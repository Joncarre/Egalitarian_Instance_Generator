{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst child_process_1 = require(\"child_process\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst artifacts_1 = require(\"../internal/artifacts\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst compilation_job_1 = require(\"../internal/solidity/compilation-job\");\n\nconst compiler_1 = require(\"../internal/solidity/compiler\");\n\nconst compiler_input_1 = require(\"../internal/solidity/compiler/compiler-input\");\n\nconst downloader_1 = require(\"../internal/solidity/compiler/downloader\");\n\nconst dependencyGraph_1 = require(\"../internal/solidity/dependencyGraph\");\n\nconst parse_1 = require(\"../internal/solidity/parse\");\n\nconst resolver_1 = require(\"../internal/solidity/resolver\");\n\nconst glob_1 = require(\"../internal/util/glob\");\n\nconst global_dir_1 = require(\"../internal/util/global-dir\");\n\nconst strings_1 = require(\"../internal/util/strings\");\n\nconst builtin_tasks_1 = require(\"../types/builtin-tasks\");\n\nconst contract_names_1 = require(\"../utils/contract-names\");\n\nconst source_names_1 = require(\"../utils/source-names\");\n\nconst task_names_1 = require(\"./task-names\");\n\nconst solidity_files_cache_1 = require(\"./utils/solidity-files-cache\");\n\nfunction isConsoleLogError(error) {\n  return error.type === \"TypeError\" && typeof error.message === \"string\" && error.message.includes(\"log\") && error.message.includes(\"type(library console)\");\n}\n\nconst log = debug_1.default(\"hardhat:core:tasks:compile\");\n/**\n * Returns a list of absolute paths to all the solidity files in the project.\n * This list doesn't include dependencies, for example solidity files inside\n * node_modules.\n *\n * This is the right task to override to change how the solidity files of the\n * project are obtained.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS, async (_, {\n  config\n}) => {\n  const paths = await glob_1.glob(path_1.default.join(config.paths.sources, \"**/*.sol\"));\n  return paths;\n});\n/**\n * Receives a list of absolute paths and returns a list of source names\n * corresponding to each path. For example, receives\n * [\"/home/user/project/contracts/Foo.sol\"] and returns\n * [\"contracts/Foo.sol\"]. These source names will be used when the solc input\n * is generated.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES).addParam(\"sourcePaths\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  sourcePaths\n}, {\n  config\n}) => {\n  const sourceNames = await Promise.all(sourcePaths.map(p => source_names_1.localPathToSourceName(config.paths.root, p)));\n  return sourceNames;\n});\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE).addParam(\"absolutePath\", undefined, undefined, config_env_1.types.string).setAction(async ({\n  absolutePath\n}) => {\n  const content = await fs_extra_1.default.readFile(absolutePath, {\n    encoding: \"utf8\"\n  });\n  return content;\n});\n/**\n * Receives a list of source names and returns a dependency graph. This task\n * is responsible for both resolving dependencies (like getting files from\n * node_modules) and generating the graph.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH).addParam(\"sourceNames\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  sourceNames,\n  solidityFilesCache\n}, {\n  config,\n  run\n}) => {\n  const parser = new parse_1.Parser(solidityFilesCache);\n  const resolver = new resolver_1.Resolver(config.paths.root, parser, absolutePath => run(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE, {\n    absolutePath\n  }));\n  const resolvedFiles = await Promise.all(sourceNames.map(sn => resolver.resolveSourceName(sn)));\n  const dependencyGraph = await dependencyGraph_1.DependencyGraph.createFromResolvedFiles(resolver, resolvedFiles);\n  return dependencyGraph;\n});\n/**\n * Receives a dependency graph and a file in it, and returns the compilation\n * job for that file. The compilation job should have everything that is\n * necessary to compile that file: a compiler config to be used and a list of\n * files to use as input of the compilation.\n *\n * If the file cannot be compiled, a MatchingCompilerFailure should be\n * returned instead.\n *\n * This is the right task to override to change the compiler configuration.\n * For example, if you want to change the compiler settings when targetting\n * rinkeby, you could do something like this:\n *\n *   const compilationJob = await runSuper();\n *   if (config.network.name === 'rinkeby') {\n *     compilationJob.solidityConfig.settings = newSettings;\n *   }\n *   return compilationJob;\n *\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE).addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any).addParam(\"file\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  dependencyGraph,\n  file\n}, {\n  config\n}) => {\n  return compilation_job_1.createCompilationJobFromFile(dependencyGraph, file, config.solidity);\n});\n/**\n * Receives a dependency graph and returns a tuple with two arrays. The first\n * array is a list of CompilationJobsSuccess, where each item has a list of\n * compilation jobs. The second array is a list of CompilationJobsFailure,\n * where each item has a list of files that couldn't be compiled, grouped by\n * the reason for the failure.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS).addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  dependencyGraph,\n  solidityFilesCache\n}, {\n  run\n}) => {\n  const connectedComponents = dependencyGraph.getConnectedComponents();\n  log(`The dependency graph was divided in '${connectedComponents.length}' connected components`);\n  const compilationJobsCreationResults = await Promise.all(connectedComponents.map(graph => compilation_job_1.createCompilationJobsFromConnectedComponent(graph, file => run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n    file,\n    dependencyGraph,\n    solidityFilesCache\n  }))));\n  let jobs = [];\n  let errors = [];\n\n  for (const result of compilationJobsCreationResults) {\n    jobs = jobs.concat(result.jobs);\n    errors = errors.concat(result.errors);\n  }\n\n  return {\n    jobs,\n    errors\n  };\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the compilation jobs might've been removed.\n *\n * This task can be overriden to change the way the cache is used, or to use\n * a different approach to filtering out compilation jobs.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"force\", undefined, undefined, config_env_1.types.boolean).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  compilationJobs,\n  force,\n  solidityFilesCache\n}) => {\n  errors_1.assertHardhatInvariant(solidityFilesCache !== undefined, \"The implementation of this task needs a defined solidityFilesCache\");\n\n  if (force) {\n    log(`force flag enabled, not filtering`);\n    return compilationJobs;\n  }\n\n  const neededCompilationJobs = compilationJobs.filter(job => needsCompilation(job, solidityFilesCache));\n  const jobsFilteredOutCount = compilationJobs.length - neededCompilationJobs.length;\n  log(`'${jobsFilteredOutCount}' jobs were filtered out`);\n  return neededCompilationJobs;\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the jobs might've been merged.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  compilationJobs\n}) => {\n  return compilation_job_1.mergeCompilationJobsWithoutBug(compilationJobs);\n});\n/**\n * Prints a message when there's nothing to compile.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async ({\n  quiet\n}) => {\n  if (!quiet) {\n    console.log(\"Nothing to compile\");\n  }\n});\n/**\n * Receives a list of compilation jobs and sends each one to be compiled.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async ({\n  compilationJobs,\n  quiet\n}, {\n  run\n}) => {\n  if (compilationJobs.length === 0) {\n    log(`No compilation jobs to compile`);\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE, {\n      quiet\n    });\n    return {\n      artifactsEmittedPerJob: []\n    };\n  } // sort compilation jobs by compiler version\n\n\n  const sortedCompilationJobs = compilationJobs.slice().sort((job1, job2) => {\n    return semver_1.default.compare(job1.getSolcConfig().version, job2.getSolcConfig().version);\n  });\n  log(`Compiling ${sortedCompilationJobs.length} jobs`);\n  const artifactsEmittedPerJob = [];\n\n  for (let i = 0; i < sortedCompilationJobs.length; i++) {\n    const compilationJob = sortedCompilationJobs[i];\n    const {\n      artifactsEmittedPerFile\n    } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n      compilationJob,\n      compilationJobs: sortedCompilationJobs,\n      compilationJobIndex: i,\n      quiet\n    });\n    artifactsEmittedPerJob.push({\n      compilationJob,\n      artifactsEmittedPerFile\n    });\n  }\n\n  return {\n    artifactsEmittedPerJob\n  };\n});\n/**\n * Receives a compilation job and returns a CompilerInput.\n *\n * It's not recommended to override this task to modify the solc\n * configuration, override\n * TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE instead.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  compilationJob\n}) => {\n  return compiler_input_1.getInputFromCompilationJob(compilationJob);\n});\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START).addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async ({\n  isCompilerDownloaded,\n  solcVersion\n}) => {\n  if (isCompilerDownloaded) {\n    return;\n  }\n\n  console.log(`Downloading compiler ${solcVersion}`);\n});\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END).addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async ({}) => {});\n/**\n * Receives a solc version and returns a path to a solc binary or to a\n * downloaded solcjs module. It also returns a flag indicating if the returned\n * path corresponds to solc or solcjs.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async ({\n  quiet,\n  solcVersion\n}, {\n  run\n}) => {\n  const compilersCache = await global_dir_1.getCompilersDir();\n  const downloader = new downloader_1.CompilerDownloader(compilersCache);\n  const isCompilerDownloaded = await downloader.isCompilerDownloaded(solcVersion);\n  const {\n    longVersion,\n    platform: desiredPlatform\n  } = await downloader.getCompilerBuild(solcVersion);\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n    solcVersion,\n    isCompilerDownloaded,\n    quiet\n  });\n  let compilerPath;\n  let platform;\n  let nativeBinaryFailed = false;\n  const compilerPathResult = await downloader.getDownloadedCompilerPath(solcVersion);\n\n  if (compilerPathResult === undefined) {\n    if (desiredPlatform === downloader_1.CompilerPlatform.WASM) {\n      // if we were trying to download solcjs and it failed, there's nothing\n      // we can do\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.CANT_GET_COMPILER, {\n        version: solcVersion\n      });\n    }\n\n    nativeBinaryFailed = true;\n  } else {\n    compilerPath = compilerPathResult.compilerPath; // when using a native binary, check that it works correctly\n    // it it doesn't, force the downloader to use solcjs\n\n    if (compilerPathResult.platform !== downloader_1.CompilerPlatform.WASM) {\n      log(\"Checking native solc binary\");\n      const solcBinaryWorks = await checkSolcBinary(compilerPathResult.compilerPath);\n\n      if (!solcBinaryWorks) {\n        log(\"Native solc binary doesn't work, using solcjs instead\");\n        nativeBinaryFailed = true;\n      }\n    }\n  }\n\n  if (nativeBinaryFailed) {\n    const solcJsDownloader = new downloader_1.CompilerDownloader(compilersCache, {\n      forceSolcJs: true\n    });\n    const solcjsCompilerPath = await solcJsDownloader.getDownloadedCompilerPath(solcVersion);\n\n    if (solcjsCompilerPath === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.CANT_GET_COMPILER, {\n        version: solcVersion\n      });\n    }\n\n    compilerPath = solcjsCompilerPath.compilerPath;\n    platform = downloader_1.CompilerPlatform.WASM;\n  }\n\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n    solcVersion,\n    isCompilerDownloaded,\n    quiet\n  });\n  const isSolcJs = platform === downloader_1.CompilerPlatform.WASM;\n  errors_1.assertHardhatInvariant(compilerPath !== undefined, \"A compilerPath should be defined at this point\");\n  return {\n    compilerPath,\n    isSolcJs,\n    version: solcVersion,\n    longVersion\n  };\n});\n/**\n * Receives an absolute path to a solcjs module and the input to be compiled,\n * and returns the generated output\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"solcJsPath\", undefined, undefined, config_env_1.types.string).setAction(async ({\n  input,\n  solcJsPath\n}) => {\n  const compiler = new compiler_1.Compiler(solcJsPath);\n  const output = await compiler.compile(input);\n  return output;\n});\n/**\n * Receives an absolute path to a solc binary and the input to be compiled,\n * and returns the generated output\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"solcPath\", undefined, undefined, config_env_1.types.string).setAction(async ({\n  input,\n  solcPath\n}) => {\n  const compiler = new compiler_1.NativeCompiler(solcPath);\n  const output = await compiler.compile(input);\n  return output;\n});\n/**\n * Receives a CompilerInput and a solc version, compiles the input using a native\n * solc binary or, if that's not possible, using solcjs. Returns the generated\n * output.\n *\n * This task can be overriden to change how solc is obtained or used.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).setAction(async ({\n  input,\n  quiet,\n  solcVersion,\n  compilationJob,\n  compilationJobs,\n  compilationJobIndex\n}, {\n  run\n}) => {\n  const solcBuild = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, {\n    quiet,\n    solcVersion\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    quiet\n  });\n  let output;\n\n  if (solcBuild.isSolcJs) {\n    output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {\n      input,\n      solcJsPath: solcBuild.compilerPath\n    });\n  } else {\n    output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC, {\n      input,\n      solcPath: solcBuild.compilerPath\n    });\n  }\n\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    output,\n    quiet\n  });\n  return {\n    output,\n    solcBuild\n  };\n});\n/**\n * This task is just a proxy to the task that compiles with solc.\n *\n * Override this to use a different task to compile a job.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, async (taskArgs, {\n  run\n}) => {\n  return run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC, taskArgs);\n});\n/**\n * Receives a compilation output and prints its errors and any other\n * information useful to the user.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async ({\n  output\n}) => {\n  var _a;\n\n  if ((output === null || output === void 0 ? void 0 : output.errors) === undefined) {\n    return;\n  }\n\n  for (const error of output.errors) {\n    if (error.severity === \"error\") {\n      const errorMessage = (_a = getFormattedInternalCompilerErrorMessage(error)) !== null && _a !== void 0 ? _a : error.formattedMessage;\n      console.error(chalk_1.default.red(errorMessage));\n    } else {\n      console.warn(chalk_1.default.yellow(error.formattedMessage));\n    }\n  }\n\n  const hasConsoleErrors = output.errors.some(isConsoleLogError);\n\n  if (hasConsoleErrors) {\n    console.error(chalk_1.default.red(`The console.log call you made isnâ€™t supported. See https://hardhat.org/console-log for the list of supported methods.`));\n    console.log();\n  }\n});\n/**\n * Receives a solc output and checks if there are errors. Throws if there are\n * errors.\n *\n * Override this task to avoid interrupting the compilation process if some\n * job has compilation errors.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async ({\n  output,\n  quiet\n}, {\n  run\n}) => {\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS, {\n    output,\n    quiet\n  });\n\n  if (hasCompilationErrors(output)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n  }\n});\n/**\n * Saves to disk the artifacts for a compilation job. These artifacts\n * include the main artifacts, the debug files, and the build info.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"solcBuild\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  compilationJob,\n  input,\n  output,\n  solcBuild\n}, {\n  artifacts,\n  run\n}) => {\n  var _a, _b;\n\n  const pathToBuildInfo = await artifacts.saveBuildInfo(compilationJob.getSolcConfig().version, solcBuild.longVersion, input, output);\n  const artifactsEmittedPerFile = [];\n\n  for (const file of compilationJob.getResolvedFiles()) {\n    log(`Emitting artifacts for file '${file.sourceName}'`);\n\n    if (!compilationJob.emitsArtifacts(file)) {\n      continue;\n    }\n\n    const artifactsEmitted = [];\n\n    for (const [contractName, contractOutput] of Object.entries((_b = (_a = output.contracts) === null || _a === void 0 ? void 0 : _a[file.sourceName]) !== null && _b !== void 0 ? _b : {})) {\n      log(`Emitting artifact for contract '${contractName}'`);\n      const artifact = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT, {\n        sourceName: file.sourceName,\n        contractName,\n        contractOutput\n      });\n      await artifacts.saveArtifactAndDebugFile(artifact, pathToBuildInfo);\n      artifactsEmitted.push(artifact.contractName);\n    }\n\n    artifactsEmittedPerFile.push({\n      file,\n      artifactsEmitted\n    });\n  }\n\n  return {\n    artifactsEmittedPerFile\n  };\n});\n/**\n * Generates the artifact for contract `contractName` given its compilation\n * output.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT).addParam(\"sourceName\", undefined, undefined, config_env_1.types.string).addParam(\"contractName\", undefined, undefined, config_env_1.types.string).addParam(\"contractOutput\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  sourceName,\n  contractName,\n  contractOutput\n}) => {\n  return artifacts_1.getArtifactFromContractOutput(sourceName, contractName, contractOutput);\n});\n/**\n * Prints a message before running soljs with some input.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async ({\n  compilationJobs,\n  compilationJobIndex\n}) => {\n  const solcVersion = compilationJobs[compilationJobIndex].getSolcConfig().version; // we log if this is the first job, or if the previous job has a\n  // different solc version\n\n  const shouldLog = compilationJobIndex === 0 || compilationJobs[compilationJobIndex - 1].getSolcConfig().version !== solcVersion;\n\n  if (!shouldLog) {\n    return;\n  } // count how many files emit artifacts for this version\n\n\n  let count = 0;\n\n  for (let i = compilationJobIndex; i < compilationJobs.length; i++) {\n    const job = compilationJobs[i];\n\n    if (job.getSolcConfig().version !== solcVersion) {\n      break;\n    }\n\n    count += job.getResolvedFiles().filter(file => job.emitsArtifacts(file)).length;\n  }\n\n  console.log(`Compiling ${count} ${strings_1.pluralize(count, \"file\")} with ${solcVersion}`);\n});\n/**\n * Prints a message after compiling some input\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async ({}) => {});\n/**\n * This is an orchestrator task that uses other subtasks to compile a\n * compilation job.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addOptionalParam(\"emitsArtifacts\", undefined, true, config_env_1.types.boolean).setAction(async ({\n  compilationJob,\n  compilationJobs,\n  compilationJobIndex,\n  quiet,\n  emitsArtifacts\n}, {\n  run\n}) => {\n  log(`Compiling job with version '${compilationJob.getSolcConfig().version}'`);\n  const input = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT, {\n    compilationJob\n  });\n  const {\n    output,\n    solcBuild\n  } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, {\n    solcVersion: compilationJob.getSolcConfig().version,\n    input,\n    quiet,\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS, {\n    output,\n    quiet\n  });\n  let artifactsEmittedPerFile = [];\n\n  if (emitsArtifacts) {\n    artifactsEmittedPerFile = (await run(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS, {\n      compilationJob,\n      input,\n      output,\n      solcBuild\n    })).artifactsEmittedPerFile;\n  }\n\n  return {\n    artifactsEmittedPerFile,\n    compilationJob,\n    input,\n    output,\n    solcBuild\n  };\n});\n/**\n * Receives a list of CompilationJobsFailure and throws an error if it's not\n * empty.\n *\n * This task could be overriden to avoid interrupting the compilation if\n * there's some part of the project that can't be compiled.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES).addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  compilationJobsCreationErrors\n}, {\n  run\n}) => {\n  const hasErrors = compilationJobsCreationErrors.length > 0;\n\n  if (hasErrors) {\n    log(`There were errors creating the compilation jobs, throwing`);\n    const reasons = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS, {\n      compilationJobsCreationErrors\n    });\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILATION_JOBS_CREATION_FAILURE, {\n      reasons\n    });\n  }\n});\n/**\n * Receives a list of CompilationJobsFailure and returns an error message\n * that describes the failure.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS).addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  compilationJobsCreationErrors: errors\n}) => {\n  var _a, _b, _c, _d;\n\n  const noCompatibleSolc = [];\n  const incompatibleOverridenSolc = [];\n  const directlyImportsIncompatibleFile = [];\n  const indirectlyImportsIncompatibleFile = [];\n  const other = [];\n\n  for (const error of errors) {\n    if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND) {\n      noCompatibleSolc.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION) {\n      incompatibleOverridenSolc.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n      directlyImportsIncompatibleFile.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n      indirectlyImportsIncompatibleFile.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR) {\n      other.push(error);\n    } else {\n      // add unrecognized errors to `other`\n      other.push(error);\n    }\n  }\n\n  let errorMessage = \"\";\n\n  if (incompatibleOverridenSolc.length > 0) {\n    errorMessage += `The compiler version for the following files is fixed through an override in your config file to a version that is incompatible with their Solidity version pragmas.\n\n`;\n\n    for (const error of incompatibleOverridenSolc) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      log(`File ${sourceName} has an incompatible overriden compiler`);\n      errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (noCompatibleSolc.length > 0) {\n    errorMessage += `The Solidity version pragma statement in these files don't match any of the configured compilers in your config. Change the pragma or configure additional compiler versions in your hardhat config.\n\n`;\n\n    for (const error of noCompatibleSolc) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      log(`File ${sourceName} doesn't match any of the configured compilers`);\n      errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (directlyImportsIncompatibleFile.length > 0) {\n    errorMessage += `These files import other files that use a different and incompatible version of Solidity:\n\n`;\n\n    for (const error of directlyImportsIncompatibleFile) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      const incompatibleDirectImportsFiles = (_b = (_a = error.extra) === null || _a === void 0 ? void 0 : _a.incompatibleDirectImports) !== null && _b !== void 0 ? _b : [];\n      const incompatibleDirectImports = incompatibleDirectImportsFiles.map(x => `${x.sourceName} (${x.content.versionPragmas.join(\" \")})`);\n      log(`File ${sourceName} imports files ${incompatibleDirectImportsFiles.map(x => x.sourceName).join(\", \")} that use an incompatible version of Solidity`);\n      let directImportsText = \"\";\n\n      if (incompatibleDirectImports.length === 1) {\n        directImportsText = ` imports ${incompatibleDirectImports[0]}`;\n      } else if (incompatibleDirectImports.length === 2) {\n        directImportsText = ` imports ${incompatibleDirectImports[0]} and ${incompatibleDirectImports[1]}`;\n      } else if (incompatibleDirectImports.length > 2) {\n        const otherImportsCount = incompatibleDirectImports.length - 2;\n        directImportsText = ` imports ${incompatibleDirectImports[0]}, ${incompatibleDirectImports[1]} and ${otherImportsCount} other ${strings_1.pluralize(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n      }\n\n      errorMessage += `  * ${sourceName} (${versionsRange})${directImportsText}\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (indirectlyImportsIncompatibleFile.length > 0) {\n    errorMessage += `These files depend on other files that use a different and incompatible version of Solidity:\n\n`;\n\n    for (const error of indirectlyImportsIncompatibleFile) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      const incompatibleIndirectImports = (_d = (_c = error.extra) === null || _c === void 0 ? void 0 : _c.incompatibleIndirectImports) !== null && _d !== void 0 ? _d : [];\n      const incompatibleImports = incompatibleIndirectImports.map(({\n        dependency\n      }) => `${dependency.sourceName} (${dependency.content.versionPragmas.join(\" \")})`);\n\n      for (const {\n        dependency,\n        path: dependencyPath\n      } of incompatibleIndirectImports) {\n        const dependencyPathText = [sourceName, ...dependencyPath.map(x => x.sourceName), dependency.sourceName].join(\" -> \");\n        log(`File ${sourceName} depends on file ${dependency.sourceName} that uses an incompatible version of Solidity\nThe dependency path is ${dependencyPathText}\n`);\n      }\n\n      let indirectImportsText = \"\";\n\n      if (incompatibleImports.length === 1) {\n        indirectImportsText = ` depends on ${incompatibleImports[0]}`;\n      } else if (incompatibleImports.length === 2) {\n        indirectImportsText = ` depends on ${incompatibleImports[0]} and ${incompatibleImports[1]}`;\n      } else if (incompatibleImports.length > 2) {\n        const otherImportsCount = incompatibleImports.length - 2;\n        indirectImportsText = ` depends on ${incompatibleImports[0]}, ${incompatibleImports[1]} and ${otherImportsCount} other ${strings_1.pluralize(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n      }\n\n      errorMessage += `  * ${sourceName} (${versionsRange})${indirectImportsText}\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (other.length > 0) {\n    errorMessage += `These files and its dependencies cannot be compiled with your config. This can happen because they have incompatible Solidity pragmas, or don't match any of your configured Solidity compilers.\n\n${other.map(x => `  * ${x.file.sourceName}`).join(\"\\n\")}\n\n`;\n  }\n\n  errorMessage += `To learn more, run the command again with --verbose\n\nRead about compiler configuration at https://hardhat.org/config\n`;\n  return errorMessage;\n});\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async ({\n  compilationJobs\n}) => {\n  if (compilationJobs.length > 0) {\n    console.log(\"Compilation finished successfully\");\n  }\n});\n/**\n * Main task for compiling the solidity files in the project.\n *\n * The main responsibility of this task is to orchestrate and connect most of\n * the subtasks related to compiling solidity.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY).addParam(\"force\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async ({\n  force,\n  quiet\n}, {\n  artifacts,\n  config,\n  run\n}) => {\n  const sourcePaths = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS);\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const solidityFilesCachePath = solidity_files_cache_1.getSolidityFilesCachePath(config.paths);\n  let solidityFilesCache = await solidity_files_cache_1.SolidityFilesCache.readFromFile(solidityFilesCachePath);\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames,\n    solidityFilesCache\n  });\n  solidityFilesCache = await invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, dependencyGraph.getResolvedFiles());\n  const compilationJobsCreationResult = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, {\n    dependencyGraph,\n    solidityFilesCache\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES, {\n    compilationJobsCreationErrors: compilationJobsCreationResult.errors\n  });\n  const compilationJobs = compilationJobsCreationResult.jobs;\n  const filteredCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS, {\n    compilationJobs,\n    force,\n    solidityFilesCache\n  });\n  const mergedCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS, {\n    compilationJobs: filteredCompilationJobs\n  });\n  const {\n    artifactsEmittedPerJob\n  } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS, {\n    compilationJobs: mergedCompilationJobs,\n    quiet\n  }); // update cache using the information about the emitted artifacts\n\n  for (const {\n    compilationJob: compilationJob,\n    artifactsEmittedPerFile: artifactsEmittedPerFile\n  } of artifactsEmittedPerJob) {\n    for (const {\n      file,\n      artifactsEmitted\n    } of artifactsEmittedPerFile) {\n      solidityFilesCache.addFile(file.absolutePath, {\n        lastModificationDate: file.lastModificationDate.valueOf(),\n        contentHash: file.contentHash,\n        sourceName: file.sourceName,\n        solcConfig: compilationJob.getSolcConfig(),\n        imports: file.content.imports,\n        versionPragmas: file.content.versionPragmas,\n        artifacts: artifactsEmitted\n      });\n    }\n  }\n\n  const allArtifactsEmittedPerFile = solidityFilesCache.getEntries(); // We know this is the actual implementation, so we use some\n  // non-public methods here.\n\n  const artifactsImpl = artifacts;\n  await artifactsImpl.removeObsoleteArtifacts(allArtifactsEmittedPerFile);\n  await artifactsImpl.removeObsoleteBuildInfos();\n  await solidityFilesCache.writeToFile(solidityFilesCachePath);\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, {\n    compilationJobs: mergedCompilationJobs,\n    quiet\n  });\n});\n/**\n * Returns a list of compilation tasks.\n *\n * This is the task to override to add support for other languages.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS, async () => {\n  return [task_names_1.TASK_COMPILE_SOLIDITY];\n});\n/**\n * Main compile task.\n *\n * This is a meta-task that just gets all the compilation tasks and runs them.\n * Right now there's only a \"compile solidity\" task.\n */\n\nconfig_env_1.task(task_names_1.TASK_COMPILE, \"Compiles the entire project, building all artifacts\").addFlag(\"force\", \"Force compilation ignoring cache\").addFlag(\"quiet\", \"Makes the compilation process less verbose\").setAction(async (compilationArgs, {\n  run\n}) => {\n  const compilationTasks = await run(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS);\n\n  for (const compilationTask of compilationTasks) {\n    await run(compilationTask, compilationArgs);\n  }\n});\n/**\n * If a file is present in the cache, but some of its artifacts are missing on\n * disk, we remove it from the cache to force it to be recompiled.\n */\n\nasync function invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, resolvedFiles) {\n  for (const file of resolvedFiles) {\n    const cacheEntry = solidityFilesCache.getEntry(file.absolutePath);\n\n    if (cacheEntry === undefined) {\n      continue;\n    }\n\n    const {\n      artifacts: emittedArtifacts\n    } = cacheEntry;\n\n    for (const emittedArtifact of emittedArtifacts) {\n      const artifactExists = await artifacts.artifactExists(contract_names_1.getFullyQualifiedName(file.sourceName, emittedArtifact));\n\n      if (!artifactExists) {\n        log(`Invalidate cache for '${file.absolutePath}' because artifact '${emittedArtifact}' doesn't exist`);\n        solidityFilesCache.removeEntry(file.absolutePath);\n        break;\n      }\n    }\n  }\n\n  return solidityFilesCache;\n}\n/**\n * Checks if the given compilation job needs to be done.\n */\n\n\nfunction needsCompilation(job, cache) {\n  for (const file of job.getResolvedFiles()) {\n    const hasChanged = cache.hasFileChanged(file.absolutePath, file.contentHash, // we only check if the solcConfig is different for files that\n    // emit artifacts\n    job.emitsArtifacts(file) ? job.getSolcConfig() : undefined);\n\n    if (hasChanged) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasCompilationErrors(output) {\n  return output.errors && output.errors.some(x => x.severity === \"error\");\n}\n\nasync function checkSolcBinary(solcPath) {\n  return new Promise(resolve => {\n    const process = child_process_1.exec(`${solcPath} --version`);\n    process.on(\"exit\", code => {\n      resolve(code === 0);\n    });\n  });\n}\n/**\n * This function returns a properly formatted Internal Compiler Error message.\n *\n * This is present due to a bug in Solidity. See: https://github.com/ethereum/solidity/issues/9926\n *\n * If the error is not an ICE, or if it's properly formatted, this function returns undefined.\n */\n\n\nfunction getFormattedInternalCompilerErrorMessage(error) {\n  if (error.formattedMessage.trim() !== \"InternalCompilerError:\") {\n    return;\n  } // We trim any final `:`, as we found some at the end of the error messages,\n  // and then trim just in case a blank space was left\n\n\n  return `${error.type}: ${error.message}`.replace(/[:\\s]*$/g, \"\").trim();\n}","map":{"version":3,"sources":["../src/builtin-tasks/compile.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chalk_1 = __importDefault(require(\"chalk\"));\nconst child_process_1 = require(\"child_process\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst semver_1 = __importDefault(require(\"semver\"));\nconst artifacts_1 = require(\"../internal/artifacts\");\nconst config_env_1 = require(\"../internal/core/config/config-env\");\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\nconst compilation_job_1 = require(\"../internal/solidity/compilation-job\");\nconst compiler_1 = require(\"../internal/solidity/compiler\");\nconst compiler_input_1 = require(\"../internal/solidity/compiler/compiler-input\");\nconst downloader_1 = require(\"../internal/solidity/compiler/downloader\");\nconst dependencyGraph_1 = require(\"../internal/solidity/dependencyGraph\");\nconst parse_1 = require(\"../internal/solidity/parse\");\nconst resolver_1 = require(\"../internal/solidity/resolver\");\nconst glob_1 = require(\"../internal/util/glob\");\nconst global_dir_1 = require(\"../internal/util/global-dir\");\nconst strings_1 = require(\"../internal/util/strings\");\nconst builtin_tasks_1 = require(\"../types/builtin-tasks\");\nconst contract_names_1 = require(\"../utils/contract-names\");\nconst source_names_1 = require(\"../utils/source-names\");\nconst task_names_1 = require(\"./task-names\");\nconst solidity_files_cache_1 = require(\"./utils/solidity-files-cache\");\nfunction isConsoleLogError(error) {\n    return (error.type === \"TypeError\" &&\n        typeof error.message === \"string\" &&\n        error.message.includes(\"log\") &&\n        error.message.includes(\"type(library console)\"));\n}\nconst log = debug_1.default(\"hardhat:core:tasks:compile\");\n/**\n * Returns a list of absolute paths to all the solidity files in the project.\n * This list doesn't include dependencies, for example solidity files inside\n * node_modules.\n *\n * This is the right task to override to change how the solidity files of the\n * project are obtained.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS, async (_, { config }) => {\n    const paths = await glob_1.glob(path_1.default.join(config.paths.sources, \"**/*.sol\"));\n    return paths;\n});\n/**\n * Receives a list of absolute paths and returns a list of source names\n * corresponding to each path. For example, receives\n * [\"/home/user/project/contracts/Foo.sol\"] and returns\n * [\"contracts/Foo.sol\"]. These source names will be used when the solc input\n * is generated.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES)\n    .addParam(\"sourcePaths\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ sourcePaths }, { config }) => {\n    const sourceNames = await Promise.all(sourcePaths.map((p) => source_names_1.localPathToSourceName(config.paths.root, p)));\n    return sourceNames;\n});\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE)\n    .addParam(\"absolutePath\", undefined, undefined, config_env_1.types.string)\n    .setAction(async ({ absolutePath }) => {\n    const content = await fs_extra_1.default.readFile(absolutePath, {\n        encoding: \"utf8\",\n    });\n    return content;\n});\n/**\n * Receives a list of source names and returns a dependency graph. This task\n * is responsible for both resolving dependencies (like getting files from\n * node_modules) and generating the graph.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH)\n    .addParam(\"sourceNames\", undefined, undefined, config_env_1.types.any)\n    .addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ sourceNames, solidityFilesCache, }, { config, run }) => {\n    const parser = new parse_1.Parser(solidityFilesCache);\n    const resolver = new resolver_1.Resolver(config.paths.root, parser, (absolutePath) => run(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE, { absolutePath }));\n    const resolvedFiles = await Promise.all(sourceNames.map((sn) => resolver.resolveSourceName(sn)));\n    const dependencyGraph = await dependencyGraph_1.DependencyGraph.createFromResolvedFiles(resolver, resolvedFiles);\n    return dependencyGraph;\n});\n/**\n * Receives a dependency graph and a file in it, and returns the compilation\n * job for that file. The compilation job should have everything that is\n * necessary to compile that file: a compiler config to be used and a list of\n * files to use as input of the compilation.\n *\n * If the file cannot be compiled, a MatchingCompilerFailure should be\n * returned instead.\n *\n * This is the right task to override to change the compiler configuration.\n * For example, if you want to change the compiler settings when targetting\n * rinkeby, you could do something like this:\n *\n *   const compilationJob = await runSuper();\n *   if (config.network.name === 'rinkeby') {\n *     compilationJob.solidityConfig.settings = newSettings;\n *   }\n *   return compilationJob;\n *\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE)\n    .addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"file\", undefined, undefined, config_env_1.types.any)\n    .addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ dependencyGraph, file, }, { config }) => {\n    return compilation_job_1.createCompilationJobFromFile(dependencyGraph, file, config.solidity);\n});\n/**\n * Receives a dependency graph and returns a tuple with two arrays. The first\n * array is a list of CompilationJobsSuccess, where each item has a list of\n * compilation jobs. The second array is a list of CompilationJobsFailure,\n * where each item has a list of files that couldn't be compiled, grouped by\n * the reason for the failure.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS)\n    .addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any)\n    .addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ dependencyGraph, solidityFilesCache, }, { run }) => {\n    const connectedComponents = dependencyGraph.getConnectedComponents();\n    log(`The dependency graph was divided in '${connectedComponents.length}' connected components`);\n    const compilationJobsCreationResults = await Promise.all(connectedComponents.map((graph) => compilation_job_1.createCompilationJobsFromConnectedComponent(graph, (file) => run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n        file,\n        dependencyGraph,\n        solidityFilesCache,\n    }))));\n    let jobs = [];\n    let errors = [];\n    for (const result of compilationJobsCreationResults) {\n        jobs = jobs.concat(result.jobs);\n        errors = errors.concat(result.errors);\n    }\n    return { jobs, errors };\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the compilation jobs might've been removed.\n *\n * This task can be overriden to change the way the cache is used, or to use\n * a different approach to filtering out compilation jobs.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS)\n    .addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"force\", undefined, undefined, config_env_1.types.boolean)\n    .addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ compilationJobs, force, solidityFilesCache, }) => {\n    errors_1.assertHardhatInvariant(solidityFilesCache !== undefined, \"The implementation of this task needs a defined solidityFilesCache\");\n    if (force) {\n        log(`force flag enabled, not filtering`);\n        return compilationJobs;\n    }\n    const neededCompilationJobs = compilationJobs.filter((job) => needsCompilation(job, solidityFilesCache));\n    const jobsFilteredOutCount = compilationJobs.length - neededCompilationJobs.length;\n    log(`'${jobsFilteredOutCount}' jobs were filtered out`);\n    return neededCompilationJobs;\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the jobs might've been merged.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS)\n    .addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ compilationJobs, }) => {\n    return compilation_job_1.mergeCompilationJobsWithoutBug(compilationJobs);\n});\n/**\n * Prints a message when there's nothing to compile.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .setAction(async ({ quiet }) => {\n    if (!quiet) {\n        console.log(\"Nothing to compile\");\n    }\n});\n/**\n * Receives a list of compilation jobs and sends each one to be compiled.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS)\n    .addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .setAction(async ({ compilationJobs, quiet, }, { run }) => {\n    if (compilationJobs.length === 0) {\n        log(`No compilation jobs to compile`);\n        await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE, { quiet });\n        return { artifactsEmittedPerJob: [] };\n    }\n    // sort compilation jobs by compiler version\n    const sortedCompilationJobs = compilationJobs\n        .slice()\n        .sort((job1, job2) => {\n        return semver_1.default.compare(job1.getSolcConfig().version, job2.getSolcConfig().version);\n    });\n    log(`Compiling ${sortedCompilationJobs.length} jobs`);\n    const artifactsEmittedPerJob = [];\n    for (let i = 0; i < sortedCompilationJobs.length; i++) {\n        const compilationJob = sortedCompilationJobs[i];\n        const { artifactsEmittedPerFile } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n            compilationJob,\n            compilationJobs: sortedCompilationJobs,\n            compilationJobIndex: i,\n            quiet,\n        });\n        artifactsEmittedPerJob.push({\n            compilationJob,\n            artifactsEmittedPerFile,\n        });\n    }\n    return { artifactsEmittedPerJob };\n});\n/**\n * Receives a compilation job and returns a CompilerInput.\n *\n * It's not recommended to override this task to modify the solc\n * configuration, override\n * TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE instead.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT)\n    .addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ compilationJob, }) => {\n    return compiler_input_1.getInputFromCompilationJob(compilationJob);\n});\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START)\n    .addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string)\n    .setAction(async ({ isCompilerDownloaded, solcVersion, }) => {\n    if (isCompilerDownloaded) {\n        return;\n    }\n    console.log(`Downloading compiler ${solcVersion}`);\n});\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END)\n    .addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string)\n    .setAction(async ({}) => { });\n/**\n * Receives a solc version and returns a path to a solc binary or to a\n * downloaded solcjs module. It also returns a flag indicating if the returned\n * path corresponds to solc or solcjs.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string)\n    .setAction(async ({ quiet, solcVersion, }, { run }) => {\n    const compilersCache = await global_dir_1.getCompilersDir();\n    const downloader = new downloader_1.CompilerDownloader(compilersCache);\n    const isCompilerDownloaded = await downloader.isCompilerDownloaded(solcVersion);\n    const { longVersion, platform: desiredPlatform } = await downloader.getCompilerBuild(solcVersion);\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n        solcVersion,\n        isCompilerDownloaded,\n        quiet,\n    });\n    let compilerPath;\n    let platform;\n    let nativeBinaryFailed = false;\n    const compilerPathResult = await downloader.getDownloadedCompilerPath(solcVersion);\n    if (compilerPathResult === undefined) {\n        if (desiredPlatform === downloader_1.CompilerPlatform.WASM) {\n            // if we were trying to download solcjs and it failed, there's nothing\n            // we can do\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.CANT_GET_COMPILER, {\n                version: solcVersion,\n            });\n        }\n        nativeBinaryFailed = true;\n    }\n    else {\n        compilerPath = compilerPathResult.compilerPath;\n        // when using a native binary, check that it works correctly\n        // it it doesn't, force the downloader to use solcjs\n        if (compilerPathResult.platform !== downloader_1.CompilerPlatform.WASM) {\n            log(\"Checking native solc binary\");\n            const solcBinaryWorks = await checkSolcBinary(compilerPathResult.compilerPath);\n            if (!solcBinaryWorks) {\n                log(\"Native solc binary doesn't work, using solcjs instead\");\n                nativeBinaryFailed = true;\n            }\n        }\n    }\n    if (nativeBinaryFailed) {\n        const solcJsDownloader = new downloader_1.CompilerDownloader(compilersCache, {\n            forceSolcJs: true,\n        });\n        const solcjsCompilerPath = await solcJsDownloader.getDownloadedCompilerPath(solcVersion);\n        if (solcjsCompilerPath === undefined) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.CANT_GET_COMPILER, {\n                version: solcVersion,\n            });\n        }\n        compilerPath = solcjsCompilerPath.compilerPath;\n        platform = downloader_1.CompilerPlatform.WASM;\n    }\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n        solcVersion,\n        isCompilerDownloaded,\n        quiet,\n    });\n    const isSolcJs = platform === downloader_1.CompilerPlatform.WASM;\n    errors_1.assertHardhatInvariant(compilerPath !== undefined, \"A compilerPath should be defined at this point\");\n    return { compilerPath, isSolcJs, version: solcVersion, longVersion };\n});\n/**\n * Receives an absolute path to a solcjs module and the input to be compiled,\n * and returns the generated output\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS)\n    .addParam(\"input\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"solcJsPath\", undefined, undefined, config_env_1.types.string)\n    .setAction(async ({ input, solcJsPath, }) => {\n    const compiler = new compiler_1.Compiler(solcJsPath);\n    const output = await compiler.compile(input);\n    return output;\n});\n/**\n * Receives an absolute path to a solc binary and the input to be compiled,\n * and returns the generated output\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC)\n    .addParam(\"input\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"solcPath\", undefined, undefined, config_env_1.types.string)\n    .setAction(async ({ input, solcPath }) => {\n    const compiler = new compiler_1.NativeCompiler(solcPath);\n    const output = await compiler.compile(input);\n    return output;\n});\n/**\n * Receives a CompilerInput and a solc version, compiles the input using a native\n * solc binary or, if that's not possible, using solcjs. Returns the generated\n * output.\n *\n * This task can be overriden to change how solc is obtained or used.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC)\n    .addParam(\"input\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string)\n    .addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int)\n    .setAction(async ({ input, quiet, solcVersion, compilationJob, compilationJobs, compilationJobIndex, }, { run }) => {\n    const solcBuild = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, {\n        quiet,\n        solcVersion,\n    });\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet,\n    });\n    let output;\n    if (solcBuild.isSolcJs) {\n        output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {\n            input,\n            solcJsPath: solcBuild.compilerPath,\n        });\n    }\n    else {\n        output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC, {\n            input,\n            solcPath: solcBuild.compilerPath,\n        });\n    }\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        output,\n        quiet,\n    });\n    return { output, solcBuild };\n});\n/**\n * This task is just a proxy to the task that compiles with solc.\n *\n * Override this to use a different task to compile a job.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, async (taskArgs, { run }) => {\n    return run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC, taskArgs);\n});\n/**\n * Receives a compilation output and prints its errors and any other\n * information useful to the user.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS)\n    .addParam(\"output\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .setAction(async ({ output }) => {\n    var _a;\n    if ((output === null || output === void 0 ? void 0 : output.errors) === undefined) {\n        return;\n    }\n    for (const error of output.errors) {\n        if (error.severity === \"error\") {\n            const errorMessage = (_a = getFormattedInternalCompilerErrorMessage(error)) !== null && _a !== void 0 ? _a : error.formattedMessage;\n            console.error(chalk_1.default.red(errorMessage));\n        }\n        else {\n            console.warn(chalk_1.default.yellow(error.formattedMessage));\n        }\n    }\n    const hasConsoleErrors = output.errors.some(isConsoleLogError);\n    if (hasConsoleErrors) {\n        console.error(chalk_1.default.red(`The console.log call you made isnâ€™t supported. See https://hardhat.org/console-log for the list of supported methods.`));\n        console.log();\n    }\n});\n/**\n * Receives a solc output and checks if there are errors. Throws if there are\n * errors.\n *\n * Override this task to avoid interrupting the compilation process if some\n * job has compilation errors.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS)\n    .addParam(\"output\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .setAction(async ({ output, quiet }, { run }) => {\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS, {\n        output,\n        quiet,\n    });\n    if (hasCompilationErrors(output)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n    }\n});\n/**\n * Saves to disk the artifacts for a compilation job. These artifacts\n * include the main artifacts, the debug files, and the build info.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS)\n    .addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"input\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"output\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"solcBuild\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ compilationJob, input, output, solcBuild, }, { artifacts, run }) => {\n    var _a, _b;\n    const pathToBuildInfo = await artifacts.saveBuildInfo(compilationJob.getSolcConfig().version, solcBuild.longVersion, input, output);\n    const artifactsEmittedPerFile = [];\n    for (const file of compilationJob.getResolvedFiles()) {\n        log(`Emitting artifacts for file '${file.sourceName}'`);\n        if (!compilationJob.emitsArtifacts(file)) {\n            continue;\n        }\n        const artifactsEmitted = [];\n        for (const [contractName, contractOutput] of Object.entries((_b = (_a = output.contracts) === null || _a === void 0 ? void 0 : _a[file.sourceName]) !== null && _b !== void 0 ? _b : {})) {\n            log(`Emitting artifact for contract '${contractName}'`);\n            const artifact = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT, {\n                sourceName: file.sourceName,\n                contractName,\n                contractOutput,\n            });\n            await artifacts.saveArtifactAndDebugFile(artifact, pathToBuildInfo);\n            artifactsEmitted.push(artifact.contractName);\n        }\n        artifactsEmittedPerFile.push({\n            file,\n            artifactsEmitted,\n        });\n    }\n    return { artifactsEmittedPerFile };\n});\n/**\n * Generates the artifact for contract `contractName` given its compilation\n * output.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT)\n    .addParam(\"sourceName\", undefined, undefined, config_env_1.types.string)\n    .addParam(\"contractName\", undefined, undefined, config_env_1.types.string)\n    .addParam(\"contractOutput\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ sourceName, contractName, contractOutput, }) => {\n    return artifacts_1.getArtifactFromContractOutput(sourceName, contractName, contractOutput);\n});\n/**\n * Prints a message before running soljs with some input.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START)\n    .addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .setAction(async ({ compilationJobs, compilationJobIndex, }) => {\n    const solcVersion = compilationJobs[compilationJobIndex].getSolcConfig().version;\n    // we log if this is the first job, or if the previous job has a\n    // different solc version\n    const shouldLog = compilationJobIndex === 0 ||\n        compilationJobs[compilationJobIndex - 1].getSolcConfig().version !==\n            solcVersion;\n    if (!shouldLog) {\n        return;\n    }\n    // count how many files emit artifacts for this version\n    let count = 0;\n    for (let i = compilationJobIndex; i < compilationJobs.length; i++) {\n        const job = compilationJobs[i];\n        if (job.getSolcConfig().version !== solcVersion) {\n            break;\n        }\n        count += job\n            .getResolvedFiles()\n            .filter((file) => job.emitsArtifacts(file)).length;\n    }\n    console.log(`Compiling ${count} ${strings_1.pluralize(count, \"file\")} with ${solcVersion}`);\n});\n/**\n * Prints a message after compiling some input\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END)\n    .addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int)\n    .addParam(\"output\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .setAction(async ({}) => { });\n/**\n * This is an orchestrator task that uses other subtasks to compile a\n * compilation job.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB)\n    .addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .addOptionalParam(\"emitsArtifacts\", undefined, true, config_env_1.types.boolean)\n    .setAction(async ({ compilationJob, compilationJobs, compilationJobIndex, quiet, emitsArtifacts, }, { run }) => {\n    log(`Compiling job with version '${compilationJob.getSolcConfig().version}'`);\n    const input = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT, {\n        compilationJob,\n    });\n    const { output, solcBuild } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, {\n        solcVersion: compilationJob.getSolcConfig().version,\n        input,\n        quiet,\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n    });\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS, { output, quiet });\n    let artifactsEmittedPerFile = [];\n    if (emitsArtifacts) {\n        artifactsEmittedPerFile = (await run(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS, {\n            compilationJob,\n            input,\n            output,\n            solcBuild,\n        })).artifactsEmittedPerFile;\n    }\n    return {\n        artifactsEmittedPerFile,\n        compilationJob,\n        input,\n        output,\n        solcBuild,\n    };\n});\n/**\n * Receives a list of CompilationJobsFailure and throws an error if it's not\n * empty.\n *\n * This task could be overriden to avoid interrupting the compilation if\n * there's some part of the project that can't be compiled.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES)\n    .addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ compilationJobsCreationErrors, }, { run }) => {\n    const hasErrors = compilationJobsCreationErrors.length > 0;\n    if (hasErrors) {\n        log(`There were errors creating the compilation jobs, throwing`);\n        const reasons = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS, { compilationJobsCreationErrors });\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILATION_JOBS_CREATION_FAILURE, {\n            reasons,\n        });\n    }\n});\n/**\n * Receives a list of CompilationJobsFailure and returns an error message\n * that describes the failure.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS)\n    .addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ compilationJobsCreationErrors: errors, }) => {\n    var _a, _b, _c, _d;\n    const noCompatibleSolc = [];\n    const incompatibleOverridenSolc = [];\n    const directlyImportsIncompatibleFile = [];\n    const indirectlyImportsIncompatibleFile = [];\n    const other = [];\n    for (const error of errors) {\n        if (error.reason ===\n            builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND) {\n            noCompatibleSolc.push(error);\n        }\n        else if (error.reason ===\n            builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION) {\n            incompatibleOverridenSolc.push(error);\n        }\n        else if (error.reason ===\n            builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n            directlyImportsIncompatibleFile.push(error);\n        }\n        else if (error.reason ===\n            builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n            indirectlyImportsIncompatibleFile.push(error);\n        }\n        else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR) {\n            other.push(error);\n        }\n        else {\n            // add unrecognized errors to `other`\n            other.push(error);\n        }\n    }\n    let errorMessage = \"\";\n    if (incompatibleOverridenSolc.length > 0) {\n        errorMessage += `The compiler version for the following files is fixed through an override in your config file to a version that is incompatible with their Solidity version pragmas.\n\n`;\n        for (const error of incompatibleOverridenSolc) {\n            const { sourceName } = error.file;\n            const { versionPragmas } = error.file.content;\n            const versionsRange = versionPragmas.join(\" \");\n            log(`File ${sourceName} has an incompatible overriden compiler`);\n            errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n        }\n        errorMessage += \"\\n\";\n    }\n    if (noCompatibleSolc.length > 0) {\n        errorMessage += `The Solidity version pragma statement in these files don't match any of the configured compilers in your config. Change the pragma or configure additional compiler versions in your hardhat config.\n\n`;\n        for (const error of noCompatibleSolc) {\n            const { sourceName } = error.file;\n            const { versionPragmas } = error.file.content;\n            const versionsRange = versionPragmas.join(\" \");\n            log(`File ${sourceName} doesn't match any of the configured compilers`);\n            errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n        }\n        errorMessage += \"\\n\";\n    }\n    if (directlyImportsIncompatibleFile.length > 0) {\n        errorMessage += `These files import other files that use a different and incompatible version of Solidity:\n\n`;\n        for (const error of directlyImportsIncompatibleFile) {\n            const { sourceName } = error.file;\n            const { versionPragmas } = error.file.content;\n            const versionsRange = versionPragmas.join(\" \");\n            const incompatibleDirectImportsFiles = (_b = (_a = error.extra) === null || _a === void 0 ? void 0 : _a.incompatibleDirectImports) !== null && _b !== void 0 ? _b : [];\n            const incompatibleDirectImports = incompatibleDirectImportsFiles.map((x) => `${x.sourceName} (${x.content.versionPragmas.join(\" \")})`);\n            log(`File ${sourceName} imports files ${incompatibleDirectImportsFiles\n                .map((x) => x.sourceName)\n                .join(\", \")} that use an incompatible version of Solidity`);\n            let directImportsText = \"\";\n            if (incompatibleDirectImports.length === 1) {\n                directImportsText = ` imports ${incompatibleDirectImports[0]}`;\n            }\n            else if (incompatibleDirectImports.length === 2) {\n                directImportsText = ` imports ${incompatibleDirectImports[0]} and ${incompatibleDirectImports[1]}`;\n            }\n            else if (incompatibleDirectImports.length > 2) {\n                const otherImportsCount = incompatibleDirectImports.length - 2;\n                directImportsText = ` imports ${incompatibleDirectImports[0]}, ${incompatibleDirectImports[1]} and ${otherImportsCount} other ${strings_1.pluralize(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n            }\n            errorMessage += `  * ${sourceName} (${versionsRange})${directImportsText}\\n`;\n        }\n        errorMessage += \"\\n\";\n    }\n    if (indirectlyImportsIncompatibleFile.length > 0) {\n        errorMessage += `These files depend on other files that use a different and incompatible version of Solidity:\n\n`;\n        for (const error of indirectlyImportsIncompatibleFile) {\n            const { sourceName } = error.file;\n            const { versionPragmas } = error.file.content;\n            const versionsRange = versionPragmas.join(\" \");\n            const incompatibleIndirectImports = (_d = (_c = error.extra) === null || _c === void 0 ? void 0 : _c.incompatibleIndirectImports) !== null && _d !== void 0 ? _d : [];\n            const incompatibleImports = incompatibleIndirectImports.map(({ dependency }) => `${dependency.sourceName} (${dependency.content.versionPragmas.join(\" \")})`);\n            for (const { dependency, path: dependencyPath, } of incompatibleIndirectImports) {\n                const dependencyPathText = [\n                    sourceName,\n                    ...dependencyPath.map((x) => x.sourceName),\n                    dependency.sourceName,\n                ].join(\" -> \");\n                log(`File ${sourceName} depends on file ${dependency.sourceName} that uses an incompatible version of Solidity\nThe dependency path is ${dependencyPathText}\n`);\n            }\n            let indirectImportsText = \"\";\n            if (incompatibleImports.length === 1) {\n                indirectImportsText = ` depends on ${incompatibleImports[0]}`;\n            }\n            else if (incompatibleImports.length === 2) {\n                indirectImportsText = ` depends on ${incompatibleImports[0]} and ${incompatibleImports[1]}`;\n            }\n            else if (incompatibleImports.length > 2) {\n                const otherImportsCount = incompatibleImports.length - 2;\n                indirectImportsText = ` depends on ${incompatibleImports[0]}, ${incompatibleImports[1]} and ${otherImportsCount} other ${strings_1.pluralize(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n            }\n            errorMessage += `  * ${sourceName} (${versionsRange})${indirectImportsText}\\n`;\n        }\n        errorMessage += \"\\n\";\n    }\n    if (other.length > 0) {\n        errorMessage += `These files and its dependencies cannot be compiled with your config. This can happen because they have incompatible Solidity pragmas, or don't match any of your configured Solidity compilers.\n\n${other.map((x) => `  * ${x.file.sourceName}`).join(\"\\n\")}\n\n`;\n    }\n    errorMessage += `To learn more, run the command again with --verbose\n\nRead about compiler configuration at https://hardhat.org/config\n`;\n    return errorMessage;\n});\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT)\n    .addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .setAction(async ({ compilationJobs }) => {\n    if (compilationJobs.length > 0) {\n        console.log(\"Compilation finished successfully\");\n    }\n});\n/**\n * Main task for compiling the solidity files in the project.\n *\n * The main responsibility of this task is to orchestrate and connect most of\n * the subtasks related to compiling solidity.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_SOLIDITY)\n    .addParam(\"force\", undefined, undefined, config_env_1.types.boolean)\n    .addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean)\n    .setAction(async ({ force, quiet }, { artifacts, config, run }) => {\n    const sourcePaths = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS);\n    const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n        sourcePaths,\n    });\n    const solidityFilesCachePath = solidity_files_cache_1.getSolidityFilesCachePath(config.paths);\n    let solidityFilesCache = await solidity_files_cache_1.SolidityFilesCache.readFromFile(solidityFilesCachePath);\n    const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, { sourceNames, solidityFilesCache });\n    solidityFilesCache = await invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, dependencyGraph.getResolvedFiles());\n    const compilationJobsCreationResult = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, {\n        dependencyGraph,\n        solidityFilesCache,\n    });\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES, {\n        compilationJobsCreationErrors: compilationJobsCreationResult.errors,\n    });\n    const compilationJobs = compilationJobsCreationResult.jobs;\n    const filteredCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS, { compilationJobs, force, solidityFilesCache });\n    const mergedCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS, { compilationJobs: filteredCompilationJobs });\n    const { artifactsEmittedPerJob, } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS, {\n        compilationJobs: mergedCompilationJobs,\n        quiet,\n    });\n    // update cache using the information about the emitted artifacts\n    for (const { compilationJob: compilationJob, artifactsEmittedPerFile: artifactsEmittedPerFile, } of artifactsEmittedPerJob) {\n        for (const { file, artifactsEmitted } of artifactsEmittedPerFile) {\n            solidityFilesCache.addFile(file.absolutePath, {\n                lastModificationDate: file.lastModificationDate.valueOf(),\n                contentHash: file.contentHash,\n                sourceName: file.sourceName,\n                solcConfig: compilationJob.getSolcConfig(),\n                imports: file.content.imports,\n                versionPragmas: file.content.versionPragmas,\n                artifacts: artifactsEmitted,\n            });\n        }\n    }\n    const allArtifactsEmittedPerFile = solidityFilesCache.getEntries();\n    // We know this is the actual implementation, so we use some\n    // non-public methods here.\n    const artifactsImpl = artifacts;\n    await artifactsImpl.removeObsoleteArtifacts(allArtifactsEmittedPerFile);\n    await artifactsImpl.removeObsoleteBuildInfos();\n    await solidityFilesCache.writeToFile(solidityFilesCachePath);\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, {\n        compilationJobs: mergedCompilationJobs,\n        quiet,\n    });\n});\n/**\n * Returns a list of compilation tasks.\n *\n * This is the task to override to add support for other languages.\n */\nconfig_env_1.subtask(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS, async () => {\n    return [task_names_1.TASK_COMPILE_SOLIDITY];\n});\n/**\n * Main compile task.\n *\n * This is a meta-task that just gets all the compilation tasks and runs them.\n * Right now there's only a \"compile solidity\" task.\n */\nconfig_env_1.task(task_names_1.TASK_COMPILE, \"Compiles the entire project, building all artifacts\")\n    .addFlag(\"force\", \"Force compilation ignoring cache\")\n    .addFlag(\"quiet\", \"Makes the compilation process less verbose\")\n    .setAction(async (compilationArgs, { run }) => {\n    const compilationTasks = await run(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS);\n    for (const compilationTask of compilationTasks) {\n        await run(compilationTask, compilationArgs);\n    }\n});\n/**\n * If a file is present in the cache, but some of its artifacts are missing on\n * disk, we remove it from the cache to force it to be recompiled.\n */\nasync function invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, resolvedFiles) {\n    for (const file of resolvedFiles) {\n        const cacheEntry = solidityFilesCache.getEntry(file.absolutePath);\n        if (cacheEntry === undefined) {\n            continue;\n        }\n        const { artifacts: emittedArtifacts } = cacheEntry;\n        for (const emittedArtifact of emittedArtifacts) {\n            const artifactExists = await artifacts.artifactExists(contract_names_1.getFullyQualifiedName(file.sourceName, emittedArtifact));\n            if (!artifactExists) {\n                log(`Invalidate cache for '${file.absolutePath}' because artifact '${emittedArtifact}' doesn't exist`);\n                solidityFilesCache.removeEntry(file.absolutePath);\n                break;\n            }\n        }\n    }\n    return solidityFilesCache;\n}\n/**\n * Checks if the given compilation job needs to be done.\n */\nfunction needsCompilation(job, cache) {\n    for (const file of job.getResolvedFiles()) {\n        const hasChanged = cache.hasFileChanged(file.absolutePath, file.contentHash, \n        // we only check if the solcConfig is different for files that\n        // emit artifacts\n        job.emitsArtifacts(file) ? job.getSolcConfig() : undefined);\n        if (hasChanged) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hasCompilationErrors(output) {\n    return (output.errors && output.errors.some((x) => x.severity === \"error\"));\n}\nasync function checkSolcBinary(solcPath) {\n    return new Promise((resolve) => {\n        const process = child_process_1.exec(`${solcPath} --version`);\n        process.on(\"exit\", (code) => {\n            resolve(code === 0);\n        });\n    });\n}\n/**\n * This function returns a properly formatted Internal Compiler Error message.\n *\n * This is present due to a bug in Solidity. See: https://github.com/ethereum/solidity/issues/9926\n *\n * If the error is not an ICE, or if it's properly formatted, this function returns undefined.\n */\nfunction getFormattedInternalCompilerErrorMessage(error) {\n    if (error.formattedMessage.trim() !== \"InternalCompilerError:\") {\n        return;\n    }\n    // We trim any final `:`, as we found some at the end of the error messages,\n    // and then trim just in case a blank space was left\n    return `${error.type}: ${error.message}`.replace(/[:\\s]*$/g, \"\").trim();\n}\n//# sourceMappingURL=compile.js.map"]},"metadata":{},"sourceType":"script"}