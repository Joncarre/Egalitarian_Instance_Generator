{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.weiToHumanReadableString = void 0;\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n/**\n * This function turns a wei value in a human readable string. It shows values\n * in ETH, gwei or wei, depending on how large it is.\n *\n * It never show more than 99999 wei or gwei, moving to the larger denominator\n * when necessary.\n *\n * It never shows more than 4 decimal digits. Adapting denominator and\n * truncating as necessary.\n */\n\n\nfunction weiToHumanReadableString(wei) {\n  if (typeof wei === \"number\") {\n    wei = new ethereumjs_util_1.BN(wei);\n  }\n\n  if (wei.eqn(0)) {\n    return \"0 ETH\";\n  }\n\n  if (wei.lt(new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(5)))) {\n    return `${wei} wei`;\n  }\n\n  if (wei.lt(new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(14)))) {\n    return `${toDecimalString(wei, 9, 4)} gwei`;\n  }\n\n  return `${toDecimalString(wei, 18, 4)} ETH`;\n}\n\nexports.weiToHumanReadableString = weiToHumanReadableString;\n\nfunction toDecimalString(value, digitsToInteger, decimalDigits = 4) {\n  const oneUnit = new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(digitsToInteger));\n  const oneDecimal = new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(digitsToInteger - decimalDigits));\n  const integer = value.div(oneUnit);\n  const decimals = value.mod(oneUnit).div(oneDecimal);\n\n  if (decimals.eqn(0)) {\n    return integer.toString(10);\n  }\n\n  const decimalsString = removeRightZeros(decimals.toString(10).padStart(decimalDigits, \"0\"));\n  return `${integer.toString(10)}.${decimalsString}`;\n}\n\nfunction removeRightZeros(str) {\n  let zeros = 0;\n\n  for (let i = str.length - 1; i >= 0; i--) {\n    if (str.charAt(i) !== \"0\") {\n      break;\n    }\n\n    zeros += 1;\n  }\n\n  return str.substr(0, str.length - zeros);\n}","map":{"version":3,"sources":["../../src/internal/util/wei-values.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAEA;;;;;;;;;AASG;;;AACH,SAAgB,wBAAhB,CAAyC,GAAzC,EAAyD;AACvD,MAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC3B,IAAA,GAAG,GAAG,IAAI,iBAAA,CAAA,EAAJ,CAAO,GAAP,CAAN;AACD;;AAED,MAAI,GAAG,CAAC,GAAJ,CAAQ,CAAR,CAAJ,EAAgB;AACd,WAAO,OAAP;AACD;;AAED,MAAI,GAAG,CAAC,EAAJ,CAAO,IAAI,iBAAA,CAAA,EAAJ,CAAO,EAAP,EAAW,GAAX,CAAe,IAAI,iBAAA,CAAA,EAAJ,CAAO,CAAP,CAAf,CAAP,CAAJ,EAAuC;AACrC,WAAO,GAAG,GAAG,MAAb;AACD;;AAED,MAAI,GAAG,CAAC,EAAJ,CAAO,IAAI,iBAAA,CAAA,EAAJ,CAAO,EAAP,EAAW,GAAX,CAAe,IAAI,iBAAA,CAAA,EAAJ,CAAO,EAAP,CAAf,CAAP,CAAJ,EAAwC;AACtC,WAAO,GAAG,eAAe,CAAC,GAAD,EAAM,CAAN,EAAS,CAAT,CAAW,OAApC;AACD;;AAED,SAAO,GAAG,eAAe,CAAC,GAAD,EAAM,EAAN,EAAU,CAAV,CAAY,MAArC;AACD;;AAlBD,OAAA,CAAA,wBAAA,GAAA,wBAAA;;AAoBA,SAAS,eAAT,CACE,KADF,EAEE,eAFF,EAGE,aAAA,GAAwB,CAH1B,EAG2B;AAEzB,QAAM,OAAO,GAAG,IAAI,iBAAA,CAAA,EAAJ,CAAO,EAAP,EAAW,GAAX,CAAe,IAAI,iBAAA,CAAA,EAAJ,CAAO,eAAP,CAAf,CAAhB;AACA,QAAM,UAAU,GAAG,IAAI,iBAAA,CAAA,EAAJ,CAAO,EAAP,EAAW,GAAX,CAAe,IAAI,iBAAA,CAAA,EAAJ,CAAO,eAAe,GAAG,aAAzB,CAAf,CAAnB;AAEA,QAAM,OAAO,GAAG,KAAK,CAAC,GAAN,CAAU,OAAV,CAAhB;AAEA,QAAM,QAAQ,GAAG,KAAK,CAAC,GAAN,CAAU,OAAV,EAAmB,GAAnB,CAAuB,UAAvB,CAAjB;;AACA,MAAI,QAAQ,CAAC,GAAT,CAAa,CAAb,CAAJ,EAAqB;AACnB,WAAO,OAAO,CAAC,QAAR,CAAiB,EAAjB,CAAP;AACD;;AAED,QAAM,cAAc,GAAG,gBAAgB,CACrC,QAAQ,CAAC,QAAT,CAAkB,EAAlB,EAAsB,QAAtB,CAA+B,aAA/B,EAA8C,GAA9C,CADqC,CAAvC;AAIA,SAAO,GAAG,OAAO,CAAC,QAAR,CAAiB,EAAjB,CAAoB,IAAI,cAAc,EAAhD;AACD;;AAED,SAAS,gBAAT,CAA0B,GAA1B,EAAqC;AACnC,MAAI,KAAK,GAAG,CAAZ;;AAEA,OAAK,IAAI,CAAC,GAAG,GAAG,CAAC,MAAJ,GAAa,CAA1B,EAA6B,CAAC,IAAI,CAAlC,EAAqC,CAAC,EAAtC,EAA0C;AACxC,QAAI,GAAG,CAAC,MAAJ,CAAW,CAAX,MAAkB,GAAtB,EAA2B;AACzB;AACD;;AAED,IAAA,KAAK,IAAI,CAAT;AACD;;AAED,SAAO,GAAG,CAAC,MAAJ,CAAW,CAAX,EAAc,GAAG,CAAC,MAAJ,GAAa,KAA3B,CAAP;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.weiToHumanReadableString = void 0;\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n/**\n * This function turns a wei value in a human readable string. It shows values\n * in ETH, gwei or wei, depending on how large it is.\n *\n * It never show more than 99999 wei or gwei, moving to the larger denominator\n * when necessary.\n *\n * It never shows more than 4 decimal digits. Adapting denominator and\n * truncating as necessary.\n */\nfunction weiToHumanReadableString(wei) {\n    if (typeof wei === \"number\") {\n        wei = new ethereumjs_util_1.BN(wei);\n    }\n    if (wei.eqn(0)) {\n        return \"0 ETH\";\n    }\n    if (wei.lt(new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(5)))) {\n        return `${wei} wei`;\n    }\n    if (wei.lt(new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(14)))) {\n        return `${toDecimalString(wei, 9, 4)} gwei`;\n    }\n    return `${toDecimalString(wei, 18, 4)} ETH`;\n}\nexports.weiToHumanReadableString = weiToHumanReadableString;\nfunction toDecimalString(value, digitsToInteger, decimalDigits = 4) {\n    const oneUnit = new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(digitsToInteger));\n    const oneDecimal = new ethereumjs_util_1.BN(10).pow(new ethereumjs_util_1.BN(digitsToInteger - decimalDigits));\n    const integer = value.div(oneUnit);\n    const decimals = value.mod(oneUnit).div(oneDecimal);\n    if (decimals.eqn(0)) {\n        return integer.toString(10);\n    }\n    const decimalsString = removeRightZeros(decimals.toString(10).padStart(decimalDigits, \"0\"));\n    return `${integer.toString(10)}.${decimalsString}`;\n}\nfunction removeRightZeros(str) {\n    let zeros = 0;\n    for (let i = str.length - 1; i >= 0; i--) {\n        if (str.charAt(i) !== \"0\") {\n            break;\n        }\n        zeros += 1;\n    }\n    return str.substr(0, str.length - zeros);\n}\n//# sourceMappingURL=wei-values.js.map"]},"metadata":{},"sourceType":"script"}