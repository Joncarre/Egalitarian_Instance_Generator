{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyProviderWrappers = exports.createProvider = exports.isHDAccountsConfig = void 0;\n\nconst constants_1 = require(\"../../constants\");\n\nconst logger_1 = require(\"../../hardhat-network/provider/modules/logger\");\n\nconst disk_cache_1 = require(\"../../hardhat-network/provider/utils/disk-cache\");\n\nconst date_1 = require(\"../../util/date\");\n\nconst util_1 = require(\"./util\");\n\nfunction isHDAccountsConfig(accounts) {\n  return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}\n\nexports.isHDAccountsConfig = isHDAccountsConfig;\n\nfunction isResolvedHttpNetworkConfig(netConfig) {\n  return \"url\" in netConfig;\n} // This function is let's you import a provider dynamically in a pretty\n// type-safe way.\n// `ProviderNameT` and `name` must be the same literal string. TS enforces it.\n// `ModuleT` and `filePath` must also be the same, but this is not enforced.\n\n\nfunction importProvider(filePath, name) {\n  const mod = require(filePath);\n\n  return mod[name];\n}\n\nfunction createProvider(networkName, networkConfig, paths, artifacts, experimentalHardhatNetworkMessageTraceHooks = []) {\n  var _a, _b, _c, _d;\n\n  let eip1193Provider;\n\n  if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n    const hardhatNetConfig = networkConfig;\n    const HardhatNetworkProvider = importProvider(\"../../hardhat-network/provider/provider\", \"HardhatNetworkProvider\");\n    let forkConfig;\n\n    if (((_a = hardhatNetConfig.forking) === null || _a === void 0 ? void 0 : _a.enabled) === true && ((_b = hardhatNetConfig.forking) === null || _b === void 0 ? void 0 : _b.url) !== undefined) {\n      forkConfig = {\n        jsonRpcUrl: (_c = hardhatNetConfig.forking) === null || _c === void 0 ? void 0 : _c.url,\n        blockNumber: (_d = hardhatNetConfig.forking) === null || _d === void 0 ? void 0 : _d.blockNumber\n      };\n    }\n\n    const accounts = util_1.normalizeHardhatNetworkAccountsConfig(hardhatNetConfig.accounts);\n    eip1193Provider = new HardhatNetworkProvider(hardhatNetConfig.hardfork, constants_1.HARDHAT_NETWORK_NAME, hardhatNetConfig.chainId, hardhatNetConfig.chainId, hardhatNetConfig.blockGasLimit, hardhatNetConfig.initialBaseFeePerGas, hardhatNetConfig.minGasPrice, hardhatNetConfig.throwOnTransactionFailures, hardhatNetConfig.throwOnCallFailures, hardhatNetConfig.mining.auto, hardhatNetConfig.mining.interval, new logger_1.ModulesLogger(hardhatNetConfig.loggingEnabled), accounts, artifacts, hardhatNetConfig.allowUnlimitedContractSize, hardhatNetConfig.initialDate !== undefined ? date_1.parseDateString(hardhatNetConfig.initialDate) : undefined, experimentalHardhatNetworkMessageTraceHooks, forkConfig, paths !== undefined ? disk_cache_1.getForkCacheDirPath(paths) : undefined);\n  } else {\n    const HttpProvider = importProvider(\"./http\", \"HttpProvider\");\n    const httpNetConfig = networkConfig;\n    eip1193Provider = new HttpProvider(httpNetConfig.url, networkName, httpNetConfig.httpHeaders, httpNetConfig.timeout);\n  }\n\n  const wrappedProvider = applyProviderWrappers(eip1193Provider, networkConfig);\n  const BackwardsCompatibilityProviderAdapter = importProvider(\"./backwards-compatibility\", \"BackwardsCompatibilityProviderAdapter\");\n  return new BackwardsCompatibilityProviderAdapter(wrappedProvider);\n}\n\nexports.createProvider = createProvider;\n\nfunction applyProviderWrappers(provider, netConfig) {\n  // These dependencies are lazy-loaded because they are really big.\n  const LocalAccountsProvider = importProvider(\"./accounts\", \"LocalAccountsProvider\");\n  const HDWalletProvider = importProvider(\"./accounts\", \"HDWalletProvider\");\n  const FixedSenderProvider = importProvider(\"./accounts\", \"FixedSenderProvider\");\n  const AutomaticSenderProvider = importProvider(\"./accounts\", \"AutomaticSenderProvider\");\n  const AutomaticGasProvider = importProvider(\"./gas-providers\", \"AutomaticGasProvider\");\n  const FixedGasProvider = importProvider(\"./gas-providers\", \"FixedGasProvider\");\n  const AutomaticGasPriceProvider = importProvider(\"./gas-providers\", \"AutomaticGasPriceProvider\");\n  const FixedGasPriceProvider = importProvider(\"./gas-providers\", \"FixedGasPriceProvider\");\n  const GanacheGasMultiplierProvider = importProvider(\"./gas-providers\", \"GanacheGasMultiplierProvider\");\n  const ChainIdValidatorProvider = importProvider(\"./chainId\", \"ChainIdValidatorProvider\");\n\n  if (isResolvedHttpNetworkConfig(netConfig)) {\n    const accounts = netConfig.accounts;\n\n    if (Array.isArray(accounts)) {\n      provider = new LocalAccountsProvider(provider, accounts);\n    } else if (isHDAccountsConfig(accounts)) {\n      provider = new HDWalletProvider(provider, accounts.mnemonic, accounts.path, accounts.initialIndex, accounts.count);\n    } // TODO: Add some extension mechanism for account plugins here\n\n\n    if (typeof netConfig.gas !== \"number\") {\n      provider = new GanacheGasMultiplierProvider(provider);\n    }\n  }\n\n  if (netConfig.from !== undefined) {\n    provider = new FixedSenderProvider(provider, netConfig.from);\n  } else {\n    provider = new AutomaticSenderProvider(provider);\n  }\n\n  if (netConfig.gas === undefined || netConfig.gas === \"auto\") {\n    provider = new AutomaticGasProvider(provider, netConfig.gasMultiplier);\n  } else {\n    provider = new FixedGasProvider(provider, netConfig.gas);\n  }\n\n  if (netConfig.gasPrice === undefined || netConfig.gasPrice === \"auto\") {\n    // If you use a LocalAccountsProvider or HDWalletProvider, your transactions\n    // are signed locally. This requires having all of their fields available,\n    // including the gasPrice / maxFeePerGas & maxPriorityFeePerGas.\n    //\n    // We never use those providers when using Hardhat Network, but sign within\n    // Hardhat Network itself. This means that we don't need to provide all the\n    // fields, as the missing ones will be resolved there.\n    //\n    // Hardhat Network handles this in a more performant way, so we don't use\n    // the AutomaticGasPriceProvider for it.\n    if (isResolvedHttpNetworkConfig(netConfig)) {\n      provider = new AutomaticGasPriceProvider(provider);\n    }\n  } else {\n    provider = new FixedGasPriceProvider(provider, netConfig.gasPrice);\n  }\n\n  if (isResolvedHttpNetworkConfig(netConfig) && netConfig.chainId !== undefined) {\n    provider = new ChainIdValidatorProvider(provider, netConfig.chainId);\n  }\n\n  return provider;\n}\n\nexports.applyProviderWrappers = applyProviderWrappers;","map":{"version":3,"sources":["../../../src/internal/core/providers/construction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyProviderWrappers = exports.createProvider = exports.isHDAccountsConfig = void 0;\nconst constants_1 = require(\"../../constants\");\nconst logger_1 = require(\"../../hardhat-network/provider/modules/logger\");\nconst disk_cache_1 = require(\"../../hardhat-network/provider/utils/disk-cache\");\nconst date_1 = require(\"../../util/date\");\nconst util_1 = require(\"./util\");\nfunction isHDAccountsConfig(accounts) {\n    return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}\nexports.isHDAccountsConfig = isHDAccountsConfig;\nfunction isResolvedHttpNetworkConfig(netConfig) {\n    return \"url\" in netConfig;\n}\n// This function is let's you import a provider dynamically in a pretty\n// type-safe way.\n// `ProviderNameT` and `name` must be the same literal string. TS enforces it.\n// `ModuleT` and `filePath` must also be the same, but this is not enforced.\nfunction importProvider(filePath, name) {\n    const mod = require(filePath);\n    return mod[name];\n}\nfunction createProvider(networkName, networkConfig, paths, artifacts, experimentalHardhatNetworkMessageTraceHooks = []) {\n    var _a, _b, _c, _d;\n    let eip1193Provider;\n    if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n        const hardhatNetConfig = networkConfig;\n        const HardhatNetworkProvider = importProvider(\"../../hardhat-network/provider/provider\", \"HardhatNetworkProvider\");\n        let forkConfig;\n        if (((_a = hardhatNetConfig.forking) === null || _a === void 0 ? void 0 : _a.enabled) === true &&\n            ((_b = hardhatNetConfig.forking) === null || _b === void 0 ? void 0 : _b.url) !== undefined) {\n            forkConfig = {\n                jsonRpcUrl: (_c = hardhatNetConfig.forking) === null || _c === void 0 ? void 0 : _c.url,\n                blockNumber: (_d = hardhatNetConfig.forking) === null || _d === void 0 ? void 0 : _d.blockNumber,\n            };\n        }\n        const accounts = util_1.normalizeHardhatNetworkAccountsConfig(hardhatNetConfig.accounts);\n        eip1193Provider = new HardhatNetworkProvider(hardhatNetConfig.hardfork, constants_1.HARDHAT_NETWORK_NAME, hardhatNetConfig.chainId, hardhatNetConfig.chainId, hardhatNetConfig.blockGasLimit, hardhatNetConfig.initialBaseFeePerGas, hardhatNetConfig.minGasPrice, hardhatNetConfig.throwOnTransactionFailures, hardhatNetConfig.throwOnCallFailures, hardhatNetConfig.mining.auto, hardhatNetConfig.mining.interval, new logger_1.ModulesLogger(hardhatNetConfig.loggingEnabled), accounts, artifacts, hardhatNetConfig.allowUnlimitedContractSize, hardhatNetConfig.initialDate !== undefined\n            ? date_1.parseDateString(hardhatNetConfig.initialDate)\n            : undefined, experimentalHardhatNetworkMessageTraceHooks, forkConfig, paths !== undefined ? disk_cache_1.getForkCacheDirPath(paths) : undefined);\n    }\n    else {\n        const HttpProvider = importProvider(\"./http\", \"HttpProvider\");\n        const httpNetConfig = networkConfig;\n        eip1193Provider = new HttpProvider(httpNetConfig.url, networkName, httpNetConfig.httpHeaders, httpNetConfig.timeout);\n    }\n    const wrappedProvider = applyProviderWrappers(eip1193Provider, networkConfig);\n    const BackwardsCompatibilityProviderAdapter = importProvider(\"./backwards-compatibility\", \"BackwardsCompatibilityProviderAdapter\");\n    return new BackwardsCompatibilityProviderAdapter(wrappedProvider);\n}\nexports.createProvider = createProvider;\nfunction applyProviderWrappers(provider, netConfig) {\n    // These dependencies are lazy-loaded because they are really big.\n    const LocalAccountsProvider = importProvider(\"./accounts\", \"LocalAccountsProvider\");\n    const HDWalletProvider = importProvider(\"./accounts\", \"HDWalletProvider\");\n    const FixedSenderProvider = importProvider(\"./accounts\", \"FixedSenderProvider\");\n    const AutomaticSenderProvider = importProvider(\"./accounts\", \"AutomaticSenderProvider\");\n    const AutomaticGasProvider = importProvider(\"./gas-providers\", \"AutomaticGasProvider\");\n    const FixedGasProvider = importProvider(\"./gas-providers\", \"FixedGasProvider\");\n    const AutomaticGasPriceProvider = importProvider(\"./gas-providers\", \"AutomaticGasPriceProvider\");\n    const FixedGasPriceProvider = importProvider(\"./gas-providers\", \"FixedGasPriceProvider\");\n    const GanacheGasMultiplierProvider = importProvider(\"./gas-providers\", \"GanacheGasMultiplierProvider\");\n    const ChainIdValidatorProvider = importProvider(\"./chainId\", \"ChainIdValidatorProvider\");\n    if (isResolvedHttpNetworkConfig(netConfig)) {\n        const accounts = netConfig.accounts;\n        if (Array.isArray(accounts)) {\n            provider = new LocalAccountsProvider(provider, accounts);\n        }\n        else if (isHDAccountsConfig(accounts)) {\n            provider = new HDWalletProvider(provider, accounts.mnemonic, accounts.path, accounts.initialIndex, accounts.count);\n        }\n        // TODO: Add some extension mechanism for account plugins here\n        if (typeof netConfig.gas !== \"number\") {\n            provider = new GanacheGasMultiplierProvider(provider);\n        }\n    }\n    if (netConfig.from !== undefined) {\n        provider = new FixedSenderProvider(provider, netConfig.from);\n    }\n    else {\n        provider = new AutomaticSenderProvider(provider);\n    }\n    if (netConfig.gas === undefined || netConfig.gas === \"auto\") {\n        provider = new AutomaticGasProvider(provider, netConfig.gasMultiplier);\n    }\n    else {\n        provider = new FixedGasProvider(provider, netConfig.gas);\n    }\n    if (netConfig.gasPrice === undefined || netConfig.gasPrice === \"auto\") {\n        // If you use a LocalAccountsProvider or HDWalletProvider, your transactions\n        // are signed locally. This requires having all of their fields available,\n        // including the gasPrice / maxFeePerGas & maxPriorityFeePerGas.\n        //\n        // We never use those providers when using Hardhat Network, but sign within\n        // Hardhat Network itself. This means that we don't need to provide all the\n        // fields, as the missing ones will be resolved there.\n        //\n        // Hardhat Network handles this in a more performant way, so we don't use\n        // the AutomaticGasPriceProvider for it.\n        if (isResolvedHttpNetworkConfig(netConfig)) {\n            provider = new AutomaticGasPriceProvider(provider);\n        }\n    }\n    else {\n        provider = new FixedGasPriceProvider(provider, netConfig.gasPrice);\n    }\n    if (isResolvedHttpNetworkConfig(netConfig) &&\n        netConfig.chainId !== undefined) {\n        provider = new ChainIdValidatorProvider(provider, netConfig.chainId);\n    }\n    return provider;\n}\nexports.applyProviderWrappers = applyProviderWrappers;\n//# sourceMappingURL=construction.js.map"]},"metadata":{},"sourceType":"script"}