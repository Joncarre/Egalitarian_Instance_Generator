{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeHardhatNetworkAccountsConfig = exports.derivePrivateKeys = void 0;\n\nconst keys_derivation_1 = require(\"../../util/keys-derivation\");\n\nconst default_config_1 = require(\"../config/default-config\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\n\nfunction derivePrivateKeys(mnemonic, hdpath, initialIndex, count) {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.INVALID_HD_PATH, {\n      path: hdpath\n    });\n  }\n\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n\n  const privateKeys = [];\n\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = keys_derivation_1.deriveKeyFromMnemonicAndPath(mnemonic, hdpath + i.toString());\n\n    if (privateKey === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath\n      });\n    }\n\n    privateKeys.push(privateKey);\n  }\n\n  return privateKeys;\n}\n\nexports.derivePrivateKeys = derivePrivateKeys;\n\nfunction normalizeHardhatNetworkAccountsConfig(accountsConfig) {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n\n  const {\n    bufferToHex\n  } = require(\"ethereumjs-util\");\n\n  return derivePrivateKeys(accountsConfig.mnemonic, accountsConfig.path, accountsConfig.initialIndex, accountsConfig.count).map(pk => {\n    var _a;\n\n    return {\n      privateKey: bufferToHex(pk),\n      balance: (_a = accountsConfig.accountsBalance) !== null && _a !== void 0 ? _a : default_config_1.DEFAULT_HARDHAT_NETWORK_BALANCE\n    };\n  });\n}\n\nexports.normalizeHardhatNetworkAccountsConfig = normalizeHardhatNetworkAccountsConfig;","map":{"version":3,"sources":["../../../src/internal/core/providers/util.ts"],"names":[],"mappings":";;;;;;;AAIA,MAAA,iBAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AACA,MAAA,gBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAM,aAAa,GAAG,oBAAtB;;AAEA,SAAgB,iBAAhB,CACE,QADF,EAEE,MAFF,EAGE,YAHF,EAIE,KAJF,EAIe;AAEb,MAAI,MAAM,CAAC,KAAP,CAAa,aAAb,MAAgC,IAApC,EAA0C;AACxC,UAAM,IAAI,QAAA,CAAA,YAAJ,CAAiB,aAAA,CAAA,MAAA,CAAO,OAAP,CAAe,eAAhC,EAAiD;AAAE,MAAA,IAAI,EAAE;AAAR,KAAjD,CAAN;AACD;;AAED,MAAI,CAAC,MAAM,CAAC,QAAP,CAAgB,GAAhB,CAAL,EAA2B;AACzB,IAAA,MAAM,IAAI,GAAV;AACD;;AAED,QAAM,WAAW,GAAa,EAA9B;;AAEA,OAAK,IAAI,CAAC,GAAG,YAAb,EAA2B,CAAC,GAAG,YAAY,GAAG,KAA9C,EAAqD,CAAC,EAAtD,EAA0D;AACxD,UAAM,UAAU,GAAG,iBAAA,CAAA,4BAAA,CACjB,QADiB,EAEjB,MAAM,GAAG,CAAC,CAAC,QAAF,EAFQ,CAAnB;;AAKA,QAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B,YAAM,IAAI,QAAA,CAAA,YAAJ,CAAiB,aAAA,CAAA,MAAA,CAAO,OAAP,CAAe,eAAhC,EAAiD;AACrD,QAAA,QADqD;AAErD,QAAA,IAAI,EAAE;AAF+C,OAAjD,CAAN;AAID;;AAED,IAAA,WAAW,CAAC,IAAZ,CAAiB,UAAjB;AACD;;AAED,SAAO,WAAP;AACD;;AAjCD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAmCA,SAAgB,qCAAhB,CACE,cADF,EAC8C;AAE5C,MAAI,KAAK,CAAC,OAAN,CAAc,cAAd,CAAJ,EAAmC;AACjC,WAAO,cAAP;AACD;;AAED,QAAM;AAAE,IAAA;AAAF,MAAkB,OAAO,CAAC,iBAAD,CAA/B;;AAEA,SAAO,iBAAiB,CACtB,cAAc,CAAC,QADO,EAEtB,cAAc,CAAC,IAFO,EAGtB,cAAc,CAAC,YAHO,EAItB,cAAc,CAAC,KAJO,CAAjB,CAKL,GALK,CAKA,EAAD,IAAO;;;AAAC,WAAC;AACb,MAAA,UAAU,EAAE,WAAW,CAAC,EAAD,CADV;AAEb,MAAA,OAAO,EAAA,CAAA,EAAA,GAAE,cAAc,CAAC,eAAjB,MAAgC,IAAhC,IAAgC,EAAA,KAAA,KAAA,CAAhC,GAAgC,EAAhC,GAAoC,gBAAA,CAAA;AAF9B,KAAD;AAGZ,GARK,CAAP;AASD;;AAlBD,OAAA,CAAA,qCAAA,GAAA,qCAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeHardhatNetworkAccountsConfig = exports.derivePrivateKeys = void 0;\nconst keys_derivation_1 = require(\"../../util/keys-derivation\");\nconst default_config_1 = require(\"../config/default-config\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\nfunction derivePrivateKeys(mnemonic, hdpath, initialIndex, count) {\n    if (hdpath.match(HD_PATH_REGEX) === null) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.INVALID_HD_PATH, { path: hdpath });\n    }\n    if (!hdpath.endsWith(\"/\")) {\n        hdpath += \"/\";\n    }\n    const privateKeys = [];\n    for (let i = initialIndex; i < initialIndex + count; i++) {\n        const privateKey = keys_derivation_1.deriveKeyFromMnemonicAndPath(mnemonic, hdpath + i.toString());\n        if (privateKey === undefined) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CANT_DERIVE_KEY, {\n                mnemonic,\n                path: hdpath,\n            });\n        }\n        privateKeys.push(privateKey);\n    }\n    return privateKeys;\n}\nexports.derivePrivateKeys = derivePrivateKeys;\nfunction normalizeHardhatNetworkAccountsConfig(accountsConfig) {\n    if (Array.isArray(accountsConfig)) {\n        return accountsConfig;\n    }\n    const { bufferToHex } = require(\"ethereumjs-util\");\n    return derivePrivateKeys(accountsConfig.mnemonic, accountsConfig.path, accountsConfig.initialIndex, accountsConfig.count).map((pk) => {\n        var _a;\n        return ({\n            privateKey: bufferToHex(pk),\n            balance: (_a = accountsConfig.accountsBalance) !== null && _a !== void 0 ? _a : default_config_1.DEFAULT_HARDHAT_NETWORK_BALANCE,\n        });\n    });\n}\nexports.normalizeHardhatNetworkAccountsConfig = normalizeHardhatNetworkAccountsConfig;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}