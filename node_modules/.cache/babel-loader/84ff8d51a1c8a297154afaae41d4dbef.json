{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceBackslashes = exports.isAbsolutePathSourceName = exports.normalizeSourceName = exports.localSourceNameToPath = exports.localPathToSourceName = exports.validateSourceNameExistenceAndCasing = exports.isLocalSourceName = exports.validateSourceNameFormat = void 0;\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst NODE_MODULES = \"node_modules\";\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\n\nfunction validateSourceNameFormat(sourceName) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH, {\n      name: sourceName\n    });\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH, {\n      name: sourceName\n    });\n  } // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n\n\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES, {\n      name: sourceName\n    });\n  }\n\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName\n    });\n  }\n}\n\nexports.validateSourceNameFormat = validateSourceNameFormat;\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\n\nasync function isLocalSourceName(projectRoot, sourceName) {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (sourceName.includes(NODE_MODULES) || sourceName === \"hardhat/console.sol\") {\n    return false;\n  }\n\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName = slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n\n  try {\n    await getPathTrueCase(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n      return false;\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n\n  return true;\n}\n\nexports.isLocalSourceName = isLocalSourceName;\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\n\nasync function validateSourceNameExistenceAndCasing(fromDir, sourceName) {\n  const trueCaseSourceName = await getPathTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName\n    });\n  }\n}\n\nexports.validateSourceNameExistenceAndCasing = validateSourceNameExistenceAndCasing;\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\n\nasync function localPathToSourceName(projectRoot, localFileAbsolutePath) {\n  const relativePath = path_1.default.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n\n  if (normalized.includes(NODE_MODULES)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n\n  return getPathTrueCase(projectRoot, relativePath);\n}\n\nexports.localPathToSourceName = localPathToSourceName;\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\n\nfunction localSourceNameToPath(projectRoot, sourceName) {\n  return path_1.default.join(projectRoot, sourceName);\n}\n\nexports.localSourceNameToPath = localSourceNameToPath;\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\n\nfunction normalizeSourceName(sourceName) {\n  return replaceBackslashes(path_1.default.normalize(sourceName));\n}\n\nexports.normalizeSourceName = normalizeSourceName;\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\n\nfunction isAbsolutePathSourceName(sourceName) {\n  return path_1.default.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\n\nexports.isAbsolutePathSourceName = isAbsolutePathSourceName;\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\n\nfunction isExplicitRelativePath(sourceName) {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n/**\n * This function replaces backslashes (\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\n\n\nfunction replaceBackslashes(str) {\n  const slash = require(\"slash\");\n\n  return slash(str);\n}\n\nexports.replaceBackslashes = replaceBackslashes;\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\n\nasync function getPathTrueCase(fromDir, p) {\n  const {\n    trueCasePath\n  } = await Promise.resolve().then(() => __importStar(require(\"true-case-path\")));\n\n  try {\n    const tcp = await trueCasePath(p, fromDir);\n    return normalizeSourceName(path_1.default.relative(fromDir, tcp));\n  } catch (error) {\n    if (typeof error.message === \"string\" && error.message.includes(\"no matching file exists\")) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND, {\n        name: p\n      }, error);\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n}","map":{"version":3,"sources":["../src/utils/source-names.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.replaceBackslashes = exports.isAbsolutePathSourceName = exports.normalizeSourceName = exports.localSourceNameToPath = exports.localPathToSourceName = exports.validateSourceNameExistenceAndCasing = exports.isLocalSourceName = exports.validateSourceNameFormat = void 0;\nconst path_1 = __importDefault(require(\"path\"));\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\nconst NODE_MODULES = \"node_modules\";\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\nfunction validateSourceNameFormat(sourceName) {\n    if (isAbsolutePathSourceName(sourceName)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH, {\n            name: sourceName,\n        });\n    }\n    if (isExplicitRelativePath(sourceName)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH, {\n            name: sourceName,\n        });\n    }\n    // We check this before normalizing so we are sure that the difference\n    // comes from slash vs backslash\n    if (replaceBackslashes(sourceName) !== sourceName) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES, {\n            name: sourceName,\n        });\n    }\n    if (normalizeSourceName(sourceName) !== sourceName) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n            name: sourceName,\n        });\n    }\n}\nexports.validateSourceNameFormat = validateSourceNameFormat;\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\nasync function isLocalSourceName(projectRoot, sourceName) {\n    // Note that we consider \"hardhat/console.sol\" as a special case here.\n    // This lets someone have a \"hardhat\" directory within their project without\n    // it impacting their use of `console.log`.\n    // See issue https://github.com/nomiclabs/hardhat/issues/998\n    if (sourceName.includes(NODE_MODULES) ||\n        sourceName === \"hardhat/console.sol\") {\n        return false;\n    }\n    const slashIndex = sourceName.indexOf(\"/\");\n    const firstDirOrFileName = slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n    try {\n        await getPathTrueCase(projectRoot, firstDirOrFileName);\n    }\n    catch (error) {\n        if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n            return false;\n        }\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n    }\n    return true;\n}\nexports.isLocalSourceName = isLocalSourceName;\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\nasync function validateSourceNameExistenceAndCasing(fromDir, sourceName) {\n    const trueCaseSourceName = await getPathTrueCase(fromDir, sourceName);\n    if (trueCaseSourceName !== sourceName) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING, {\n            incorrect: sourceName,\n            correct: trueCaseSourceName,\n        });\n    }\n}\nexports.validateSourceNameExistenceAndCasing = validateSourceNameExistenceAndCasing;\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\nasync function localPathToSourceName(projectRoot, localFileAbsolutePath) {\n    const relativePath = path_1.default.relative(projectRoot, localFileAbsolutePath);\n    const normalized = normalizeSourceName(relativePath);\n    if (normalized.startsWith(\"..\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n            path: localFileAbsolutePath,\n        });\n    }\n    if (normalized.includes(NODE_MODULES)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n            path: localFileAbsolutePath,\n        });\n    }\n    return getPathTrueCase(projectRoot, relativePath);\n}\nexports.localPathToSourceName = localPathToSourceName;\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\nfunction localSourceNameToPath(projectRoot, sourceName) {\n    return path_1.default.join(projectRoot, sourceName);\n}\nexports.localSourceNameToPath = localSourceNameToPath;\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\nfunction normalizeSourceName(sourceName) {\n    return replaceBackslashes(path_1.default.normalize(sourceName));\n}\nexports.normalizeSourceName = normalizeSourceName;\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\nfunction isAbsolutePathSourceName(sourceName) {\n    return path_1.default.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\nexports.isAbsolutePathSourceName = isAbsolutePathSourceName;\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\nfunction isExplicitRelativePath(sourceName) {\n    const [base] = sourceName.split(\"/\", 1);\n    return base === \".\" || base === \"..\";\n}\n/**\n * This function replaces backslashes (\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\nfunction replaceBackslashes(str) {\n    const slash = require(\"slash\");\n    return slash(str);\n}\nexports.replaceBackslashes = replaceBackslashes;\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\nasync function getPathTrueCase(fromDir, p) {\n    const { trueCasePath } = await Promise.resolve().then(() => __importStar(require(\"true-case-path\")));\n    try {\n        const tcp = await trueCasePath(p, fromDir);\n        return normalizeSourceName(path_1.default.relative(fromDir, tcp));\n    }\n    catch (error) {\n        if (typeof error.message === \"string\" &&\n            error.message.includes(\"no matching file exists\")) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND, {\n                name: p,\n            }, error);\n        }\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n    }\n}\n//# sourceMappingURL=source-names.js.map"]},"metadata":{},"sourceType":"script"}