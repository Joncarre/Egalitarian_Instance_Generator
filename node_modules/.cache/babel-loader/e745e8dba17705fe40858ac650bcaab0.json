{"ast":null,"code":"import { getCurrentHub } from '@sentry/core';\nimport { Severity } from '@sentry/types';\nimport { logger } from '@sentry/utils';\nimport { logAndExitProcess } from '../handlers';\n/** Global Promise Rejection handler */\n\nvar OnUncaughtException =\n/** @class */\nfunction () {\n  /**\n   * @inheritDoc\n   */\n  function OnUncaughtException(_options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    this._options = _options;\n    /**\n     * @inheritDoc\n     */\n\n    this.name = OnUncaughtException.id;\n    /**\n     * @inheritDoc\n     */\n\n    this.handler = this._makeErrorHandler();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  OnUncaughtException.prototype.setupOnce = function () {\n    global.process.on('uncaughtException', this.handler.bind(this));\n  };\n  /**\n   * @hidden\n   */\n\n\n  OnUncaughtException.prototype._makeErrorHandler = function () {\n    var _this = this;\n\n    var timeout = 2000;\n    var caughtFirstError = false;\n    var caughtSecondError = false;\n    var calledFatalError = false;\n    var firstError;\n    return function (error) {\n      var onFatalError = logAndExitProcess;\n      var client = getCurrentHub().getClient();\n\n      if (_this._options.onFatalError) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onFatalError = _this._options.onFatalError;\n      } else if (client && client.getOptions().onFatalError) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onFatalError = client.getOptions().onFatalError;\n      }\n\n      if (!caughtFirstError) {\n        var hub_1 = getCurrentHub(); // this is the first uncaught error and the ultimate reason for shutting down\n        // we want to do absolutely everything possible to ensure it gets captured\n        // also we want to make sure we don't go recursion crazy if more errors happen after this one\n\n        firstError = error;\n        caughtFirstError = true;\n\n        if (hub_1.getIntegration(OnUncaughtException)) {\n          hub_1.withScope(function (scope) {\n            scope.setLevel(Severity.Fatal);\n            hub_1.captureException(error, {\n              originalException: error\n            });\n\n            if (!calledFatalError) {\n              calledFatalError = true;\n              onFatalError(error);\n            }\n          });\n        } else {\n          if (!calledFatalError) {\n            calledFatalError = true;\n            onFatalError(error);\n          }\n        }\n      } else if (calledFatalError) {\n        // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n        logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');\n        logAndExitProcess(error);\n      } else if (!caughtSecondError) {\n        // two cases for how we can hit this branch:\n        //   - capturing of first error blew up and we just caught the exception from that\n        //     - quit trying to capture, proceed with shutdown\n        //   - a second independent error happened while waiting for first error to capture\n        //     - want to avoid causing premature shutdown before first error capture finishes\n        // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n        // so let's instead just delay a bit before we proceed with our action here\n        // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n        // in case 2, the delay hopefully made us wait long enough for the capture to finish\n        // two potential nonideal outcomes:\n        //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n        //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n        // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n        //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n        caughtSecondError = true;\n        setTimeout(function () {\n          if (!calledFatalError) {\n            // it was probably case 1, let's treat err as the sendErr and call onFatalError\n            calledFatalError = true;\n            onFatalError(firstError, error);\n          } else {// it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n          }\n        }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n      }\n    };\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  OnUncaughtException.id = 'OnUncaughtException';\n  return OnUncaughtException;\n}();\n\nexport { OnUncaughtException };","map":{"version":3,"sources":["../../src/integrations/onuncaughtexception.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub, Scope } from '@sentry/core';\nimport { Integration, Severity } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { NodeClient } from '../client';\nimport { logAndExitProcess } from '../handlers';\n\n/** Global Promise Rejection handler */\nexport class OnUncaughtException implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'OnUncaughtException';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = OnUncaughtException.id;\n\n  /**\n   * @inheritDoc\n   */\n  public readonly handler: (error: Error) => void = this._makeErrorHandler();\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(\n    private readonly _options: {\n      /**\n       * Default onFatalError handler\n       * @param firstError Error that has been thrown\n       * @param secondError If this was called multiple times this will be set\n       */\n      onFatalError?(firstError: Error, secondError?: Error): void;\n    } = {},\n  ) {}\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    global.process.on('uncaughtException', this.handler.bind(this));\n  }\n\n  /**\n   * @hidden\n   */\n  private _makeErrorHandler(): (error: Error) => void {\n    const timeout = 2000;\n    let caughtFirstError: boolean = false;\n    let caughtSecondError: boolean = false;\n    let calledFatalError: boolean = false;\n    let firstError: Error;\n\n    return (error: Error): void => {\n      type onFatalErrorHandlerType = (firstError: Error, secondError?: Error) => void;\n\n      let onFatalError: onFatalErrorHandlerType = logAndExitProcess;\n      const client = getCurrentHub().getClient<NodeClient>();\n\n      if (this._options.onFatalError) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onFatalError = this._options.onFatalError;\n      } else if (client && client.getOptions().onFatalError) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onFatalError = client.getOptions().onFatalError as onFatalErrorHandlerType;\n      }\n\n      if (!caughtFirstError) {\n        const hub = getCurrentHub();\n\n        // this is the first uncaught error and the ultimate reason for shutting down\n        // we want to do absolutely everything possible to ensure it gets captured\n        // also we want to make sure we don't go recursion crazy if more errors happen after this one\n        firstError = error;\n        caughtFirstError = true;\n\n        if (hub.getIntegration(OnUncaughtException)) {\n          hub.withScope((scope: Scope) => {\n            scope.setLevel(Severity.Fatal);\n            hub.captureException(error, { originalException: error });\n            if (!calledFatalError) {\n              calledFatalError = true;\n              onFatalError(error);\n            }\n          });\n        } else {\n          if (!calledFatalError) {\n            calledFatalError = true;\n            onFatalError(error);\n          }\n        }\n      } else if (calledFatalError) {\n        // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n        logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');\n        logAndExitProcess(error);\n      } else if (!caughtSecondError) {\n        // two cases for how we can hit this branch:\n        //   - capturing of first error blew up and we just caught the exception from that\n        //     - quit trying to capture, proceed with shutdown\n        //   - a second independent error happened while waiting for first error to capture\n        //     - want to avoid causing premature shutdown before first error capture finishes\n        // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n        // so let's instead just delay a bit before we proceed with our action here\n        // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n        // in case 2, the delay hopefully made us wait long enough for the capture to finish\n        // two potential nonideal outcomes:\n        //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n        //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n        // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n        //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n        caughtSecondError = true;\n        setTimeout(() => {\n          if (!calledFatalError) {\n            // it was probably case 1, let's treat err as the sendErr and call onFatalError\n            calledFatalError = true;\n            onFatalError(firstError, error);\n          } else {\n            // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n          }\n        }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n      }\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}