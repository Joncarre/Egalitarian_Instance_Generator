{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SolidityTracer = exports.FIRST_SOLC_VERSION_SUPPORTED = exports.SUPPORTED_SOLIDITY_VERSION_RANGE = void 0;\n\nconst return_data_1 = require(\"../provider/return-data\");\n\nconst error_inferrer_1 = require(\"./error-inferrer\");\n\nconst mapped_inlined_internal_functions_heuristics_1 = require(\"./mapped-inlined-internal-functions-heuristics\");\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst model_1 = require(\"./model\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nexports.SUPPORTED_SOLIDITY_VERSION_RANGE = \"<=0.8.4\";\nexports.FIRST_SOLC_VERSION_SUPPORTED = \"0.5.1\";\n\nclass SolidityTracer {\n  constructor() {\n    this._errorInferrer = new error_inferrer_1.ErrorInferrer();\n  }\n\n  getStackTrace(maybeDecodedMessageTrace) {\n    if (maybeDecodedMessageTrace.error === undefined) {\n      return [];\n    }\n\n    if (message_trace_1.isPrecompileTrace(maybeDecodedMessageTrace)) {\n      return this._getPrecompileMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if (message_trace_1.isDecodedCreateTrace(maybeDecodedMessageTrace)) {\n      return this._getCreateMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if (message_trace_1.isDecodedCallTrace(maybeDecodedMessageTrace)) {\n      return this._getCallMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    return this._getUnrecognizedMessageStackTrace(maybeDecodedMessageTrace);\n  }\n\n  _getCallMessageStackTrace(trace) {\n    const inferredError = this._errorInferrer.inferBeforeTracingCallMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  _getUnrecognizedMessageStackTrace(trace) {\n    const subtrace = this._getLastSubtrace(trace);\n\n    if (subtrace !== undefined) {\n      // This is not a very exact heuristic, but most of the time it will be right, as solidity\n      // reverts if a call fails, and most contracts are in solidity\n      if (subtrace.error !== undefined && trace.returnData.equals(subtrace.returnData)) {\n        let unrecognizedEntry;\n\n        if (message_trace_1.isCreateTrace(trace)) {\n          unrecognizedEntry = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY\n          };\n        } else {\n          unrecognizedEntry = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY,\n            address: trace.address\n          };\n        }\n\n        return [unrecognizedEntry, ...this.getStackTrace(subtrace)];\n      }\n    }\n\n    if (message_trace_1.isCreateTrace(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR,\n        message: new return_data_1.ReturnData(trace.returnData)\n      }];\n    }\n\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR,\n      address: trace.address,\n      message: new return_data_1.ReturnData(trace.returnData)\n    }];\n  }\n\n  _getCreateMessageStackTrace(trace) {\n    const inferredError = this._errorInferrer.inferBeforeTracingCreateMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  _getPrecompileMessageStackTrace(trace) {\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.PRECOMPILE_ERROR,\n      precompile: trace.precompile\n    }];\n  }\n\n  _traceEvmExecution(trace) {\n    const stackTrace = this._rawTraceEvmExecution(trace);\n\n    if (mapped_inlined_internal_functions_heuristics_1.stackTraceMayRequireAdjustments(stackTrace, trace)) {\n      return mapped_inlined_internal_functions_heuristics_1.adjustStackTrace(stackTrace, trace);\n    }\n\n    return stackTrace;\n  }\n\n  _rawTraceEvmExecution(trace) {\n    const stacktrace = [];\n    let subtracesSeen = 0;\n    let jumpedIntoFunction = false;\n    const functionJumpdests = [];\n    let lastSubmessageData;\n\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if (message_trace_1.isEvmStep(step)) {\n        const inst = trace.bytecode.getInstruction(step.pc);\n\n        if (inst.jumpType === model_1.JumpType.INTO_FUNCTION) {\n          const nextEvmStep = nextStep; // A jump can't be followed by a subtrace\n\n          const nextInst = trace.bytecode.getInstruction(nextEvmStep.pc);\n\n          if (nextInst !== undefined && nextInst.opcode === opcodes_1.Opcode.JUMPDEST) {\n            stacktrace.push(error_inferrer_1.instructionToCallstackStackTraceEntry(trace.bytecode, inst));\n\n            if (nextInst.location !== undefined) {\n              jumpedIntoFunction = true;\n            }\n\n            functionJumpdests.push(nextInst);\n          }\n        } else if (inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n          stacktrace.pop();\n          functionJumpdests.pop();\n        }\n      } else {\n        subtracesSeen += 1; // If there are more subtraces, this one didn't terminate the execution\n\n        if (subtracesSeen < trace.numberOfSubtraces) {\n          continue;\n        }\n\n        const submessageTrace = this.getStackTrace(step);\n        lastSubmessageData = {\n          messageTrace: step,\n          stepIndex,\n          stacktrace: submessageTrace\n        };\n      }\n    }\n\n    const stacktraceWithInferredError = this._errorInferrer.inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData);\n\n    return this._errorInferrer.filterRedundantFrames(stacktraceWithInferredError);\n  }\n\n  _getLastSubtrace(trace) {\n    if (trace.numberOfSubtraces < 1) {\n      return undefined;\n    }\n\n    let i = trace.steps.length - 1;\n\n    while (message_trace_1.isEvmStep(trace.steps[i])) {\n      i -= 1;\n    }\n\n    return trace.steps[i];\n  }\n\n}\n\nexports.SolidityTracer = SolidityTracer;","map":{"version":3,"sources":["../../../src/internal/hardhat-network/stack-traces/solidityTracer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SolidityTracer = exports.FIRST_SOLC_VERSION_SUPPORTED = exports.SUPPORTED_SOLIDITY_VERSION_RANGE = void 0;\nconst return_data_1 = require(\"../provider/return-data\");\nconst error_inferrer_1 = require(\"./error-inferrer\");\nconst mapped_inlined_internal_functions_heuristics_1 = require(\"./mapped-inlined-internal-functions-heuristics\");\nconst message_trace_1 = require(\"./message-trace\");\nconst model_1 = require(\"./model\");\nconst opcodes_1 = require(\"./opcodes\");\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\nexports.SUPPORTED_SOLIDITY_VERSION_RANGE = \"<=0.8.4\";\nexports.FIRST_SOLC_VERSION_SUPPORTED = \"0.5.1\";\nclass SolidityTracer {\n    constructor() {\n        this._errorInferrer = new error_inferrer_1.ErrorInferrer();\n    }\n    getStackTrace(maybeDecodedMessageTrace) {\n        if (maybeDecodedMessageTrace.error === undefined) {\n            return [];\n        }\n        if (message_trace_1.isPrecompileTrace(maybeDecodedMessageTrace)) {\n            return this._getPrecompileMessageStackTrace(maybeDecodedMessageTrace);\n        }\n        if (message_trace_1.isDecodedCreateTrace(maybeDecodedMessageTrace)) {\n            return this._getCreateMessageStackTrace(maybeDecodedMessageTrace);\n        }\n        if (message_trace_1.isDecodedCallTrace(maybeDecodedMessageTrace)) {\n            return this._getCallMessageStackTrace(maybeDecodedMessageTrace);\n        }\n        return this._getUnrecognizedMessageStackTrace(maybeDecodedMessageTrace);\n    }\n    _getCallMessageStackTrace(trace) {\n        const inferredError = this._errorInferrer.inferBeforeTracingCallMessage(trace);\n        if (inferredError !== undefined) {\n            return inferredError;\n        }\n        return this._traceEvmExecution(trace);\n    }\n    _getUnrecognizedMessageStackTrace(trace) {\n        const subtrace = this._getLastSubtrace(trace);\n        if (subtrace !== undefined) {\n            // This is not a very exact heuristic, but most of the time it will be right, as solidity\n            // reverts if a call fails, and most contracts are in solidity\n            if (subtrace.error !== undefined &&\n                trace.returnData.equals(subtrace.returnData)) {\n                let unrecognizedEntry;\n                if (message_trace_1.isCreateTrace(trace)) {\n                    unrecognizedEntry = {\n                        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY,\n                    };\n                }\n                else {\n                    unrecognizedEntry = {\n                        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY,\n                        address: trace.address,\n                    };\n                }\n                return [unrecognizedEntry, ...this.getStackTrace(subtrace)];\n            }\n        }\n        if (message_trace_1.isCreateTrace(trace)) {\n            return [\n                {\n                    type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR,\n                    message: new return_data_1.ReturnData(trace.returnData),\n                },\n            ];\n        }\n        return [\n            {\n                type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR,\n                address: trace.address,\n                message: new return_data_1.ReturnData(trace.returnData),\n            },\n        ];\n    }\n    _getCreateMessageStackTrace(trace) {\n        const inferredError = this._errorInferrer.inferBeforeTracingCreateMessage(trace);\n        if (inferredError !== undefined) {\n            return inferredError;\n        }\n        return this._traceEvmExecution(trace);\n    }\n    _getPrecompileMessageStackTrace(trace) {\n        return [\n            {\n                type: solidity_stack_trace_1.StackTraceEntryType.PRECOMPILE_ERROR,\n                precompile: trace.precompile,\n            },\n        ];\n    }\n    _traceEvmExecution(trace) {\n        const stackTrace = this._rawTraceEvmExecution(trace);\n        if (mapped_inlined_internal_functions_heuristics_1.stackTraceMayRequireAdjustments(stackTrace, trace)) {\n            return mapped_inlined_internal_functions_heuristics_1.adjustStackTrace(stackTrace, trace);\n        }\n        return stackTrace;\n    }\n    _rawTraceEvmExecution(trace) {\n        const stacktrace = [];\n        let subtracesSeen = 0;\n        let jumpedIntoFunction = false;\n        const functionJumpdests = [];\n        let lastSubmessageData;\n        for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n            const step = trace.steps[stepIndex];\n            const nextStep = trace.steps[stepIndex + 1];\n            if (message_trace_1.isEvmStep(step)) {\n                const inst = trace.bytecode.getInstruction(step.pc);\n                if (inst.jumpType === model_1.JumpType.INTO_FUNCTION) {\n                    const nextEvmStep = nextStep; // A jump can't be followed by a subtrace\n                    const nextInst = trace.bytecode.getInstruction(nextEvmStep.pc);\n                    if (nextInst !== undefined && nextInst.opcode === opcodes_1.Opcode.JUMPDEST) {\n                        stacktrace.push(error_inferrer_1.instructionToCallstackStackTraceEntry(trace.bytecode, inst));\n                        if (nextInst.location !== undefined) {\n                            jumpedIntoFunction = true;\n                        }\n                        functionJumpdests.push(nextInst);\n                    }\n                }\n                else if (inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n                    stacktrace.pop();\n                    functionJumpdests.pop();\n                }\n            }\n            else {\n                subtracesSeen += 1;\n                // If there are more subtraces, this one didn't terminate the execution\n                if (subtracesSeen < trace.numberOfSubtraces) {\n                    continue;\n                }\n                const submessageTrace = this.getStackTrace(step);\n                lastSubmessageData = {\n                    messageTrace: step,\n                    stepIndex,\n                    stacktrace: submessageTrace,\n                };\n            }\n        }\n        const stacktraceWithInferredError = this._errorInferrer.inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData);\n        return this._errorInferrer.filterRedundantFrames(stacktraceWithInferredError);\n    }\n    _getLastSubtrace(trace) {\n        if (trace.numberOfSubtraces < 1) {\n            return undefined;\n        }\n        let i = trace.steps.length - 1;\n        while (message_trace_1.isEvmStep(trace.steps[i])) {\n            i -= 1;\n        }\n        return trace.steps[i];\n    }\n}\nexports.SolidityTracer = SolidityTracer;\n//# sourceMappingURL=solidityTracer.js.map"]},"metadata":{},"sourceType":"script"}