{"ast":null,"code":"\"use strict\";\n/**\n * This file includes Solidity tracing heuristics for solc starting with version\n * 0.6.9.\n *\n * This solc version introduced a significant change to how sourcemaps are\n * handled for inline yul/internal functions. These were mapped to the\n * unmapped/-1 file before, which lead to many unmapped reverts. Now, they are\n * mapped to the part of the Solidity source that lead to their inlining.\n *\n * This change is a very positive change, as errors would point to the correct\n * line by default. The only problem is that we used to rely very heavily on\n * unmapped reverts to decide when our error detection heuristics were to be\n * run. In fact, this heuristics were first introduced because of unmapped\n * reverts.\n *\n * Instead of synthetically completing stack traces when unmapped reverts occur,\n * we now start from complete stack traces and adjust them if we can provide\n * more meaningful errors.\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.adjustStackTrace = exports.stackTraceMayRequireAdjustments = void 0;\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nconst FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS = \"0.6.9\";\n\nfunction stackTraceMayRequireAdjustments(stackTrace, decodedTrace) {\n  if (stackTrace.length === 0) {\n    return false;\n  }\n\n  const lastFrame = stackTrace[stackTrace.length - 1];\n  return lastFrame.type === solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR && !lastFrame.isInvalidOpcodeError && lastFrame.message.isEmpty() && semver_1.default.gte(decodedTrace.bytecode.compilerVersion, FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS);\n}\n\nexports.stackTraceMayRequireAdjustments = stackTraceMayRequireAdjustments;\n\nfunction adjustStackTrace(stackTrace, decodedTrace) {\n  const start = stackTrace.slice(0, -1);\n  const [revert] = stackTrace.slice(-1);\n\n  if (isNonContractAccountCalledError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  if (isConstructorInvalidParamsError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  if (isCallInvalidParamsError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  return stackTrace;\n}\n\nexports.adjustStackTrace = adjustStackTrace;\n\nfunction isNonContractAccountCalledError(decodedTrace) {\n  return matchOpcodes(decodedTrace, -9, [opcodes_1.Opcode.EXTCODESIZE, opcodes_1.Opcode.ISZERO, opcodes_1.Opcode.DUP1, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction isConstructorInvalidParamsError(decodedTrace) {\n  if (!message_trace_1.isDecodedCreateTrace(decodedTrace)) {\n    return false;\n  }\n\n  return matchOpcodes(decodedTrace, -20, [opcodes_1.Opcode.CODESIZE]) && matchOpcodes(decodedTrace, -15, [opcodes_1.Opcode.CODECOPY]) && matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction isCallInvalidParamsError(decodedTrace) {\n  if (!message_trace_1.isDecodedCallTrace(decodedTrace)) {\n    return false;\n  }\n\n  return matchOpcodes(decodedTrace, -11, [opcodes_1.Opcode.CALLDATASIZE]) && matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction matchOpcode(decodedTrace, stepIndex, opcode) {\n  const [step] = decodedTrace.steps.slice(stepIndex, stepIndex + 1);\n\n  if (step === undefined || !message_trace_1.isEvmStep(step)) {\n    return false;\n  }\n\n  const instruction = decodedTrace.bytecode.getInstruction(step.pc);\n  return instruction.opcode === opcode;\n}\n\nfunction matchOpcodes(decodedTrace, firstStepIndex, opcodes) {\n  let index = firstStepIndex;\n\n  for (const opcode of opcodes) {\n    if (!matchOpcode(decodedTrace, index, opcode)) {\n      return false;\n    }\n\n    index += 1;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["../../../src/internal/hardhat-network/stack-traces/mapped-inlined-internal-functions-heuristics.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * This file includes Solidity tracing heuristics for solc starting with version\n * 0.6.9.\n *\n * This solc version introduced a significant change to how sourcemaps are\n * handled for inline yul/internal functions. These were mapped to the\n * unmapped/-1 file before, which lead to many unmapped reverts. Now, they are\n * mapped to the part of the Solidity source that lead to their inlining.\n *\n * This change is a very positive change, as errors would point to the correct\n * line by default. The only problem is that we used to rely very heavily on\n * unmapped reverts to decide when our error detection heuristics were to be\n * run. In fact, this heuristics were first introduced because of unmapped\n * reverts.\n *\n * Instead of synthetically completing stack traces when unmapped reverts occur,\n * we now start from complete stack traces and adjust them if we can provide\n * more meaningful errors.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.adjustStackTrace = exports.stackTraceMayRequireAdjustments = void 0;\nconst semver_1 = __importDefault(require(\"semver\"));\nconst message_trace_1 = require(\"./message-trace\");\nconst opcodes_1 = require(\"./opcodes\");\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\nconst FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS = \"0.6.9\";\nfunction stackTraceMayRequireAdjustments(stackTrace, decodedTrace) {\n    if (stackTrace.length === 0) {\n        return false;\n    }\n    const lastFrame = stackTrace[stackTrace.length - 1];\n    return (lastFrame.type === solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR &&\n        !lastFrame.isInvalidOpcodeError &&\n        lastFrame.message.isEmpty() &&\n        semver_1.default.gte(decodedTrace.bytecode.compilerVersion, FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS));\n}\nexports.stackTraceMayRequireAdjustments = stackTraceMayRequireAdjustments;\nfunction adjustStackTrace(stackTrace, decodedTrace) {\n    const start = stackTrace.slice(0, -1);\n    const [revert] = stackTrace.slice(-1);\n    if (isNonContractAccountCalledError(decodedTrace)) {\n        return [\n            ...start,\n            {\n                type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n                sourceReference: revert.sourceReference,\n            },\n        ];\n    }\n    if (isConstructorInvalidParamsError(decodedTrace)) {\n        return [\n            ...start,\n            {\n                type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n                sourceReference: revert.sourceReference,\n            },\n        ];\n    }\n    if (isCallInvalidParamsError(decodedTrace)) {\n        return [\n            ...start,\n            {\n                type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n                sourceReference: revert.sourceReference,\n            },\n        ];\n    }\n    return stackTrace;\n}\nexports.adjustStackTrace = adjustStackTrace;\nfunction isNonContractAccountCalledError(decodedTrace) {\n    return matchOpcodes(decodedTrace, -9, [\n        opcodes_1.Opcode.EXTCODESIZE,\n        opcodes_1.Opcode.ISZERO,\n        opcodes_1.Opcode.DUP1,\n        opcodes_1.Opcode.ISZERO,\n    ]);\n}\nfunction isConstructorInvalidParamsError(decodedTrace) {\n    if (!message_trace_1.isDecodedCreateTrace(decodedTrace)) {\n        return false;\n    }\n    return (matchOpcodes(decodedTrace, -20, [opcodes_1.Opcode.CODESIZE]) &&\n        matchOpcodes(decodedTrace, -15, [opcodes_1.Opcode.CODECOPY]) &&\n        matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]));\n}\nfunction isCallInvalidParamsError(decodedTrace) {\n    if (!message_trace_1.isDecodedCallTrace(decodedTrace)) {\n        return false;\n    }\n    return (matchOpcodes(decodedTrace, -11, [opcodes_1.Opcode.CALLDATASIZE]) &&\n        matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]));\n}\nfunction matchOpcode(decodedTrace, stepIndex, opcode) {\n    const [step] = decodedTrace.steps.slice(stepIndex, stepIndex + 1);\n    if (step === undefined || !message_trace_1.isEvmStep(step)) {\n        return false;\n    }\n    const instruction = decodedTrace.bytecode.getInstruction(step.pc);\n    return instruction.opcode === opcode;\n}\nfunction matchOpcodes(decodedTrace, firstStepIndex, opcodes) {\n    let index = firstStepIndex;\n    for (const opcode of opcodes) {\n        if (!matchOpcode(decodedTrace, index, opcode)) {\n            return false;\n        }\n        index += 1;\n    }\n    return true;\n}\n//# sourceMappingURL=mapped-inlined-internal-functions-heuristics.js.map"]},"metadata":{},"sourceType":"script"}