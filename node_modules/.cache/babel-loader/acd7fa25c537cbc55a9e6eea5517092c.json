{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Environment = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst artifacts_1 = require(\"../artifacts\");\n\nconst lazy_1 = require(\"../util/lazy\");\n\nconst config_loading_1 = require(\"./config/config-loading\");\n\nconst errors_1 = require(\"./errors\");\n\nconst errors_list_1 = require(\"./errors-list\");\n\nconst construction_1 = require(\"./providers/construction\");\n\nconst task_definitions_1 = require(\"./tasks/task-definitions\");\n\nconst log = debug_1.default(\"hardhat:core:hre\");\n\nclass Environment {\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param extenders A list of extenders.\n   */\n  constructor(config, hardhatArguments, tasks, extenders = [], experimentalHardhatNetworkMessageTraceHooks = []) {\n    this.config = config;\n    this.hardhatArguments = hardhatArguments;\n    this.tasks = tasks;\n    /**\n     * Executes the task with the given name.\n     *\n     * @param name The task's name.\n     * @param taskArguments A map of task's arguments.\n     *\n     * @throws a HH303 if there aren't any defined tasks with the given name.\n     * @returns a promise with the task's execution result.\n     */\n\n    this.run = async (name, taskArguments = {}) => {\n      const taskDefinition = this.tasks[name];\n      log(\"Running task %s\", name);\n\n      if (taskDefinition === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: name\n        });\n      }\n\n      const resolvedTaskArguments = this._resolveValidTaskArguments(taskDefinition, taskArguments);\n\n      try {\n        return await this._runTaskDefinition(taskDefinition, resolvedTaskArguments);\n      } catch (e) {\n        config_loading_1.analyzeModuleNotFoundError(e, this.config.paths.configFile); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw e;\n      }\n    };\n\n    log(\"Creating HardhatRuntimeEnvironment\");\n    const networkName = hardhatArguments.network !== undefined ? hardhatArguments.network : config.defaultNetwork;\n    const networkConfig = config.networks[networkName];\n\n    if (networkConfig === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName\n      });\n    }\n\n    this.artifacts = new artifacts_1.Artifacts(config.paths.artifacts);\n    const provider = lazy_1.lazyObject(() => {\n      log(`Creating provider for network ${networkName}`);\n      return construction_1.createProvider(networkName, networkConfig, this.config.paths, this.artifacts, experimentalHardhatNetworkMessageTraceHooks.map(hook => (trace, isCallMessageTrace) => hook(this, trace, isCallMessageTrace)));\n    });\n    this.network = {\n      name: networkName,\n      config: config.networks[networkName],\n      provider\n    };\n    this._extenders = extenders;\n    extenders.forEach(extender => extender(this));\n  }\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n\n\n  injectToGlobal(blacklist = Environment._BLACKLISTED_PROPERTIES) {\n    const globalAsAny = global;\n    const previousValues = {};\n    const previousHre = globalAsAny.hre;\n    globalAsAny.hre = this;\n\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n\n  async _runTaskDefinition(taskDefinition, taskArguments) {\n    let runSuperFunction;\n\n    if (taskDefinition instanceof task_definitions_1.OverriddenTaskDefinition) {\n      runSuperFunction = async (_taskArguments = taskArguments) => {\n        log(\"Running %s's super\", taskDefinition.name);\n        return this._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments);\n      };\n\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name\n        });\n      };\n\n      runSuperFunction.isDefined = false;\n    }\n\n    const runSuper = runSuperFunction;\n    const globalAsAny = global;\n    const previousRunSuper = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n    const uninjectFromGlobal = this.injectToGlobal();\n\n    try {\n      return await taskDefinition.action(taskArguments, this, runSuper);\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n\n\n  _resolveValidTaskArguments(taskDefinition, taskArguments) {\n    const {\n      paramDefinitions,\n      positionalParamDefinitions\n    } = taskDefinition;\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions); // gather all task param definitions\n\n    const allTaskParamDefinitions = [...nonPositionalParamDefinitions, ...positionalParamDefinitions];\n    const initResolvedArguments = {\n      errors: [],\n      values: {}\n    };\n    const resolvedArguments = allTaskParamDefinitions.reduce(({\n      errors,\n      values\n    }, paramDefinition) => {\n      try {\n        const paramName = paramDefinition.name;\n        const argumentValue = taskArguments[paramName];\n\n        const resolvedArgumentValue = this._resolveArgument(paramDefinition, argumentValue);\n\n        if (resolvedArgumentValue !== undefined) {\n          values[paramName] = resolvedArgumentValue;\n        }\n      } catch (error) {\n        errors.push(error);\n      }\n\n      return {\n        errors,\n        values\n      };\n    }, initResolvedArguments);\n    const {\n      errors: resolveErrors,\n      values: resolvedValues\n    } = resolvedArguments; // if has argument errors, throw the first one\n\n    if (resolveErrors.length > 0) {\n      throw resolveErrors[0];\n    } // append the rest of arguments that where not in the task param definitions\n\n\n    const resolvedTaskArguments = Object.assign(Object.assign({}, taskArguments), resolvedValues);\n    return resolvedTaskArguments;\n  }\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n\n\n  _resolveArgument(paramDefinition, argumentValue) {\n    const {\n      name,\n      isOptional,\n      defaultValue\n    } = paramDefinition;\n\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      } // undefined & mandatory argument -> error\n\n\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name\n      });\n    } // arg was present -> validate type, if applicable\n\n\n    this._checkTypeValidation(paramDefinition, argumentValue);\n\n    return argumentValue;\n  }\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n\n\n  _checkTypeValidation(paramDefinition, argumentValue) {\n    const {\n      name: paramName,\n      type,\n      isVariadic\n    } = paramDefinition; // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n\n}\n\nexports.Environment = Environment;\nEnvironment._BLACKLISTED_PROPERTIES = [\"injectToGlobal\", \"_runTaskDefinition\"];","map":{"version":3,"sources":["../../src/internal/core/runtime-environment.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Environment = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst artifacts_1 = require(\"../artifacts\");\nconst lazy_1 = require(\"../util/lazy\");\nconst config_loading_1 = require(\"./config/config-loading\");\nconst errors_1 = require(\"./errors\");\nconst errors_list_1 = require(\"./errors-list\");\nconst construction_1 = require(\"./providers/construction\");\nconst task_definitions_1 = require(\"./tasks/task-definitions\");\nconst log = debug_1.default(\"hardhat:core:hre\");\nclass Environment {\n    /**\n     * Initializes the Hardhat Runtime Environment and the given\n     * extender functions.\n     *\n     * @remarks The extenders' execution order is given by the order\n     * of the requires in the hardhat's config file and its plugins.\n     *\n     * @param config The hardhat's config object.\n     * @param hardhatArguments The parsed hardhat's arguments.\n     * @param tasks A map of tasks.\n     * @param extenders A list of extenders.\n     */\n    constructor(config, hardhatArguments, tasks, extenders = [], experimentalHardhatNetworkMessageTraceHooks = []) {\n        this.config = config;\n        this.hardhatArguments = hardhatArguments;\n        this.tasks = tasks;\n        /**\n         * Executes the task with the given name.\n         *\n         * @param name The task's name.\n         * @param taskArguments A map of task's arguments.\n         *\n         * @throws a HH303 if there aren't any defined tasks with the given name.\n         * @returns a promise with the task's execution result.\n         */\n        this.run = async (name, taskArguments = {}) => {\n            const taskDefinition = this.tasks[name];\n            log(\"Running task %s\", name);\n            if (taskDefinition === undefined) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n                    task: name,\n                });\n            }\n            const resolvedTaskArguments = this._resolveValidTaskArguments(taskDefinition, taskArguments);\n            try {\n                return await this._runTaskDefinition(taskDefinition, resolvedTaskArguments);\n            }\n            catch (e) {\n                config_loading_1.analyzeModuleNotFoundError(e, this.config.paths.configFile);\n                // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n                throw e;\n            }\n        };\n        log(\"Creating HardhatRuntimeEnvironment\");\n        const networkName = hardhatArguments.network !== undefined\n            ? hardhatArguments.network\n            : config.defaultNetwork;\n        const networkConfig = config.networks[networkName];\n        if (networkConfig === undefined) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n                network: networkName,\n            });\n        }\n        this.artifacts = new artifacts_1.Artifacts(config.paths.artifacts);\n        const provider = lazy_1.lazyObject(() => {\n            log(`Creating provider for network ${networkName}`);\n            return construction_1.createProvider(networkName, networkConfig, this.config.paths, this.artifacts, experimentalHardhatNetworkMessageTraceHooks.map((hook) => (trace, isCallMessageTrace) => hook(this, trace, isCallMessageTrace)));\n        });\n        this.network = {\n            name: networkName,\n            config: config.networks[networkName],\n            provider,\n        };\n        this._extenders = extenders;\n        extenders.forEach((extender) => extender(this));\n    }\n    /**\n     * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n     *\n     * @param blacklist a list of property names that won't be injected.\n     *\n     * @returns a function that restores the previous environment.\n     */\n    injectToGlobal(blacklist = Environment._BLACKLISTED_PROPERTIES) {\n        const globalAsAny = global;\n        const previousValues = {};\n        const previousHre = globalAsAny.hre;\n        globalAsAny.hre = this;\n        for (const [key, value] of Object.entries(this)) {\n            if (blacklist.includes(key)) {\n                continue;\n            }\n            previousValues[key] = globalAsAny[key];\n            globalAsAny[key] = value;\n        }\n        return () => {\n            for (const [key, _] of Object.entries(this)) {\n                if (blacklist.includes(key)) {\n                    continue;\n                }\n                globalAsAny.hre = previousHre;\n                globalAsAny[key] = previousValues[key];\n            }\n        };\n    }\n    async _runTaskDefinition(taskDefinition, taskArguments) {\n        let runSuperFunction;\n        if (taskDefinition instanceof task_definitions_1.OverriddenTaskDefinition) {\n            runSuperFunction = async (_taskArguments = taskArguments) => {\n                log(\"Running %s's super\", taskDefinition.name);\n                return this._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments);\n            };\n            runSuperFunction.isDefined = true;\n        }\n        else {\n            runSuperFunction = async () => {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n                    taskName: taskDefinition.name,\n                });\n            };\n            runSuperFunction.isDefined = false;\n        }\n        const runSuper = runSuperFunction;\n        const globalAsAny = global;\n        const previousRunSuper = globalAsAny.runSuper;\n        globalAsAny.runSuper = runSuper;\n        const uninjectFromGlobal = this.injectToGlobal();\n        try {\n            return await taskDefinition.action(taskArguments, this, runSuper);\n        }\n        finally {\n            uninjectFromGlobal();\n            globalAsAny.runSuper = previousRunSuper;\n        }\n    }\n    /**\n     * Check that task arguments are within TaskDefinition defined params constraints.\n     * Also, populate missing, non-mandatory arguments with default param values (if any).\n     *\n     * @private\n     * @throws HardhatError if any of the following are true:\n     *  > a required argument is missing\n     *  > an argument's value's type doesn't match the defined param type\n     *\n     * @param taskDefinition\n     * @param taskArguments\n     * @returns resolvedTaskArguments\n     */\n    _resolveValidTaskArguments(taskDefinition, taskArguments) {\n        const { paramDefinitions, positionalParamDefinitions } = taskDefinition;\n        const nonPositionalParamDefinitions = Object.values(paramDefinitions);\n        // gather all task param definitions\n        const allTaskParamDefinitions = [\n            ...nonPositionalParamDefinitions,\n            ...positionalParamDefinitions,\n        ];\n        const initResolvedArguments = { errors: [], values: {} };\n        const resolvedArguments = allTaskParamDefinitions.reduce(({ errors, values }, paramDefinition) => {\n            try {\n                const paramName = paramDefinition.name;\n                const argumentValue = taskArguments[paramName];\n                const resolvedArgumentValue = this._resolveArgument(paramDefinition, argumentValue);\n                if (resolvedArgumentValue !== undefined) {\n                    values[paramName] = resolvedArgumentValue;\n                }\n            }\n            catch (error) {\n                errors.push(error);\n            }\n            return { errors, values };\n        }, initResolvedArguments);\n        const { errors: resolveErrors, values: resolvedValues } = resolvedArguments;\n        // if has argument errors, throw the first one\n        if (resolveErrors.length > 0) {\n            throw resolveErrors[0];\n        }\n        // append the rest of arguments that where not in the task param definitions\n        const resolvedTaskArguments = Object.assign(Object.assign({}, taskArguments), resolvedValues);\n        return resolvedTaskArguments;\n    }\n    /**\n     * Resolves an argument according to a ParamDefinition rules.\n     *\n     * @param paramDefinition\n     * @param argumentValue\n     * @private\n     */\n    _resolveArgument(paramDefinition, argumentValue) {\n        const { name, isOptional, defaultValue } = paramDefinition;\n        if (argumentValue === undefined) {\n            if (isOptional) {\n                // undefined & optional argument -> return defaultValue\n                return defaultValue;\n            }\n            // undefined & mandatory argument -> error\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n                param: name,\n            });\n        }\n        // arg was present -> validate type, if applicable\n        this._checkTypeValidation(paramDefinition, argumentValue);\n        return argumentValue;\n    }\n    /**\n     * Checks if value is valid for the specified param definition.\n     *\n     * @param paramDefinition {ParamDefinition} - the param definition for validation\n     * @param argumentValue - the value to be validated\n     * @private\n     * @throws HH301 if value is not valid for the param type\n     */\n    _checkTypeValidation(paramDefinition, argumentValue) {\n        const { name: paramName, type, isVariadic } = paramDefinition;\n        // in case of variadic param, argValue is an array and the type validation must pass for all values.\n        // otherwise, it's a single value that is to be validated\n        const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n        for (const value of argumentValueContainer) {\n            type.validate(paramName, value);\n        }\n    }\n}\nexports.Environment = Environment;\nEnvironment._BLACKLISTED_PROPERTIES = [\n    \"injectToGlobal\",\n    \"_runTaskDefinition\",\n];\n//# sourceMappingURL=runtime-environment.js.map"]},"metadata":{},"sourceType":"script"}