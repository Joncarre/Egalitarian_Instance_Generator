{"ast":null,"code":"import { addContextToFrame, basename, dirname, SyncPromise } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\nimport * as stacktrace from './stacktrace';\nvar DEFAULT_LINES_OF_CONTEXT = 7;\nvar FILE_CONTENT_CACHE = new LRUMap(100);\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\n\nexport function resetFileContentCache() {\n  FILE_CONTENT_CACHE.clear();\n}\n/** JSDoc */\n\nfunction getFunction(frame) {\n  try {\n    return frame.functionName || frame.typeName + \".\" + (frame.methodName || '<anonymous>');\n  } catch (e) {\n    // This seems to happen sometimes when using 'use strict',\n    // stemming from `getTypeName`.\n    // [TypeError: Cannot read property 'constructor' of undefined]\n    return '<anonymous>';\n  }\n}\n\nvar mainModule = (require.main && require.main.filename && dirname(require.main.filename) || global.process.cwd()) + \"/\";\n/** JSDoc */\n\nfunction getModule(filename, base) {\n  if (!base) {\n    // eslint-disable-next-line no-param-reassign\n    base = mainModule;\n  } // It's specifically a module\n\n\n  var file = basename(filename, '.js'); // eslint-disable-next-line no-param-reassign\n\n  filename = dirname(filename);\n  var n = filename.lastIndexOf('/node_modules/');\n\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return filename.substr(n + 14).replace(/\\//g, '.') + \":\" + file;\n  } // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n\n\n  n = (filename + \"/\").lastIndexOf(base, 0);\n\n  if (n === 0) {\n    var moduleName = filename.substr(base.length).replace(/\\//g, '.');\n\n    if (moduleName) {\n      moduleName += ':';\n    }\n\n    moduleName += file;\n    return moduleName;\n  }\n\n  return file;\n}\n/**\n * This function reads file contents and caches them in a global LRU cache.\n * Returns a Promise filepath => content array for all files that we were able to read.\n *\n * @param filenames Array of filepaths to read content from.\n */\n\n\nfunction readSourceFiles(filenames) {\n  // we're relying on filenames being de-duped already\n  if (filenames.length === 0) {\n    return SyncPromise.resolve({});\n  }\n\n  return new SyncPromise(function (resolve) {\n    var sourceFiles = {};\n    var count = 0;\n\n    var _loop_1 = function (i) {\n      var filename = filenames[i];\n      var cache = FILE_CONTENT_CACHE.get(filename); // We have a cache hit\n\n      if (cache !== undefined) {\n        // If it's not null (which means we found a file and have a content)\n        // we set the content and return it later.\n        if (cache !== null) {\n          sourceFiles[filename] = cache;\n        } // eslint-disable-next-line no-plusplus\n\n\n        count++; // In any case we want to skip here then since we have a content already or we couldn't\n        // read the file and don't want to try again.\n\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n\n        return \"continue\";\n      }\n\n      readFile(filename, function (err, data) {\n        var content = err ? null : data.toString();\n        sourceFiles[filename] = content; // We always want to set the cache, even to null which means there was an error reading the file.\n        // We do not want to try to read the file again.\n\n        FILE_CONTENT_CACHE.set(filename, content); // eslint-disable-next-line no-plusplus\n\n        count++;\n\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n      });\n    }; // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n\n    for (var i = 0; i < filenames.length; i++) {\n      _loop_1(i);\n    }\n  });\n}\n/**\n * @hidden\n */\n\n\nexport function extractStackFromError(error) {\n  var stack = stacktrace.parse(error);\n\n  if (!stack) {\n    return [];\n  }\n\n  return stack;\n}\n/**\n * @hidden\n */\n\nexport function parseStack(stack, options) {\n  var filesToRead = [];\n  var linesOfContext = options && options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n  var frames = stack.map(function (frame) {\n    var parsedFrame = {\n      colno: frame.columnNumber,\n      filename: frame.fileName || '',\n      function: getFunction(frame),\n      lineno: frame.lineNumber\n    };\n    var isInternal = frame.native || parsedFrame.filename && !parsedFrame.filename.startsWith('/') && !parsedFrame.filename.startsWith('.') && parsedFrame.filename.indexOf(':\\\\') !== 1; // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n\n    parsedFrame.in_app = !isInternal && parsedFrame.filename !== undefined && parsedFrame.filename.indexOf('node_modules/') === -1; // Extract a module name based on the filename\n\n    if (parsedFrame.filename) {\n      parsedFrame.module = getModule(parsedFrame.filename);\n\n      if (!isInternal && linesOfContext > 0 && filesToRead.indexOf(parsedFrame.filename) === -1) {\n        filesToRead.push(parsedFrame.filename);\n      }\n    }\n\n    return parsedFrame;\n  }); // We do an early return if we do not want to fetch context liens\n\n  if (linesOfContext <= 0) {\n    return SyncPromise.resolve(frames);\n  }\n\n  try {\n    return addPrePostContext(filesToRead, frames, linesOfContext);\n  } catch (_) {\n    // This happens in electron for example where we are not able to read files from asar.\n    // So it's fine, we recover be just returning all frames without pre/post context.\n    return SyncPromise.resolve(frames);\n  }\n}\n/**\n * This function tries to read the source files + adding pre and post context (source code)\n * to a frame.\n * @param filesToRead string[] of filepaths\n * @param frames StackFrame[] containg all frames\n */\n\nfunction addPrePostContext(filesToRead, frames, linesOfContext) {\n  return new SyncPromise(function (resolve) {\n    return readSourceFiles(filesToRead).then(function (sourceFiles) {\n      var result = frames.map(function (frame) {\n        if (frame.filename && sourceFiles[frame.filename]) {\n          try {\n            var lines = sourceFiles[frame.filename].split('\\n');\n            addContextToFrame(lines, frame, linesOfContext);\n          } catch (e) {// anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n\n        return frame;\n      });\n      resolve(result);\n    });\n  });\n}\n/**\n * @hidden\n */\n\n\nexport function getExceptionFromError(error, options) {\n  var name = error.name || error.constructor.name;\n  var stack = extractStackFromError(error);\n  return new SyncPromise(function (resolve) {\n    return parseStack(stack, options).then(function (frames) {\n      var result = {\n        stacktrace: {\n          frames: prepareFramesForEvent(frames)\n        },\n        type: name,\n        value: error.message\n      };\n      resolve(result);\n    });\n  });\n}\n/**\n * @hidden\n */\n\nexport function parseError(error, options) {\n  return new SyncPromise(function (resolve) {\n    return getExceptionFromError(error, options).then(function (exception) {\n      resolve({\n        exception: {\n          values: [exception]\n        }\n      });\n    });\n  });\n}\n/**\n * @hidden\n */\n\nexport function prepareFramesForEvent(stack) {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  var localStack = stack;\n  var firstFrameFunction = localStack[0].function || '';\n\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  } // The frame where the crash happened, should be the last entry in the array\n\n\n  return localStack.reverse();\n}","map":{"version":3,"sources":["../src/parsers.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, Exception, ExtendedError, StackFrame } from '@sentry/types';\nimport { addContextToFrame, basename, dirname, SyncPromise } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\n\nimport { NodeOptions } from './backend';\nimport * as stacktrace from './stacktrace';\n\nconst DEFAULT_LINES_OF_CONTEXT: number = 7;\nconst FILE_CONTENT_CACHE = new LRUMap<string, string | null>(100);\n\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\nexport function resetFileContentCache(): void {\n  FILE_CONTENT_CACHE.clear();\n}\n\n/** JSDoc */\nfunction getFunction(frame: stacktrace.StackFrame): string {\n  try {\n    return frame.functionName || `${frame.typeName}.${frame.methodName || '<anonymous>'}`;\n  } catch (e) {\n    // This seems to happen sometimes when using 'use strict',\n    // stemming from `getTypeName`.\n    // [TypeError: Cannot read property 'constructor' of undefined]\n    return '<anonymous>';\n  }\n}\n\nconst mainModule: string = `${(require.main && require.main.filename && dirname(require.main.filename)) ||\n  global.process.cwd()}/`;\n\n/** JSDoc */\nfunction getModule(filename: string, base?: string): string {\n  if (!base) {\n    // eslint-disable-next-line no-param-reassign\n    base = mainModule;\n  }\n\n  // It's specifically a module\n  const file = basename(filename, '.js');\n  // eslint-disable-next-line no-param-reassign\n  filename = dirname(filename);\n  let n = filename.lastIndexOf('/node_modules/');\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return `${filename.substr(n + 14).replace(/\\//g, '.')}:${file}`;\n  }\n  // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n  n = `${filename}/`.lastIndexOf(base, 0);\n  if (n === 0) {\n    let moduleName = filename.substr(base.length).replace(/\\//g, '.');\n    if (moduleName) {\n      moduleName += ':';\n    }\n    moduleName += file;\n    return moduleName;\n  }\n  return file;\n}\n\n/**\n * This function reads file contents and caches them in a global LRU cache.\n * Returns a Promise filepath => content array for all files that we were able to read.\n *\n * @param filenames Array of filepaths to read content from.\n */\nfunction readSourceFiles(filenames: string[]): PromiseLike<{ [key: string]: string | null }> {\n  // we're relying on filenames being de-duped already\n  if (filenames.length === 0) {\n    return SyncPromise.resolve({});\n  }\n\n  return new SyncPromise<{\n    [key: string]: string | null;\n  }>(resolve => {\n    const sourceFiles: {\n      [key: string]: string | null;\n    } = {};\n\n    let count = 0;\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < filenames.length; i++) {\n      const filename = filenames[i];\n\n      const cache = FILE_CONTENT_CACHE.get(filename);\n      // We have a cache hit\n      if (cache !== undefined) {\n        // If it's not null (which means we found a file and have a content)\n        // we set the content and return it later.\n        if (cache !== null) {\n          sourceFiles[filename] = cache;\n        }\n        // eslint-disable-next-line no-plusplus\n        count++;\n        // In any case we want to skip here then since we have a content already or we couldn't\n        // read the file and don't want to try again.\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n        continue;\n      }\n\n      readFile(filename, (err: Error | null, data: Buffer) => {\n        const content = err ? null : data.toString();\n        sourceFiles[filename] = content;\n\n        // We always want to set the cache, even to null which means there was an error reading the file.\n        // We do not want to try to read the file again.\n        FILE_CONTENT_CACHE.set(filename, content);\n        // eslint-disable-next-line no-plusplus\n        count++;\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n      });\n    }\n  });\n}\n\n/**\n * @hidden\n */\nexport function extractStackFromError(error: Error): stacktrace.StackFrame[] {\n  const stack = stacktrace.parse(error);\n  if (!stack) {\n    return [];\n  }\n  return stack;\n}\n\n/**\n * @hidden\n */\nexport function parseStack(stack: stacktrace.StackFrame[], options?: NodeOptions): PromiseLike<StackFrame[]> {\n  const filesToRead: string[] = [];\n\n  const linesOfContext =\n    options && options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n\n  const frames: StackFrame[] = stack.map(frame => {\n    const parsedFrame: StackFrame = {\n      colno: frame.columnNumber,\n      filename: frame.fileName || '',\n      function: getFunction(frame),\n      lineno: frame.lineNumber,\n    };\n\n    const isInternal =\n      frame.native ||\n      (parsedFrame.filename &&\n        !parsedFrame.filename.startsWith('/') &&\n        !parsedFrame.filename.startsWith('.') &&\n        parsedFrame.filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    parsedFrame.in_app =\n      !isInternal && parsedFrame.filename !== undefined && parsedFrame.filename.indexOf('node_modules/') === -1;\n\n    // Extract a module name based on the filename\n    if (parsedFrame.filename) {\n      parsedFrame.module = getModule(parsedFrame.filename);\n\n      if (!isInternal && linesOfContext > 0 && filesToRead.indexOf(parsedFrame.filename) === -1) {\n        filesToRead.push(parsedFrame.filename);\n      }\n    }\n\n    return parsedFrame;\n  });\n\n  // We do an early return if we do not want to fetch context liens\n  if (linesOfContext <= 0) {\n    return SyncPromise.resolve(frames);\n  }\n\n  try {\n    return addPrePostContext(filesToRead, frames, linesOfContext);\n  } catch (_) {\n    // This happens in electron for example where we are not able to read files from asar.\n    // So it's fine, we recover be just returning all frames without pre/post context.\n    return SyncPromise.resolve(frames);\n  }\n}\n\n/**\n * This function tries to read the source files + adding pre and post context (source code)\n * to a frame.\n * @param filesToRead string[] of filepaths\n * @param frames StackFrame[] containg all frames\n */\nfunction addPrePostContext(\n  filesToRead: string[],\n  frames: StackFrame[],\n  linesOfContext: number,\n): PromiseLike<StackFrame[]> {\n  return new SyncPromise<StackFrame[]>(resolve =>\n    readSourceFiles(filesToRead).then(sourceFiles => {\n      const result = frames.map(frame => {\n        if (frame.filename && sourceFiles[frame.filename]) {\n          try {\n            const lines = (sourceFiles[frame.filename] as string).split('\\n');\n\n            addContextToFrame(lines, frame, linesOfContext);\n          } catch (e) {\n            // anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n        return frame;\n      });\n\n      resolve(result);\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function getExceptionFromError(error: Error, options?: NodeOptions): PromiseLike<Exception> {\n  const name = error.name || error.constructor.name;\n  const stack = extractStackFromError(error);\n  return new SyncPromise<Exception>(resolve =>\n    parseStack(stack, options).then(frames => {\n      const result = {\n        stacktrace: {\n          frames: prepareFramesForEvent(frames),\n        },\n        type: name,\n        value: error.message,\n      };\n      resolve(result);\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function parseError(error: ExtendedError, options?: NodeOptions): PromiseLike<Event> {\n  return new SyncPromise<Event>(resolve =>\n    getExceptionFromError(error, options).then((exception: Exception) => {\n      resolve({\n        exception: {\n          values: [exception],\n        },\n      });\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function prepareFramesForEvent(stack: StackFrame[]): StackFrame[] {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n  const firstFrameFunction = localStack[0].function || '';\n\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack.reverse();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}