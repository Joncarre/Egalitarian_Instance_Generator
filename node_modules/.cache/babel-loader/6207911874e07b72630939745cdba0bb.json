{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProvider = void 0;\n\nconst events_1 = require(\"events\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst errors_2 = require(\"./errors\");\n\nfunction isErrorResponse(response) {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\nconst TOO_MANY_REQUEST_STATUS = 429;\n\nclass HttpProvider extends events_1.EventEmitter {\n  constructor(_url, _networkName, _extraHeaders = {}, _timeout = 20000) {\n    super();\n    this._url = _url;\n    this._networkName = _networkName;\n    this._extraHeaders = _extraHeaders;\n    this._timeout = _timeout;\n    this._nextRequestId = 1;\n  }\n\n  get url() {\n    return this._url;\n  }\n\n  async request(args) {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);\n\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data; // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n    }\n\n    if (args.method === \"evm_revert\") {\n      this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n\n\n  async sendBatch(batch) {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1); // we need this to sort the responses\n\n    const idToIndexMap = {};\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data; // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw error;\n      }\n    } // We already know that it has this type, but TS can't infer it.\n\n\n    const responses = jsonRpcResponses; // we use the id to sort the responses so that they match the order of the requests\n\n    const sortedResponses = responses.map(response => [idToIndexMap[response.id], response.result]).sort(([indexA], [indexB]) => indexA - indexB).map(([, result]) => result);\n    return sortedResponses;\n  }\n\n  async _fetchJsonRpcResponse(request, retryNumber = 0) {\n    const {\n      default: fetch\n    } = await Promise.resolve().then(() => __importStar(require(\"node-fetch\")));\n\n    try {\n      const response = await fetch(this._url, {\n        method: \"POST\",\n        body: JSON.stringify(request),\n        redirect: \"follow\",\n        timeout: process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined ? 0 : this._timeout,\n        headers: Object.assign({\n          \"Content-Type\": \"application/json\"\n        }, this._extraHeaders)\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // Consume the response stream and discard its result\n        // See: https://github.com/node-fetch/node-fetch/issues/83\n        const _discarded = await response.text();\n\n        const seconds = this._getRetryAfterSeconds(response);\n\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        const url = new URL(this._url); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw new errors_2.ProviderError(`Too Many Requests error received from ${url.hostname}`, -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return jsonrpc_1.parseJsonResponse(await response.text());\n    } catch (error) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING, {\n          network: this._networkName\n        }, error);\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async _retry(request, seconds, retryNumber) {\n    await new Promise(resolve => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  _getJsonRpcRequest(method, params = []) {\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++\n    };\n  }\n\n  _shouldRetry(retryNumber, retryAfterSeconds) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _isRateLimitResponse(response) {\n    return response.status === TOO_MANY_REQUEST_STATUS;\n  }\n\n  _getRetryAfterSeconds(response) {\n    const header = response.headers.get(\"Retry-After\");\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n\n}\n\nexports.HttpProvider = HttpProvider;","map":{"version":3,"sources":["../../../src/internal/core/providers/http.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpProvider = void 0;\nconst events_1 = require(\"events\");\nconst constants_1 = require(\"../../constants\");\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst errors_2 = require(\"./errors\");\nfunction isErrorResponse(response) {\n    return typeof response.error !== \"undefined\";\n}\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\nconst TOO_MANY_REQUEST_STATUS = 429;\nclass HttpProvider extends events_1.EventEmitter {\n    constructor(_url, _networkName, _extraHeaders = {}, _timeout = 20000) {\n        super();\n        this._url = _url;\n        this._networkName = _networkName;\n        this._extraHeaders = _extraHeaders;\n        this._timeout = _timeout;\n        this._nextRequestId = 1;\n    }\n    get url() {\n        return this._url;\n    }\n    async request(args) {\n        // We create the error here to capture the stack traces at this point,\n        // the async call that follows would probably loose of the stack trace\n        const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n        const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);\n        const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n        if (isErrorResponse(jsonRpcResponse)) {\n            error.message = jsonRpcResponse.error.message;\n            error.code = jsonRpcResponse.error.code;\n            error.data = jsonRpcResponse.error.data;\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n        if (args.method === \"hardhat_reset\") {\n            this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n        }\n        if (args.method === \"evm_revert\") {\n            this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n        }\n        return jsonRpcResponse.result;\n    }\n    /**\n     * Sends a batch of requests. Fails if any of them fails.\n     */\n    async sendBatch(batch) {\n        // We create the errors here to capture the stack traces at this point,\n        // the async call that follows would probably loose of the stack trace\n        const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n        // we need this to sort the responses\n        const idToIndexMap = {};\n        const requests = batch.map((r, i) => {\n            const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n            idToIndexMap[jsonRpcRequest.id] = i;\n            return jsonRpcRequest;\n        });\n        const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n        for (const response of jsonRpcResponses) {\n            if (isErrorResponse(response)) {\n                error.message = response.error.message;\n                error.code = response.error.code;\n                error.data = response.error.data;\n                // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n                throw error;\n            }\n        }\n        // We already know that it has this type, but TS can't infer it.\n        const responses = jsonRpcResponses;\n        // we use the id to sort the responses so that they match the order of the requests\n        const sortedResponses = responses\n            .map((response) => [idToIndexMap[response.id], response.result])\n            .sort(([indexA], [indexB]) => indexA - indexB)\n            .map(([, result]) => result);\n        return sortedResponses;\n    }\n    async _fetchJsonRpcResponse(request, retryNumber = 0) {\n        const { default: fetch } = await Promise.resolve().then(() => __importStar(require(\"node-fetch\")));\n        try {\n            const response = await fetch(this._url, {\n                method: \"POST\",\n                body: JSON.stringify(request),\n                redirect: \"follow\",\n                timeout: process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined\n                    ? 0\n                    : this._timeout,\n                headers: Object.assign({ \"Content-Type\": \"application/json\" }, this._extraHeaders),\n            });\n            if (this._isRateLimitResponse(response)) {\n                // Consume the response stream and discard its result\n                // See: https://github.com/node-fetch/node-fetch/issues/83\n                const _discarded = await response.text();\n                const seconds = this._getRetryAfterSeconds(response);\n                if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n                    return await this._retry(request, seconds, retryNumber);\n                }\n                const url = new URL(this._url);\n                // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n                throw new errors_2.ProviderError(`Too Many Requests error received from ${url.hostname}`, -32005 // Limit exceeded according to EIP1474\n                );\n            }\n            return jsonrpc_1.parseJsonResponse(await response.text());\n        }\n        catch (error) {\n            if (error.code === \"ECONNREFUSED\") {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING, { network: this._networkName }, error);\n            }\n            if (error.type === \"request-timeout\") {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n            }\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n    }\n    async _retry(request, seconds, retryNumber) {\n        await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));\n        return this._fetchJsonRpcResponse(request, retryNumber + 1);\n    }\n    _getJsonRpcRequest(method, params = []) {\n        return {\n            jsonrpc: \"2.0\",\n            method,\n            params,\n            id: this._nextRequestId++,\n        };\n    }\n    _shouldRetry(retryNumber, retryAfterSeconds) {\n        if (retryNumber > MAX_RETRIES) {\n            return false;\n        }\n        if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n            return false;\n        }\n        return true;\n    }\n    _isRateLimitResponse(response) {\n        return response.status === TOO_MANY_REQUEST_STATUS;\n    }\n    _getRetryAfterSeconds(response) {\n        const header = response.headers.get(\"Retry-After\");\n        if (header === undefined || header === null) {\n            return undefined;\n        }\n        const parsed = parseInt(header, 10);\n        if (isNaN(parsed)) {\n            return undefined;\n        }\n        return parsed;\n    }\n}\nexports.HttpProvider = HttpProvider;\n//# sourceMappingURL=http.js.map"]},"metadata":{},"sourceType":"script"}