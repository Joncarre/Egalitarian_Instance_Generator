{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, Dsn, extractExceptionKeysForMessage, isError, isPlainObject, normalizeToSize, SyncPromise } from '@sentry/utils';\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\n\nvar NodeBackend =\n/** @class */\nfunction (_super) {\n  __extends(NodeBackend, _super);\n\n  function NodeBackend() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\n\n  NodeBackend.prototype.eventFromException = function (exception, hint) {\n    var _this = this; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var ex = exception;\n    var mechanism = {\n      handled: true,\n      type: 'generic'\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        var message = \"Non-Error exception captured with keys: \" + extractExceptionKeysForMessage(exception);\n        getCurrentHub().configureScope(function (scope) {\n          scope.setExtra('__serialized__', normalizeToSize(exception));\n        });\n        ex = hint && hint.syntheticException || new Error(message);\n        ex.message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = hint && hint.syntheticException || new Error(exception);\n        ex.message = exception;\n      }\n\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise(function (resolve, reject) {\n      return parseError(ex, _this._options).then(function (event) {\n        addExceptionTypeValue(event, undefined, undefined);\n        addExceptionMechanism(event, mechanism);\n        resolve(__assign(__assign({}, event), {\n          event_id: hint && hint.event_id\n        }));\n      }).then(null, reject);\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  NodeBackend.prototype.eventFromMessage = function (message, level, hint) {\n    var _this = this;\n\n    if (level === void 0) {\n      level = Severity.Info;\n    }\n\n    var event = {\n      event_id: hint && hint.event_id,\n      level: level,\n      message: message\n    };\n    return new SyncPromise(function (resolve) {\n      if (_this._options.attachStacktrace && hint && hint.syntheticException) {\n        var stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, _this._options).then(function (frames) {\n          event.stacktrace = {\n            frames: prepareFramesForEvent(frames)\n          };\n          resolve(event);\n        }).then(null, function () {\n          resolve(event);\n        });\n      } else {\n        resolve(event);\n      }\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  NodeBackend.prototype._setupTransport = function () {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return _super.prototype._setupTransport.call(this);\n    }\n\n    var dsn = new Dsn(this._options.dsn);\n\n    var transportOptions = __assign(__assign(__assign(__assign(__assign({}, this._options.transportOptions), this._options.httpProxy && {\n      httpProxy: this._options.httpProxy\n    }), this._options.httpsProxy && {\n      httpsProxy: this._options.httpsProxy\n    }), this._options.caCerts && {\n      caCerts: this._options.caCerts\n    }), {\n      dsn: this._options.dsn\n    });\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n\n    return new HTTPSTransport(transportOptions);\n  };\n\n  return NodeBackend;\n}(BaseBackend);\n\nexport { NodeBackend };","map":{"version":3,"sources":["../src/backend.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Mechanism, Options, Severity, Transport, TransportOptions } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  Dsn,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n\n  /** Sets the number of context lines for each frame when loading a file. */\n  frameContextLines?: number;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n}\n\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(exception: any, hint?: EventHint): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let ex: any = exception;\n    const mechanism: Mechanism = {\n      handled: true,\n      type: 'generic',\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n        getCurrentHub().configureScope(scope => {\n          scope.setExtra('__serialized__', normalizeToSize(exception as Record<string, unknown>));\n        });\n\n        ex = (hint && hint.syntheticException) || new Error(message);\n        (ex as Error).message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = (hint && hint.syntheticException) || new Error(exception as string);\n        (ex as Error).message = exception;\n      }\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise<Event>((resolve, reject) =>\n      parseError(ex as Error, this._options)\n        .then(event => {\n          addExceptionTypeValue(event, undefined, undefined);\n          addExceptionMechanism(event, mechanism);\n\n          resolve({\n            ...event,\n            event_id: hint && hint.event_id,\n          });\n        })\n        .then(null, reject),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): PromiseLike<Event> {\n    const event: Event = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    return new SyncPromise<Event>(resolve => {\n      if (this._options.attachStacktrace && hint && hint.syntheticException) {\n        const stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, this._options)\n          .then(frames => {\n            event.stacktrace = {\n              frames: prepareFramesForEvent(frames),\n            };\n            resolve(event);\n          })\n          .then(null, () => {\n            resolve(event);\n          });\n      } else {\n        resolve(event);\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const dsn = new Dsn(this._options.dsn);\n\n    const transportOptions: TransportOptions = {\n      ...this._options.transportOptions,\n      ...(this._options.httpProxy && { httpProxy: this._options.httpProxy }),\n      ...(this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }),\n      ...(this._options.caCerts && { caCerts: this._options.caCerts }),\n      dsn: this._options.dsn,\n    };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}