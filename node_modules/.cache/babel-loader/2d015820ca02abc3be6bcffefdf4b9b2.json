{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bytecode = exports.Instruction = exports.CustomError = exports.ContractFunction = exports.Contract = exports.SourceLocation = exports.SourceFile = exports.ContractFunctionVisibility = exports.ContractFunctionType = exports.ContractType = exports.JumpType = void 0;\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\n\nvar JumpType;\n\n(function (JumpType) {\n  JumpType[JumpType[\"NOT_JUMP\"] = 0] = \"NOT_JUMP\";\n  JumpType[JumpType[\"INTO_FUNCTION\"] = 1] = \"INTO_FUNCTION\";\n  JumpType[JumpType[\"OUTOF_FUNCTION\"] = 2] = \"OUTOF_FUNCTION\";\n  JumpType[JumpType[\"INTERNAL_JUMP\"] = 3] = \"INTERNAL_JUMP\";\n})(JumpType = exports.JumpType || (exports.JumpType = {}));\n\nvar ContractType;\n\n(function (ContractType) {\n  ContractType[ContractType[\"CONTRACT\"] = 0] = \"CONTRACT\";\n  ContractType[ContractType[\"LIBRARY\"] = 1] = \"LIBRARY\";\n})(ContractType = exports.ContractType || (exports.ContractType = {}));\n\nvar ContractFunctionType;\n\n(function (ContractFunctionType) {\n  ContractFunctionType[ContractFunctionType[\"CONSTRUCTOR\"] = 0] = \"CONSTRUCTOR\";\n  ContractFunctionType[ContractFunctionType[\"FUNCTION\"] = 1] = \"FUNCTION\";\n  ContractFunctionType[ContractFunctionType[\"FALLBACK\"] = 2] = \"FALLBACK\";\n  ContractFunctionType[ContractFunctionType[\"RECEIVE\"] = 3] = \"RECEIVE\";\n  ContractFunctionType[ContractFunctionType[\"GETTER\"] = 4] = \"GETTER\";\n  ContractFunctionType[ContractFunctionType[\"MODIFIER\"] = 5] = \"MODIFIER\";\n  ContractFunctionType[ContractFunctionType[\"FREE_FUNCTION\"] = 6] = \"FREE_FUNCTION\";\n})(ContractFunctionType = exports.ContractFunctionType || (exports.ContractFunctionType = {}));\n\nvar ContractFunctionVisibility;\n\n(function (ContractFunctionVisibility) {\n  ContractFunctionVisibility[ContractFunctionVisibility[\"PRIVATE\"] = 0] = \"PRIVATE\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"INTERNAL\"] = 1] = \"INTERNAL\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"PUBLIC\"] = 2] = \"PUBLIC\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"EXTERNAL\"] = 3] = \"EXTERNAL\";\n})(ContractFunctionVisibility = exports.ContractFunctionVisibility || (exports.ContractFunctionVisibility = {}));\n\nclass SourceFile {\n  constructor(sourceName, content) {\n    this.sourceName = sourceName;\n    this.content = content;\n    this.contracts = [];\n    this.functions = [];\n  }\n\n  addContract(contract) {\n    if (contract.location.file !== this) {\n      throw new Error(\"Trying to add a contract from another file\");\n    }\n\n    this.contracts.push(contract);\n  }\n\n  addFunction(func) {\n    if (func.location.file !== this) {\n      throw new Error(\"Trying to add a function from another file\");\n    }\n\n    this.functions.push(func);\n  }\n\n  getContainingFunction(location) {\n    // TODO: Optimize this with a binary search or an internal tree\n    for (const func of this.functions) {\n      if (func.location.contains(location)) {\n        return func;\n      }\n    }\n\n    return undefined;\n  }\n\n}\n\nexports.SourceFile = SourceFile;\n\nclass SourceLocation {\n  constructor(file, offset, length) {\n    this.file = file;\n    this.offset = offset;\n    this.length = length;\n  }\n\n  getStartingLineNumber() {\n    if (this._line === undefined) {\n      this._line = 1;\n\n      for (const c of this.file.content.slice(0, this.offset)) {\n        if (c === \"\\n\") {\n          this._line += 1;\n        }\n      }\n    }\n\n    return this._line;\n  }\n\n  getContainingFunction() {\n    return this.file.getContainingFunction(this);\n  }\n\n  contains(other) {\n    if (this.file !== other.file) {\n      return false;\n    }\n\n    if (other.offset < this.offset) {\n      return false;\n    }\n\n    return other.offset + other.length <= this.offset + this.length;\n  }\n\n  equals(other) {\n    return this.file === other.file && this.offset === other.offset && this.length === other.length;\n  }\n\n}\n\nexports.SourceLocation = SourceLocation;\n\nclass Contract {\n  constructor(name, type, location) {\n    this.name = name;\n    this.type = type;\n    this.location = location;\n    this.localFunctions = [];\n    this.customErrors = [];\n    this._selectorHexToFunction = new Map();\n  }\n\n  get constructorFunction() {\n    return this._constructor;\n  }\n\n  get fallback() {\n    return this._fallback;\n  }\n\n  get receive() {\n    return this._receive;\n  }\n\n  addLocalFunction(func) {\n    if (func.contract !== this) {\n      throw new Error(\"Function isn't local\");\n    }\n\n    if (func.visibility === ContractFunctionVisibility.PUBLIC || func.visibility === ContractFunctionVisibility.EXTERNAL) {\n      if (func.type === ContractFunctionType.FUNCTION || func.type === ContractFunctionType.GETTER) {\n        this._selectorHexToFunction.set(ethereumjs_util_1.bufferToHex(func.selector), func);\n      } else if (func.type === ContractFunctionType.CONSTRUCTOR) {\n        this._constructor = func;\n      } else if (func.type === ContractFunctionType.FALLBACK) {\n        this._fallback = func;\n      } else if (func.type === ContractFunctionType.RECEIVE) {\n        this._receive = func;\n      }\n    }\n\n    this.localFunctions.push(func);\n  }\n\n  addCustomError(customError) {\n    this.customErrors.push(customError);\n  }\n\n  addNextLinearizedBaseContract(baseContract) {\n    if (this._fallback === undefined && baseContract._fallback !== undefined) {\n      this._fallback = baseContract._fallback;\n    }\n\n    if (this._receive === undefined && baseContract._receive !== undefined) {\n      this._receive = baseContract._receive;\n    }\n\n    for (const baseContractFunction of baseContract.localFunctions) {\n      if (baseContractFunction.type !== ContractFunctionType.GETTER && baseContractFunction.type !== ContractFunctionType.FUNCTION) {\n        continue;\n      }\n\n      if (baseContractFunction.visibility !== ContractFunctionVisibility.PUBLIC && baseContractFunction.visibility !== ContractFunctionVisibility.EXTERNAL) {\n        continue;\n      }\n\n      const selectorHex = ethereumjs_util_1.bufferToHex(baseContractFunction.selector);\n\n      if (!this._selectorHexToFunction.has(selectorHex)) {\n        this._selectorHexToFunction.set(selectorHex, baseContractFunction);\n      }\n    }\n  }\n\n  getFunctionFromSelector(selector) {\n    return this._selectorHexToFunction.get(ethereumjs_util_1.bufferToHex(selector));\n  }\n  /**\n   * We compute selectors manually, which is particularly hard. We do this\n   * because we need to map selectors to AST nodes, and it seems easier to start\n   * from the AST node. This is surprisingly super hard: things like inherited\n   * enums, structs and ABIv2 complicate it.\n   *\n   * As we know that that can fail, we run a heuristic that tries to correct\n   * incorrect selectors. What it does is checking the `evm.methodIdentifiers`\n   * compiler output, and detect missing selectors. Then we take those and\n   * find contract functions with the same name. If there are multiple of those\n   * we can't do anything. If there is a single one, it must have an incorrect\n   * selector, so we update it with the `evm.methodIdentifiers`'s value.\n   */\n\n\n  correctSelector(functionName, selector) {\n    const functions = Array.from(this._selectorHexToFunction.values()).filter(cf => cf.name === functionName);\n\n    if (functions.length !== 1) {\n      return false;\n    }\n\n    const functionToCorrect = functions[0];\n\n    if (functionToCorrect.selector !== undefined) {\n      this._selectorHexToFunction.delete(ethereumjs_util_1.bufferToHex(functionToCorrect.selector));\n    }\n\n    functionToCorrect.selector = selector;\n\n    this._selectorHexToFunction.set(ethereumjs_util_1.bufferToHex(selector), functionToCorrect);\n\n    return true;\n  }\n\n}\n\nexports.Contract = Contract;\n\nclass ContractFunction {\n  constructor(name, type, location, contract, visibility, isPayable, selector) {\n    this.name = name;\n    this.type = type;\n    this.location = location;\n    this.contract = contract;\n    this.visibility = visibility;\n    this.isPayable = isPayable;\n    this.selector = selector;\n\n    if (contract !== undefined && !contract.location.contains(location)) {\n      throw new Error(\"Incompatible contract and function location\");\n    }\n  }\n\n}\n\nexports.ContractFunction = ContractFunction;\n\nclass CustomError {\n  constructor(selector, name, paramTypes) {\n    this.selector = selector;\n    this.name = name;\n    this.paramTypes = paramTypes;\n  }\n  /**\n   * Return a CustomError from the given ABI information: the name\n   * of the error and its inputs. Returns undefined if it can't build\n   * the CustomError.\n   */\n\n\n  static fromABI(name, inputs) {\n    const selector = abi_helpers_1.AbiHelpers.computeSelector(name, inputs);\n\n    if (selector !== undefined) {\n      return new CustomError(selector, name, inputs);\n    }\n  }\n\n}\n\nexports.CustomError = CustomError;\n\nclass Instruction {\n  constructor(pc, opcode, jumpType, pushData, location) {\n    this.pc = pc;\n    this.opcode = opcode;\n    this.jumpType = jumpType;\n    this.pushData = pushData;\n    this.location = location;\n  }\n\n}\n\nexports.Instruction = Instruction;\n\nclass Bytecode {\n  constructor(contract, isDeployment, normalizedCode, instructions, libraryAddressPositions, immutableReferences, compilerVersion) {\n    this.contract = contract;\n    this.isDeployment = isDeployment;\n    this.normalizedCode = normalizedCode;\n    this.instructions = instructions;\n    this.libraryAddressPositions = libraryAddressPositions;\n    this.immutableReferences = immutableReferences;\n    this.compilerVersion = compilerVersion;\n    this._pcToInstruction = new Map();\n\n    for (const inst of instructions) {\n      this._pcToInstruction.set(inst.pc, inst);\n    }\n  }\n\n  getInstruction(pc) {\n    const inst = this._pcToInstruction.get(pc);\n\n    if (inst === undefined) {\n      throw new Error(`There's no instruction at pc ${pc}`);\n    }\n\n    return inst;\n  }\n\n  hasInstruction(pc) {\n    return this._pcToInstruction.has(pc);\n  }\n\n}\n\nexports.Bytecode = Bytecode;","map":{"version":3,"sources":["../../../src/internal/hardhat-network/stack-traces/model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Bytecode = exports.Instruction = exports.CustomError = exports.ContractFunction = exports.Contract = exports.SourceLocation = exports.SourceFile = exports.ContractFunctionVisibility = exports.ContractFunctionType = exports.ContractType = exports.JumpType = void 0;\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\nvar JumpType;\n(function (JumpType) {\n    JumpType[JumpType[\"NOT_JUMP\"] = 0] = \"NOT_JUMP\";\n    JumpType[JumpType[\"INTO_FUNCTION\"] = 1] = \"INTO_FUNCTION\";\n    JumpType[JumpType[\"OUTOF_FUNCTION\"] = 2] = \"OUTOF_FUNCTION\";\n    JumpType[JumpType[\"INTERNAL_JUMP\"] = 3] = \"INTERNAL_JUMP\";\n})(JumpType = exports.JumpType || (exports.JumpType = {}));\nvar ContractType;\n(function (ContractType) {\n    ContractType[ContractType[\"CONTRACT\"] = 0] = \"CONTRACT\";\n    ContractType[ContractType[\"LIBRARY\"] = 1] = \"LIBRARY\";\n})(ContractType = exports.ContractType || (exports.ContractType = {}));\nvar ContractFunctionType;\n(function (ContractFunctionType) {\n    ContractFunctionType[ContractFunctionType[\"CONSTRUCTOR\"] = 0] = \"CONSTRUCTOR\";\n    ContractFunctionType[ContractFunctionType[\"FUNCTION\"] = 1] = \"FUNCTION\";\n    ContractFunctionType[ContractFunctionType[\"FALLBACK\"] = 2] = \"FALLBACK\";\n    ContractFunctionType[ContractFunctionType[\"RECEIVE\"] = 3] = \"RECEIVE\";\n    ContractFunctionType[ContractFunctionType[\"GETTER\"] = 4] = \"GETTER\";\n    ContractFunctionType[ContractFunctionType[\"MODIFIER\"] = 5] = \"MODIFIER\";\n    ContractFunctionType[ContractFunctionType[\"FREE_FUNCTION\"] = 6] = \"FREE_FUNCTION\";\n})(ContractFunctionType = exports.ContractFunctionType || (exports.ContractFunctionType = {}));\nvar ContractFunctionVisibility;\n(function (ContractFunctionVisibility) {\n    ContractFunctionVisibility[ContractFunctionVisibility[\"PRIVATE\"] = 0] = \"PRIVATE\";\n    ContractFunctionVisibility[ContractFunctionVisibility[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ContractFunctionVisibility[ContractFunctionVisibility[\"PUBLIC\"] = 2] = \"PUBLIC\";\n    ContractFunctionVisibility[ContractFunctionVisibility[\"EXTERNAL\"] = 3] = \"EXTERNAL\";\n})(ContractFunctionVisibility = exports.ContractFunctionVisibility || (exports.ContractFunctionVisibility = {}));\nclass SourceFile {\n    constructor(sourceName, content) {\n        this.sourceName = sourceName;\n        this.content = content;\n        this.contracts = [];\n        this.functions = [];\n    }\n    addContract(contract) {\n        if (contract.location.file !== this) {\n            throw new Error(\"Trying to add a contract from another file\");\n        }\n        this.contracts.push(contract);\n    }\n    addFunction(func) {\n        if (func.location.file !== this) {\n            throw new Error(\"Trying to add a function from another file\");\n        }\n        this.functions.push(func);\n    }\n    getContainingFunction(location) {\n        // TODO: Optimize this with a binary search or an internal tree\n        for (const func of this.functions) {\n            if (func.location.contains(location)) {\n                return func;\n            }\n        }\n        return undefined;\n    }\n}\nexports.SourceFile = SourceFile;\nclass SourceLocation {\n    constructor(file, offset, length) {\n        this.file = file;\n        this.offset = offset;\n        this.length = length;\n    }\n    getStartingLineNumber() {\n        if (this._line === undefined) {\n            this._line = 1;\n            for (const c of this.file.content.slice(0, this.offset)) {\n                if (c === \"\\n\") {\n                    this._line += 1;\n                }\n            }\n        }\n        return this._line;\n    }\n    getContainingFunction() {\n        return this.file.getContainingFunction(this);\n    }\n    contains(other) {\n        if (this.file !== other.file) {\n            return false;\n        }\n        if (other.offset < this.offset) {\n            return false;\n        }\n        return other.offset + other.length <= this.offset + this.length;\n    }\n    equals(other) {\n        return (this.file === other.file &&\n            this.offset === other.offset &&\n            this.length === other.length);\n    }\n}\nexports.SourceLocation = SourceLocation;\nclass Contract {\n    constructor(name, type, location) {\n        this.name = name;\n        this.type = type;\n        this.location = location;\n        this.localFunctions = [];\n        this.customErrors = [];\n        this._selectorHexToFunction = new Map();\n    }\n    get constructorFunction() {\n        return this._constructor;\n    }\n    get fallback() {\n        return this._fallback;\n    }\n    get receive() {\n        return this._receive;\n    }\n    addLocalFunction(func) {\n        if (func.contract !== this) {\n            throw new Error(\"Function isn't local\");\n        }\n        if (func.visibility === ContractFunctionVisibility.PUBLIC ||\n            func.visibility === ContractFunctionVisibility.EXTERNAL) {\n            if (func.type === ContractFunctionType.FUNCTION ||\n                func.type === ContractFunctionType.GETTER) {\n                this._selectorHexToFunction.set(ethereumjs_util_1.bufferToHex(func.selector), func);\n            }\n            else if (func.type === ContractFunctionType.CONSTRUCTOR) {\n                this._constructor = func;\n            }\n            else if (func.type === ContractFunctionType.FALLBACK) {\n                this._fallback = func;\n            }\n            else if (func.type === ContractFunctionType.RECEIVE) {\n                this._receive = func;\n            }\n        }\n        this.localFunctions.push(func);\n    }\n    addCustomError(customError) {\n        this.customErrors.push(customError);\n    }\n    addNextLinearizedBaseContract(baseContract) {\n        if (this._fallback === undefined && baseContract._fallback !== undefined) {\n            this._fallback = baseContract._fallback;\n        }\n        if (this._receive === undefined && baseContract._receive !== undefined) {\n            this._receive = baseContract._receive;\n        }\n        for (const baseContractFunction of baseContract.localFunctions) {\n            if (baseContractFunction.type !== ContractFunctionType.GETTER &&\n                baseContractFunction.type !== ContractFunctionType.FUNCTION) {\n                continue;\n            }\n            if (baseContractFunction.visibility !== ContractFunctionVisibility.PUBLIC &&\n                baseContractFunction.visibility !== ContractFunctionVisibility.EXTERNAL) {\n                continue;\n            }\n            const selectorHex = ethereumjs_util_1.bufferToHex(baseContractFunction.selector);\n            if (!this._selectorHexToFunction.has(selectorHex)) {\n                this._selectorHexToFunction.set(selectorHex, baseContractFunction);\n            }\n        }\n    }\n    getFunctionFromSelector(selector) {\n        return this._selectorHexToFunction.get(ethereumjs_util_1.bufferToHex(selector));\n    }\n    /**\n     * We compute selectors manually, which is particularly hard. We do this\n     * because we need to map selectors to AST nodes, and it seems easier to start\n     * from the AST node. This is surprisingly super hard: things like inherited\n     * enums, structs and ABIv2 complicate it.\n     *\n     * As we know that that can fail, we run a heuristic that tries to correct\n     * incorrect selectors. What it does is checking the `evm.methodIdentifiers`\n     * compiler output, and detect missing selectors. Then we take those and\n     * find contract functions with the same name. If there are multiple of those\n     * we can't do anything. If there is a single one, it must have an incorrect\n     * selector, so we update it with the `evm.methodIdentifiers`'s value.\n     */\n    correctSelector(functionName, selector) {\n        const functions = Array.from(this._selectorHexToFunction.values()).filter((cf) => cf.name === functionName);\n        if (functions.length !== 1) {\n            return false;\n        }\n        const functionToCorrect = functions[0];\n        if (functionToCorrect.selector !== undefined) {\n            this._selectorHexToFunction.delete(ethereumjs_util_1.bufferToHex(functionToCorrect.selector));\n        }\n        functionToCorrect.selector = selector;\n        this._selectorHexToFunction.set(ethereumjs_util_1.bufferToHex(selector), functionToCorrect);\n        return true;\n    }\n}\nexports.Contract = Contract;\nclass ContractFunction {\n    constructor(name, type, location, contract, visibility, isPayable, selector) {\n        this.name = name;\n        this.type = type;\n        this.location = location;\n        this.contract = contract;\n        this.visibility = visibility;\n        this.isPayable = isPayable;\n        this.selector = selector;\n        if (contract !== undefined && !contract.location.contains(location)) {\n            throw new Error(\"Incompatible contract and function location\");\n        }\n    }\n}\nexports.ContractFunction = ContractFunction;\nclass CustomError {\n    constructor(selector, name, paramTypes) {\n        this.selector = selector;\n        this.name = name;\n        this.paramTypes = paramTypes;\n    }\n    /**\n     * Return a CustomError from the given ABI information: the name\n     * of the error and its inputs. Returns undefined if it can't build\n     * the CustomError.\n     */\n    static fromABI(name, inputs) {\n        const selector = abi_helpers_1.AbiHelpers.computeSelector(name, inputs);\n        if (selector !== undefined) {\n            return new CustomError(selector, name, inputs);\n        }\n    }\n}\nexports.CustomError = CustomError;\nclass Instruction {\n    constructor(pc, opcode, jumpType, pushData, location) {\n        this.pc = pc;\n        this.opcode = opcode;\n        this.jumpType = jumpType;\n        this.pushData = pushData;\n        this.location = location;\n    }\n}\nexports.Instruction = Instruction;\nclass Bytecode {\n    constructor(contract, isDeployment, normalizedCode, instructions, libraryAddressPositions, immutableReferences, compilerVersion) {\n        this.contract = contract;\n        this.isDeployment = isDeployment;\n        this.normalizedCode = normalizedCode;\n        this.instructions = instructions;\n        this.libraryAddressPositions = libraryAddressPositions;\n        this.immutableReferences = immutableReferences;\n        this.compilerVersion = compilerVersion;\n        this._pcToInstruction = new Map();\n        for (const inst of instructions) {\n            this._pcToInstruction.set(inst.pc, inst);\n        }\n    }\n    getInstruction(pc) {\n        const inst = this._pcToInstruction.get(pc);\n        if (inst === undefined) {\n            throw new Error(`There's no instruction at pc ${pc}`);\n        }\n        return inst;\n    }\n    hasInstruction(pc) {\n        return this._pcToInstruction.has(pc);\n    }\n}\nexports.Bytecode = Bytecode;\n//# sourceMappingURL=model.js.map"]},"metadata":{},"sourceType":"script"}