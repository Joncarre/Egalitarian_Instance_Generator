{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseName = exports.parseFullyQualifiedName = exports.isFullyQualifiedName = exports.getFullyQualifiedName = void 0;\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n/**\n * Returns a fully qualified name from a sourceName and contractName.\n */\n\n\nfunction getFullyQualifiedName(sourceName, contractName) {\n  return `${sourceName}:${contractName}`;\n}\n\nexports.getFullyQualifiedName = getFullyQualifiedName;\n/**\n * Returns true if a name is fully qualified, and not just a bare contract name.\n */\n\nfunction isFullyQualifiedName(name) {\n  return name.includes(\":\");\n}\n\nexports.isFullyQualifiedName = isFullyQualifiedName;\n/**\n * Parses a fully qualified name.\n *\n * @param fullyQualifiedName It MUST be a fully qualified name.\n */\n\nfunction parseFullyQualifiedName(fullyQualifiedName) {\n  const {\n    sourceName,\n    contractName\n  } = parseName(fullyQualifiedName);\n\n  if (sourceName === undefined) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME, {\n      name: fullyQualifiedName\n    });\n  }\n\n  return {\n    sourceName,\n    contractName\n  };\n}\n\nexports.parseFullyQualifiedName = parseFullyQualifiedName;\n/**\n * Parses a name, which can be a bare contract name, or a fully qualified name.\n */\n\nfunction parseName(name) {\n  const parts = name.split(\":\");\n\n  if (parts.length === 1) {\n    return {\n      contractName: parts[0]\n    };\n  }\n\n  const contractName = parts[parts.length - 1];\n  const sourceName = parts.slice(0, parts.length - 1).join(\":\");\n  return {\n    sourceName,\n    contractName\n  };\n}\n\nexports.parseName = parseName;","map":{"version":3,"sources":["../src/utils/contract-names.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;AAEA;;AAEG;;;AACH,SAAgB,qBAAhB,CACE,UADF,EAEE,YAFF,EAEsB;AAEpB,SAAO,GAAG,UAAU,IAAI,YAAY,EAApC;AACD;;AALD,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAOA;;AAEG;;AACH,SAAgB,oBAAhB,CAAqC,IAArC,EAAiD;AAC/C,SAAO,IAAI,CAAC,QAAL,CAAc,GAAd,CAAP;AACD;;AAFD,OAAA,CAAA,oBAAA,GAAA,oBAAA;AAIA;;;;AAIG;;AACH,SAAgB,uBAAhB,CAAwC,kBAAxC,EAAkE;AAIhE,QAAM;AAAE,IAAA,UAAF;AAAc,IAAA;AAAd,MAA+B,SAAS,CAAC,kBAAD,CAA9C;;AAEA,MAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B,UAAM,IAAI,QAAA,CAAA,YAAJ,CAAiB,aAAA,CAAA,MAAA,CAAO,cAAP,CAAsB,4BAAvC,EAAqE;AACzE,MAAA,IAAI,EAAE;AADmE,KAArE,CAAN;AAGD;;AAED,SAAO;AAAE,IAAA,UAAF;AAAc,IAAA;AAAd,GAAP;AACD;;AAbD,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAeA;;AAEG;;AACH,SAAgB,SAAhB,CAA0B,IAA1B,EAAsC;AAIpC,QAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAd;;AAEA,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACtB,WAAO;AAAE,MAAA,YAAY,EAAE,KAAK,CAAC,CAAD;AAArB,KAAP;AACD;;AAED,QAAM,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAA1B;AACA,QAAM,UAAU,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,KAAK,CAAC,MAAN,GAAe,CAA9B,EAAiC,IAAjC,CAAsC,GAAtC,CAAnB;AAEA,SAAO;AAAE,IAAA,UAAF;AAAc,IAAA;AAAd,GAAP;AACD;;AAdD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseName = exports.parseFullyQualifiedName = exports.isFullyQualifiedName = exports.getFullyQualifiedName = void 0;\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n/**\n * Returns a fully qualified name from a sourceName and contractName.\n */\nfunction getFullyQualifiedName(sourceName, contractName) {\n    return `${sourceName}:${contractName}`;\n}\nexports.getFullyQualifiedName = getFullyQualifiedName;\n/**\n * Returns true if a name is fully qualified, and not just a bare contract name.\n */\nfunction isFullyQualifiedName(name) {\n    return name.includes(\":\");\n}\nexports.isFullyQualifiedName = isFullyQualifiedName;\n/**\n * Parses a fully qualified name.\n *\n * @param fullyQualifiedName It MUST be a fully qualified name.\n */\nfunction parseFullyQualifiedName(fullyQualifiedName) {\n    const { sourceName, contractName } = parseName(fullyQualifiedName);\n    if (sourceName === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME, {\n            name: fullyQualifiedName,\n        });\n    }\n    return { sourceName, contractName };\n}\nexports.parseFullyQualifiedName = parseFullyQualifiedName;\n/**\n * Parses a name, which can be a bare contract name, or a fully qualified name.\n */\nfunction parseName(name) {\n    const parts = name.split(\":\");\n    if (parts.length === 1) {\n        return { contractName: parts[0] };\n    }\n    const contractName = parts[parts.length - 1];\n    const sourceName = parts.slice(0, parts.length - 1).join(\":\");\n    return { sourceName, contractName };\n}\nexports.parseName = parseName;\n//# sourceMappingURL=contract-names.js.map"]},"metadata":{},"sourceType":"script"}