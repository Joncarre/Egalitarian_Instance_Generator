{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instructionToCallstackStackTraceEntry = exports.ErrorInferrer = void 0;\n\nconst exceptions_1 = require(\"@ethereumjs/vm/dist/exceptions\");\n\nconst abi_1 = require(\"@ethersproject/abi\");\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\n\nconst return_data_1 = require(\"../provider/return-data\");\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst model_1 = require(\"./model\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nconst FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION = \"0.5.9\";\nconst FIRST_SOLC_VERSION_RECEIVE_FUNCTION = \"0.6.0\";\nconst FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS = \"0.6.3\";\nconst EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT = 0x6000;\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nclass ErrorInferrer {\n  inferBeforeTracingCallMessage(trace) {\n    if (this._isDirectLibraryCall(trace)) {\n      return this._getDirectLibraryCallErrorStackTrace(trace);\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (this._isFunctionNotPayableError(trace, calledFunction)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n        value: trace.value\n      }];\n    }\n\n    if (this._isMissingFunctionAndFallbackError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR,\n          sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n        }];\n      }\n\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR,\n        sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n      }];\n    }\n\n    if (this._isFallbackNotPayableError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR,\n          sourceReference: this._getFallbackStartSourceReference(trace),\n          value: trace.value\n        }];\n      }\n\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR,\n        sourceReference: this._getFallbackStartSourceReference(trace),\n        value: trace.value\n      }];\n    }\n  }\n\n  inferBeforeTracingCreateMessage(trace) {\n    if (this._isConstructorNotPayableError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        value: trace.value\n      }];\n    }\n\n    if (this._isConstructorInvalidArgumentsError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace)\n      }];\n    }\n  }\n\n  inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData) {\n    var _a, _b, _c, _d, _e, _f;\n\n    return (_f = (_e = (_d = (_c = (_b = (_a = this._checkLastSubmessage(trace, stacktrace, lastSubmessageData)) !== null && _a !== void 0 ? _a : this._checkFailedLastCall(trace, stacktrace)) !== null && _b !== void 0 ? _b : this._checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction)) !== null && _c !== void 0 ? _c : this._checkNonContractCalled(trace, stacktrace)) !== null && _d !== void 0 ? _d : this._checkSolidity063UnmappedRevert(trace, stacktrace)) !== null && _e !== void 0 ? _e : this._checkContractTooLarge(trace)) !== null && _f !== void 0 ? _f : this._otherExecutionErrorStacktrace(trace, stacktrace);\n  }\n\n  filterRedundantFrames(stacktrace) {\n    return stacktrace.filter((frame, i) => {\n      if (i + 1 === stacktrace.length) {\n        return true;\n      }\n\n      const nextFrame = stacktrace[i + 1]; // we can only filter frames if we know their sourceReference\n      // and the one from the next frame\n\n      if (frame.sourceReference === undefined || nextFrame.sourceReference === undefined) {\n        return true;\n      } // constructors contain the whole contract, so we ignore them\n\n\n      if (frame.sourceReference.function === \"constructor\" && nextFrame.sourceReference.function !== \"constructor\") {\n        return true;\n      } // this is probably a recursive call\n\n\n      if (i > 0 && frame.type === nextFrame.type && frame.sourceReference.range[0] === nextFrame.sourceReference.range[0] && frame.sourceReference.range[1] === nextFrame.sourceReference.range[1] && frame.sourceReference.line === nextFrame.sourceReference.line) {\n        return true;\n      }\n\n      if (frame.sourceReference.range[0] <= nextFrame.sourceReference.range[0] && frame.sourceReference.range[1] >= nextFrame.sourceReference.range[1]) {\n        return false;\n      }\n\n      return true;\n    });\n  } // Heuristics\n\n  /**\n   * Check if the last submessage can be used to generate the stack trace.\n   */\n\n\n  _checkLastSubmessage(trace, stacktrace, lastSubmessageData) {\n    if (lastSubmessageData === undefined) {\n      return undefined;\n    }\n\n    const inferredStacktrace = [...stacktrace]; // get the instruction before the submessage and add it to the stack trace\n\n    const callStep = trace.steps[lastSubmessageData.stepIndex - 1];\n\n    if (!message_trace_1.isEvmStep(callStep)) {\n      throw new Error(\"This should not happen: MessageTrace should be preceded by a EVM step\");\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    const callStackFrame = instructionToCallstackStackTraceEntry(trace.bytecode, callInst);\n    const lastMessageFailed = lastSubmessageData.messageTrace.error !== undefined;\n\n    if (lastMessageFailed) {\n      // add the call/create that generated the message to the stack trace\n      inferredStacktrace.push(callStackFrame);\n\n      if (this._isSubtraceErrorPropagated(trace, lastSubmessageData.stepIndex) || this._isProxyErrorPropagated(trace, lastSubmessageData.stepIndex)) {\n        inferredStacktrace.push(...lastSubmessageData.stacktrace);\n\n        if (this._isContractCallRunOutOfGasError(trace, lastSubmessageData.stepIndex)) {\n          const lastFrame = inferredStacktrace.pop();\n          inferredStacktrace.push({\n            type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR,\n            sourceReference: lastFrame.sourceReference\n          });\n        }\n\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    } else {\n      const isReturnDataSizeError = this._failsRightAfterCall(trace, lastSubmessageData.stepIndex);\n\n      if (isReturnDataSizeError) {\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.RETURNDATA_SIZE_ERROR,\n          sourceReference: callStackFrame.sourceReference\n        });\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    }\n  }\n  /**\n   * Check if the last call/create that was done failed.\n   */\n\n\n  _checkFailedLastCall(trace, stacktrace) {\n    for (let stepIndex = trace.steps.length - 2; stepIndex >= 0; stepIndex--) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if (!message_trace_1.isEvmStep(step)) {\n        return;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n      const isCallOrCreate = opcodes_1.isCall(inst.opcode) || opcodes_1.isCreate(inst.opcode);\n\n      if (isCallOrCreate && message_trace_1.isEvmStep(nextStep)) {\n        if (this._isCallFailedError(trace, stepIndex, inst)) {\n          const inferredStacktrace = [...stacktrace, this._callInstructionToCallFailedToExecuteStackTraceEntry(trace.bytecode, inst)];\n          return this._fixInitialModifier(trace, inferredStacktrace);\n        }\n      }\n    }\n  }\n  /**\n   * Check if the execution stopped with a revert or an invalid opcode.\n   */\n\n\n  _checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction) {\n    var _a;\n\n    if (lastInstruction.opcode !== opcodes_1.Opcode.REVERT && lastInstruction.opcode !== opcodes_1.Opcode.INVALID) {\n      return;\n    }\n\n    const inferredStacktrace = [...stacktrace];\n\n    if (lastInstruction.location !== undefined && (!message_trace_1.isDecodedCallTrace(trace) || jumpedIntoFunction)) {\n      // There should always be a function here, but that's not the case with optimizations.\n      //\n      // If this is a create trace, we already checked args and nonpayable failures before\n      // calling this function.\n      //\n      // If it's a call trace, we already jumped into a function. But optimizations can happen.\n      const failingFunction = lastInstruction.location.getContainingFunction(); // If the failure is in a modifier we add an entry with the function/constructor\n\n      if (failingFunction !== undefined && failingFunction.type === model_1.ContractFunctionType.MODIFIER) {\n        inferredStacktrace.push(this._getEntryBeforeFailureInModifier(trace, functionJumpdests));\n      }\n    }\n\n    const panicStacktrace = this._checkPanic(trace, inferredStacktrace, lastInstruction);\n\n    if (panicStacktrace !== undefined) {\n      return panicStacktrace;\n    }\n\n    const customErrorStacktrace = this._checkCustomErrors(trace, inferredStacktrace, lastInstruction);\n\n    if (customErrorStacktrace !== undefined) {\n      return customErrorStacktrace;\n    }\n\n    if (lastInstruction.location !== undefined && (!message_trace_1.isDecodedCallTrace(trace) || jumpedIntoFunction)) {\n      const failingFunction = lastInstruction.location.getContainingFunction();\n\n      if (failingFunction !== undefined) {\n        inferredStacktrace.push(this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction));\n      } else if (message_trace_1.isDecodedCallTrace(trace)) {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4))),\n          message: new return_data_1.ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n        });\n      } else {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n          message: new return_data_1.ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n        });\n      }\n\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    } // If the revert instruction is not mapped but there is return data,\n    // we add the frame anyway, sith the best sourceReference we can get\n\n\n    if (lastInstruction.location === undefined && trace.returnData.length > 0) {\n      const revertFrame = {\n        type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n        sourceReference: (_a = this._getLastSourceReference(trace)) !== null && _a !== void 0 ? _a : this._getContractStartWithoutFunctionSourceReference(trace),\n        message: new return_data_1.ReturnData(trace.returnData),\n        isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n      };\n      inferredStacktrace.push(revertFrame);\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n  }\n  /**\n   * Check if the trace reverted with a panic error.\n   */\n\n\n  _checkPanic(trace, stacktrace, lastInstruction) {\n    if (!this._isPanicReturnData(trace.returnData)) {\n      return;\n    } // If the last frame is an internal function, it means that the trace\n    // jumped there to return the panic. If that's the case, we remove that\n    // frame.\n\n\n    const lastFrame = stacktrace[stacktrace.length - 1];\n\n    if ((lastFrame === null || lastFrame === void 0 ? void 0 : lastFrame.type) === solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY) {\n      stacktrace.splice(-1);\n    }\n\n    const panicReturnData = new return_data_1.ReturnData(trace.returnData);\n    const errorCode = panicReturnData.decodePanic(); // if the error comes from a call to a zero-initialized function,\n    // we remove the last frame, which represents the call, to avoid\n    // having duplicated frames\n\n    if (errorCode.eqn(0x51)) {\n      stacktrace.splice(-1);\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(this._instructionWithinFunctionToPanicStackTraceEntry(trace, lastInstruction, errorCode));\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n\n  _checkCustomErrors(trace, stacktrace, lastInstruction) {\n    const returnData = new return_data_1.ReturnData(trace.returnData);\n\n    if (returnData.isEmpty() || returnData.isErrorReturnData()) {\n      // if there is no return data, or if it's a Error(string),\n      // then it can't be a custom error\n      return;\n    }\n\n    let errorMessage = \"reverted with an unrecognized custom error\";\n\n    for (const customError of trace.bytecode.contract.customErrors) {\n      if (returnData.matchesSelector(customError.selector)) {\n        // if the return data matches a custom error in the called contract,\n        // we format the message using the returnData and the custom error instance\n        const decodedValues = abi_1.defaultAbiCoder.decode(customError.paramTypes, returnData.value.slice(4));\n        const params = abi_helpers_1.AbiHelpers.formatValues([...decodedValues]);\n        errorMessage = `reverted with custom error '${customError.name}(${params})'`;\n        break;\n      }\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(this._instructionWithinFunctionToCustomErrorStackTraceEntry(trace, lastInstruction, errorMessage));\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n  /**\n   * Check last instruction to try to infer the error.\n   */\n\n\n  _checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!message_trace_1.isEvmStep(lastStep)) {\n      throw new Error(\"This should not happen: MessageTrace ends with a subtrace\");\n    }\n\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n\n    const revertOrInvalidStacktrace = this._checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction);\n\n    if (revertOrInvalidStacktrace !== undefined) {\n      return revertOrInvalidStacktrace;\n    }\n\n    if (message_trace_1.isDecodedCallTrace(trace) && !jumpedIntoFunction) {\n      if (this._hasFailedInsideTheFallbackFunction(trace) || this._hasFailedInsideTheReceiveFunction(trace)) {\n        return [this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction)];\n      } // Sometimes we do fail inside of a function but there's no jump into\n\n\n      if (lastInstruction.location !== undefined) {\n        const failingFunction = lastInstruction.location.getContainingFunction();\n\n        if (failingFunction !== undefined) {\n          return [{\n            type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n            sourceReference: this._getFunctionStartSourceReference(trace, failingFunction),\n            message: new return_data_1.ReturnData(trace.returnData),\n            isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n          }];\n        }\n      }\n\n      const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n      if (calledFunction !== undefined) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, calledFunction)\n        }];\n      }\n\n      if (this._solidity063MaybeUnmappedRevert(trace)) {\n        const revertFrame = this._solidity063GetFrameForUnmappedRevertBeforeFunction(trace);\n\n        if (revertFrame !== undefined) {\n          return [revertFrame];\n        }\n      }\n\n      return [this._getOtherErrorBeforeCalledFunctionStackTraceEntry(trace)];\n    }\n  }\n\n  _checkNonContractCalled(trace, stacktrace) {\n    if (this._isCalledNonContractAccountError(trace)) {\n      const nonContractCalledFrame = {\n        type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n        // We are sure this is not undefined because there was at least a call instruction\n        sourceReference: this._getLastSourceReference(trace)\n      };\n      return [...stacktrace, nonContractCalledFrame];\n    }\n  }\n\n  _checkSolidity063UnmappedRevert(trace, stacktrace) {\n    if (this._solidity063MaybeUnmappedRevert(trace)) {\n      const revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n      if (revertFrame !== undefined) {\n        return [...stacktrace, revertFrame];\n      }\n    }\n  }\n\n  _checkContractTooLarge(trace) {\n    if (message_trace_1.isCreateTrace(trace) && this._isContractTooLargeError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace)\n      }];\n    }\n  }\n\n  _otherExecutionErrorStacktrace(trace, stacktrace) {\n    const otherExecutionErrorFrame = {\n      type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getLastSourceReference(trace)\n    };\n    return [...stacktrace, otherExecutionErrorFrame];\n  } // Helpers\n\n\n  _fixInitialModifier(trace, stacktrace) {\n    const firstEntry = stacktrace[0];\n\n    if (firstEntry !== undefined && firstEntry.type === solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY && firstEntry.functionType === model_1.ContractFunctionType.MODIFIER) {\n      return [this._getEntryBeforeInitialModifierCallstackEntry(trace), ...stacktrace];\n    }\n\n    return stacktrace;\n  }\n\n  _isDirectLibraryCall(trace) {\n    return trace.depth === 0 && trace.bytecode.contract.type === model_1.ContractType.LIBRARY;\n  }\n\n  _getDirectLibraryCallErrorStackTrace(trace) {\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (func !== undefined) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n        sourceReference: this._getFunctionStartSourceReference(trace, func)\n      }];\n    }\n\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n      sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n    }];\n  }\n\n  _isFunctionNotPayableError(trace, calledFunction) {\n    if (calledFunction === undefined) {\n      return false;\n    } // This error doesn't return data\n\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value.lten(0)) {\n      return false;\n    } // Libraries don't have a nonpayable check\n\n\n    if (trace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n      return false;\n    }\n\n    return calledFunction.isPayable === undefined || !calledFunction.isPayable;\n  }\n\n  _getFunctionStartSourceReference(trace, func) {\n    return {\n      file: func.location.file,\n      contract: trace.bytecode.contract.name,\n      function: func.name,\n      line: func.location.getStartingLineNumber(),\n      range: [func.location.offset, func.location.offset + func.location.length]\n    };\n  }\n\n  _isMissingFunctionAndFallbackError(trace, calledFunction) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    } // the called function exists in the contract\n\n\n    if (calledFunction !== undefined) {\n      return false;\n    } // there's a receive function and no calldata\n\n\n    if (trace.calldata.length === 0 && trace.bytecode.contract.receive !== undefined) {\n      return false;\n    }\n\n    return trace.bytecode.contract.fallback === undefined;\n  }\n\n  _emptyCalldataAndNoReceive(trace) {\n    // this only makes sense when receive functions are available\n    if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_RECEIVE_FUNCTION)) {\n      return false;\n    }\n\n    return trace.calldata.length === 0 && trace.bytecode.contract.receive === undefined;\n  }\n\n  _getContractStartWithoutFunctionSourceReference(trace) {\n    const location = trace.bytecode.contract.location;\n    return {\n      file: location.file,\n      contract: trace.bytecode.contract.name,\n      line: location.getStartingLineNumber(),\n      range: [location.offset, location.offset + location.length]\n    };\n  }\n\n  _isFallbackNotPayableError(trace, calledFunction) {\n    if (calledFunction !== undefined) {\n      return false;\n    } // This error doesn't return data\n\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value.lten(0)) {\n      return false;\n    }\n\n    if (trace.bytecode.contract.fallback === undefined) {\n      return false;\n    }\n\n    const isPayable = trace.bytecode.contract.fallback.isPayable;\n    return isPayable === undefined || !isPayable;\n  }\n\n  _getFallbackStartSourceReference(trace) {\n    const func = trace.bytecode.contract.fallback;\n\n    if (func === undefined) {\n      throw new Error(\"This shouldn't happen: trying to get fallback source reference from a contract without fallback\");\n    }\n\n    return {\n      file: func.location.file,\n      contract: trace.bytecode.contract.name,\n      function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n      line: func.location.getStartingLineNumber(),\n      range: [func.location.offset, func.location.offset + func.location.length]\n    };\n  }\n\n  _isConstructorNotPayableError(trace) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const constructor = trace.bytecode.contract.constructorFunction; // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n\n    if (constructor === undefined) {\n      return false;\n    }\n\n    return trace.value.gtn(0) && (constructor.isPayable === undefined || !constructor.isPayable);\n  }\n  /**\n   * Returns a source reference pointing to the constructor if it exists, or to the contract\n   * otherwise.\n   */\n\n\n  _getConstructorStartSourceReference(trace) {\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n    const line = constructor !== undefined ? constructor.location.getStartingLineNumber() : contract.location.getStartingLineNumber();\n    return {\n      file: contract.location.file,\n      contract: contract.name,\n      function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n      line,\n      range: [contract.location.offset, contract.location.offset + contract.location.length]\n    };\n  }\n\n  _isConstructorInvalidArgumentsError(trace) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction; // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n\n    if (constructor === undefined) {\n      return false;\n    }\n\n    if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION)) {\n      return false;\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!message_trace_1.isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.REVERT || lastInst.location !== undefined) {\n      return false;\n    }\n\n    let hasReadDeploymentCodeSize = false; // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n\n      if (!message_trace_1.isEvmStep(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location !== undefined && !contract.location.equals(inst.location) && !constructor.location.equals(inst.location)) {\n        return false;\n      }\n\n      if (inst.opcode === opcodes_1.Opcode.CODESIZE && message_trace_1.isCreateTrace(trace)) {\n        hasReadDeploymentCodeSize = true;\n      }\n    }\n\n    return hasReadDeploymentCodeSize;\n  }\n\n  _getEntryBeforeInitialModifierCallstackEntry(trace) {\n    if (message_trace_1.isDecodedCreateTrace(trace)) {\n      return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        functionType: model_1.ContractFunctionType.CONSTRUCTOR\n      };\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (calledFunction !== undefined) {\n      return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n        functionType: model_1.ContractFunctionType.FUNCTION\n      };\n    } // If it failed or made a call from within a modifier, and the selector doesn't match\n    // any function, it must have a fallback.\n\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getFallbackStartSourceReference(trace),\n      functionType: model_1.ContractFunctionType.FALLBACK\n    };\n  }\n\n  _getLastSourceReference(trace) {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n\n      if (!message_trace_1.isEvmStep(step)) {\n        continue;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location === undefined) {\n        continue;\n      }\n\n      return sourceLocationToSourceReference(trace.bytecode, inst.location);\n    }\n\n    return undefined;\n  }\n\n  _hasFailedInsideTheFallbackFunction(trace) {\n    const contract = trace.bytecode.contract;\n\n    if (contract.fallback === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.fallback);\n  }\n\n  _hasFailedInsideTheReceiveFunction(trace) {\n    const contract = trace.bytecode.contract;\n\n    if (contract.receive === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.receive);\n  }\n\n  _hasFailedInsideFunction(trace, func) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n    return lastInstruction.location !== undefined && lastInstruction.opcode === opcodes_1.Opcode.REVERT && func.location.contains(lastInstruction.location);\n  }\n\n  _instructionWithinFunctionToRevertStackTraceEntry(trace, inst) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n      sourceReference: sourceLocationToSourceReference(trace.bytecode, inst.location),\n      message: new return_data_1.ReturnData(trace.returnData),\n      isInvalidOpcodeError: inst.opcode === opcodes_1.Opcode.INVALID\n    };\n  }\n\n  _instructionWithinFunctionToPanicStackTraceEntry(trace, inst, errorCode) {\n    var _a;\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.PANIC_ERROR,\n      sourceReference: (_a = sourceLocationToSourceReference(trace.bytecode, inst.location)) !== null && _a !== void 0 ? _a : this._getLastSourceReference(trace),\n      errorCode\n    };\n  }\n\n  _instructionWithinFunctionToCustomErrorStackTraceEntry(trace, inst, message) {\n    var _a;\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CUSTOM_ERROR,\n      sourceReference: (_a = sourceLocationToSourceReference(trace.bytecode, inst.location)) !== null && _a !== void 0 ? _a : this._getLastSourceReference(trace),\n      message\n    };\n  }\n\n  _solidity063MaybeUnmappedRevert(trace) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!message_trace_1.isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    return semver_1.default.satisfies(trace.bytecode.compilerVersion, `^${FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS}`) && lastInst.opcode === opcodes_1.Opcode.REVERT;\n  } // Solidity 0.6.3 unmapped reverts special handling\n  // For more info: https://github.com/ethereum/solidity/issues/9006\n\n\n  _solidity063GetFrameForUnmappedRevertBeforeFunction(trace) {\n    let revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n    if (revertFrame === undefined || revertFrame.sourceReference === undefined) {\n      if (trace.bytecode.contract.receive === undefined || trace.calldata.length > 0) {\n        if (trace.bytecode.contract.fallback !== undefined) {\n          // Failed within the fallback\n          const location = trace.bytecode.contract.fallback.location;\n          revertFrame = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n            sourceReference: {\n              contract: trace.bytecode.contract.name,\n              function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n              file: location.file,\n              line: location.getStartingLineNumber(),\n              range: [location.offset, location.offset + location.length]\n            }\n          };\n\n          this._solidity063CorrectLineNumber(revertFrame);\n        }\n      } else {\n        // Failed within the receive function\n        const location = trace.bytecode.contract.receive.location;\n        revertFrame = {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n          sourceReference: {\n            contract: trace.bytecode.contract.name,\n            function: solidity_stack_trace_1.RECEIVE_FUNCTION_NAME,\n            file: location.file,\n            line: location.getStartingLineNumber(),\n            range: [location.offset, location.offset + location.length]\n          }\n        };\n\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n    }\n\n    return revertFrame;\n  }\n\n  _getOtherErrorBeforeCalledFunctionStackTraceEntry(trace) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n    };\n  }\n\n  _isCalledNonContractAccountError(trace) {\n    // We could change this to checking that the last valid location maps to a call, but\n    // it's way more complex as we need to get the ast node from that location.\n    const lastIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n\n    if (lastIndex === undefined || lastIndex === 0) {\n      return false;\n    }\n\n    const lastStep = trace.steps[lastIndex]; // We know this is an EVM step\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.ISZERO) {\n      return false;\n    }\n\n    const prevStep = trace.steps[lastIndex - 1]; // We know this is an EVM step\n\n    const prevInst = trace.bytecode.getInstruction(prevStep.pc);\n    return prevInst.opcode === opcodes_1.Opcode.EXTCODESIZE;\n  }\n\n  _solidity063GetFrameForUnmappedRevertWithinFunction(trace) {\n    // If we are within a function there's a last valid location. It may\n    // be the entire contract.\n    const prevInst = this._getLastInstructionWithValidLocation(trace);\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const nextInstPc = lastStep.pc + 1;\n    const hasNextInst = trace.bytecode.hasInstruction(nextInstPc);\n\n    if (hasNextInst) {\n      const nextInst = trace.bytecode.getInstruction(nextInstPc);\n      const prevLoc = prevInst.location;\n      const nextLoc = nextInst.location;\n      const prevFunc = prevLoc.getContainingFunction();\n      const nextFunc = nextLoc === null || nextLoc === void 0 ? void 0 : nextLoc.getContainingFunction(); // This is probably a require. This means that we have the exact\n      // line, but the stack trace may be degraded (e.g. missing our\n      // synthetic call frames when failing in a modifier) so we still\n      // add this frame as UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n\n      if (prevFunc !== undefined && nextLoc !== undefined && prevLoc.equals(nextLoc)) {\n        return Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, nextInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      }\n\n      let revertFrame; // If the previous and next location don't match, we try to use the\n      // previous one if it's inside a function, otherwise we use the next one\n\n      if (prevFunc !== undefined) {\n        revertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      } else if (nextFunc !== undefined) {\n        revertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, nextInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      }\n\n      if (revertFrame !== undefined) {\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n\n      return revertFrame;\n    }\n\n    if (message_trace_1.isCreateTrace(trace)) {\n      // Solidity is smart enough to stop emitting extra instructions after\n      // an unconditional revert happens in a constructor. If this is the case\n      // we just return a special error.\n      const constructorRevertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n        type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n      }); // When the latest instruction is not within a function we need\n      // some default sourceReference to show to the user\n\n      if (constructorRevertFrame.sourceReference === undefined) {\n        const location = trace.bytecode.contract.location;\n        const defaultSourceReference = {\n          function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n          contract: trace.bytecode.contract.name,\n          file: location.file,\n          line: location.getStartingLineNumber(),\n          range: [location.offset, location.offset + location.length]\n        };\n\n        if (trace.bytecode.contract.constructorFunction !== undefined) {\n          defaultSourceReference.line = trace.bytecode.contract.constructorFunction.location.getStartingLineNumber();\n        }\n\n        constructorRevertFrame.sourceReference = defaultSourceReference;\n      } else {\n        this._solidity063CorrectLineNumber(constructorRevertFrame);\n      }\n\n      return constructorRevertFrame;\n    } // We may as well just be in a function or modifier and just happen\n    // to be at the last instruction of the runtime bytecode.\n    // In this case we just return whatever the last mapped intruction\n    // points to.\n\n\n    const latestInstructionRevertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n      type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n    });\n\n    if (latestInstructionRevertFrame.sourceReference !== undefined) {\n      this._solidity063CorrectLineNumber(latestInstructionRevertFrame);\n    }\n\n    return latestInstructionRevertFrame;\n  }\n\n  _isContractTooLargeError(trace) {\n    if (trace.error === undefined || trace.error.error !== exceptions_1.ERROR.OUT_OF_GAS) {\n      return false;\n    } // This error doesn't come from solidity, but actually from the VM.\n    // The deployment code executes correctly, but it OOGs.\n\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!message_trace_1.isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.RETURN) {\n      return false;\n    } // TODO: This is an over approximation, as we should be comparing the\n    //  runtime bytecode.\n\n\n    if (trace.bytecode.normalizedCode.length <= EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT) {\n      return false;\n    } // TODO: What happens if it's an actual out of gas that OOGs at the return?\n    //   maybe traces should have gasLimit and gasUsed.\n\n\n    return true;\n  }\n\n  _solidity063CorrectLineNumber(revertFrame) {\n    const file = revertFrame.sourceReference.file;\n    const lines = file.content.split(\"\\n\");\n    const currentLine = lines[revertFrame.sourceReference.line - 1];\n\n    if (currentLine.includes(\"require\") || currentLine.includes(\"revert\")) {\n      return;\n    }\n\n    const nextLines = lines.slice(revertFrame.sourceReference.line);\n    const firstNonEmptyLine = nextLines.findIndex(l => l.trim() !== \"\");\n\n    if (firstNonEmptyLine === -1) {\n      return;\n    }\n\n    const nextLine = nextLines[firstNonEmptyLine];\n\n    if (nextLine.includes(\"require\") || nextLine.includes(\"revert\")) {\n      revertFrame.sourceReference.line += 1 + firstNonEmptyLine;\n    }\n  }\n\n  _getLastInstructionWithValidLocationStepIndex(trace) {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n\n      if (!message_trace_1.isEvmStep(step)) {\n        return undefined;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n\n  _getLastInstructionWithValidLocation(trace) {\n    const lastLocationIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n\n    if (lastLocationIndex === undefined) {\n      return undefined;\n    }\n\n    const lastLocationStep = trace.steps[lastLocationIndex];\n\n    if (message_trace_1.isEvmStep(lastLocationStep)) {\n      const lastInstructionWithLocation = trace.bytecode.getInstruction(lastLocationStep.pc);\n      return lastInstructionWithLocation;\n    }\n\n    return undefined;\n  }\n\n  _callInstructionToCallFailedToExecuteStackTraceEntry(bytecode, callInst) {\n    // Calls only happen within functions\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALL_FAILED_ERROR,\n      sourceReference: sourceLocationToSourceReference(bytecode, callInst.location)\n    };\n  }\n\n  _getEntryBeforeFailureInModifier(trace, functionJumpdests) {\n    // If there's a jumpdest, this modifier belongs to the last function that it represents\n    if (functionJumpdests.length > 0) {\n      return instructionToCallstackStackTraceEntry(trace.bytecode, functionJumpdests[functionJumpdests.length - 1]);\n    } // This function is only called after we jumped into the initial function in call traces, so\n    // there should always be at least a function jumpdest.\n\n\n    if (!message_trace_1.isDecodedCreateTrace(trace)) {\n      throw new Error(\"This shouldn't happen: a call trace has no functionJumpdest but has already jumped into a function\");\n    } // If there's no jump dest, we point to the constructor.\n\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getConstructorStartSourceReference(trace),\n      functionType: model_1.ContractFunctionType.CONSTRUCTOR\n    };\n  }\n\n  _failsRightAfterCall(trace, callSubtraceStepIndex) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!message_trace_1.isEvmStep(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.REVERT) {\n      return false;\n    }\n\n    const callOpcodeStep = trace.steps[callSubtraceStepIndex - 1];\n    const callInst = trace.bytecode.getInstruction(callOpcodeStep.pc);\n    return this._isLastLocation(trace, callSubtraceStepIndex + 1, callInst.location // Calls are always made from within functions\n    );\n  }\n\n  _isCallFailedError(trace, instIndex, callInstruction) {\n    const callLocation = callInstruction.location; // Calls are always made from within functions\n\n    return this._isLastLocation(trace, instIndex, callLocation);\n  }\n\n  _isLastLocation(trace, fromStep, location) {\n    for (let i = fromStep; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n\n      if (!message_trace_1.isEvmStep(step)) {\n        return false;\n      }\n\n      const stepInst = trace.bytecode.getInstruction(step.pc);\n\n      if (stepInst.location === undefined) {\n        continue;\n      }\n\n      if (!location.equals(stepInst.location)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _isSubtraceErrorPropagated(trace, callSubtraceStepIndex) {\n    var _a, _b;\n\n    const call = trace.steps[callSubtraceStepIndex];\n\n    if (!trace.returnData.equals(call.returnData)) {\n      return false;\n    }\n\n    if (((_a = trace.error) === null || _a === void 0 ? void 0 : _a.error) === exceptions_1.ERROR.OUT_OF_GAS && ((_b = call.error) === null || _b === void 0 ? void 0 : _b.error) === exceptions_1.ERROR.OUT_OF_GAS) {\n      return true;\n    }\n\n    return this._failsRightAfterCall(trace, callSubtraceStepIndex);\n  }\n\n  _isProxyErrorPropagated(trace, callSubtraceStepIndex) {\n    if (!message_trace_1.isDecodedCallTrace(trace)) {\n      return false;\n    }\n\n    const callStep = trace.steps[callSubtraceStepIndex - 1];\n\n    if (!message_trace_1.isEvmStep(callStep)) {\n      return false;\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n\n    if (callInst.opcode !== opcodes_1.Opcode.DELEGATECALL) {\n      return false;\n    }\n\n    const subtrace = trace.steps[callSubtraceStepIndex];\n\n    if (message_trace_1.isEvmStep(subtrace)) {\n      return false;\n    }\n\n    if (message_trace_1.isPrecompileTrace(subtrace)) {\n      return false;\n    } // If we can't recognize the implementation we'd better don't consider it as such\n\n\n    if (subtrace.bytecode === undefined) {\n      return false;\n    }\n\n    if (subtrace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n      return false;\n    }\n\n    if (!trace.returnData.equals(subtrace.returnData)) {\n      return false;\n    }\n\n    for (let i = callSubtraceStepIndex + 1; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n\n      if (!message_trace_1.isEvmStep(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc); // All the remaining locations should be valid, as they are part of the inline asm\n\n      if (inst.location === undefined) {\n        return false;\n      }\n\n      if (inst.jumpType === model_1.JumpType.INTO_FUNCTION || inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n        return false;\n      }\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    return lastInst.opcode === opcodes_1.Opcode.REVERT;\n  }\n\n  _isContractCallRunOutOfGasError(trace, callStepIndex) {\n    var _a, _b;\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (((_a = trace.error) === null || _a === void 0 ? void 0 : _a.error) !== exceptions_1.ERROR.REVERT) {\n      return false;\n    }\n\n    const call = trace.steps[callStepIndex];\n\n    if (((_b = call.error) === null || _b === void 0 ? void 0 : _b.error) !== exceptions_1.ERROR.OUT_OF_GAS) {\n      return false;\n    }\n\n    return this._failsRightAfterCall(trace, callStepIndex);\n  }\n\n  _isPanicReturnData(returnData) {\n    return new return_data_1.ReturnData(returnData).isPanicReturnData();\n  }\n\n}\n\nexports.ErrorInferrer = ErrorInferrer;\n\nfunction instructionToCallstackStackTraceEntry(bytecode, inst) {\n  // This means that a jump is made from within an internal solc function.\n  // These are normally made from yul code, so they don't map to any Solidity\n  // function\n  if (inst.location === undefined) {\n    const location = bytecode.contract.location;\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY,\n      pc: inst.pc,\n      sourceReference: {\n        file: bytecode.contract.location.file,\n        contract: bytecode.contract.name,\n        function: undefined,\n        line: bytecode.contract.location.getStartingLineNumber(),\n        range: [location.offset, location.offset + location.length]\n      }\n    };\n  }\n\n  const func = inst.location.getContainingFunction();\n\n  if (func !== undefined) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: sourceLocationToSourceReference(bytecode, inst.location),\n      functionType: func.type\n    };\n  }\n\n  return {\n    type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n    sourceReference: {\n      function: undefined,\n      contract: bytecode.contract.name,\n      file: inst.location.file,\n      line: inst.location.getStartingLineNumber(),\n      range: [inst.location.offset, inst.location.offset + inst.location.length]\n    },\n    functionType: model_1.ContractFunctionType.FUNCTION\n  };\n}\n\nexports.instructionToCallstackStackTraceEntry = instructionToCallstackStackTraceEntry;\n\nfunction sourceLocationToSourceReference(bytecode, location) {\n  if (location === undefined) {\n    return undefined;\n  }\n\n  const func = location.getContainingFunction();\n\n  if (func === undefined) {\n    return undefined;\n  }\n\n  let funcName = func.name;\n\n  if (func.type === model_1.ContractFunctionType.CONSTRUCTOR) {\n    funcName = solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME;\n  } else if (func.type === model_1.ContractFunctionType.FALLBACK) {\n    funcName = solidity_stack_trace_1.FALLBACK_FUNCTION_NAME;\n  } else if (func.type === model_1.ContractFunctionType.RECEIVE) {\n    funcName = solidity_stack_trace_1.RECEIVE_FUNCTION_NAME;\n  }\n\n  return {\n    function: funcName,\n    contract: func.type === model_1.ContractFunctionType.FREE_FUNCTION ? undefined : bytecode.contract.name,\n    file: func.location.file,\n    line: location.getStartingLineNumber(),\n    range: [location.offset, location.offset + location.length]\n  };\n}","map":{"version":3,"sources":["../../../src/internal/hardhat-network/stack-traces/error-inferrer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.instructionToCallstackStackTraceEntry = exports.ErrorInferrer = void 0;\nconst exceptions_1 = require(\"@ethereumjs/vm/dist/exceptions\");\nconst abi_1 = require(\"@ethersproject/abi\");\nconst semver_1 = __importDefault(require(\"semver\"));\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\nconst return_data_1 = require(\"../provider/return-data\");\nconst message_trace_1 = require(\"./message-trace\");\nconst model_1 = require(\"./model\");\nconst opcodes_1 = require(\"./opcodes\");\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\nconst FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION = \"0.5.9\";\nconst FIRST_SOLC_VERSION_RECEIVE_FUNCTION = \"0.6.0\";\nconst FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS = \"0.6.3\";\nconst EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT = 0x6000;\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\nclass ErrorInferrer {\n    inferBeforeTracingCallMessage(trace) {\n        if (this._isDirectLibraryCall(trace)) {\n            return this._getDirectLibraryCallErrorStackTrace(trace);\n        }\n        const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n        if (this._isFunctionNotPayableError(trace, calledFunction)) {\n            return [\n                {\n                    type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n                    sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n                    value: trace.value,\n                },\n            ];\n        }\n        if (this._isMissingFunctionAndFallbackError(trace, calledFunction)) {\n            if (this._emptyCalldataAndNoReceive(trace)) {\n                return [\n                    {\n                        type: solidity_stack_trace_1.StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR,\n                        sourceReference: this._getContractStartWithoutFunctionSourceReference(trace),\n                    },\n                ];\n            }\n            return [\n                {\n                    type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR,\n                    sourceReference: this._getContractStartWithoutFunctionSourceReference(trace),\n                },\n            ];\n        }\n        if (this._isFallbackNotPayableError(trace, calledFunction)) {\n            if (this._emptyCalldataAndNoReceive(trace)) {\n                return [\n                    {\n                        type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR,\n                        sourceReference: this._getFallbackStartSourceReference(trace),\n                        value: trace.value,\n                    },\n                ];\n            }\n            return [\n                {\n                    type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR,\n                    sourceReference: this._getFallbackStartSourceReference(trace),\n                    value: trace.value,\n                },\n            ];\n        }\n    }\n    inferBeforeTracingCreateMessage(trace) {\n        if (this._isConstructorNotPayableError(trace)) {\n            return [\n                {\n                    type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n                    sourceReference: this._getConstructorStartSourceReference(trace),\n                    value: trace.value,\n                },\n            ];\n        }\n        if (this._isConstructorInvalidArgumentsError(trace)) {\n            return [\n                {\n                    type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n                    sourceReference: this._getConstructorStartSourceReference(trace),\n                },\n            ];\n        }\n    }\n    inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData) {\n        var _a, _b, _c, _d, _e, _f;\n        return ((_f = (_e = (_d = (_c = (_b = (_a = this._checkLastSubmessage(trace, stacktrace, lastSubmessageData)) !== null && _a !== void 0 ? _a : this._checkFailedLastCall(trace, stacktrace)) !== null && _b !== void 0 ? _b : this._checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction)) !== null && _c !== void 0 ? _c : this._checkNonContractCalled(trace, stacktrace)) !== null && _d !== void 0 ? _d : this._checkSolidity063UnmappedRevert(trace, stacktrace)) !== null && _e !== void 0 ? _e : this._checkContractTooLarge(trace)) !== null && _f !== void 0 ? _f : this._otherExecutionErrorStacktrace(trace, stacktrace));\n    }\n    filterRedundantFrames(stacktrace) {\n        return stacktrace.filter((frame, i) => {\n            if (i + 1 === stacktrace.length) {\n                return true;\n            }\n            const nextFrame = stacktrace[i + 1];\n            // we can only filter frames if we know their sourceReference\n            // and the one from the next frame\n            if (frame.sourceReference === undefined ||\n                nextFrame.sourceReference === undefined) {\n                return true;\n            }\n            // constructors contain the whole contract, so we ignore them\n            if (frame.sourceReference.function === \"constructor\" &&\n                nextFrame.sourceReference.function !== \"constructor\") {\n                return true;\n            }\n            // this is probably a recursive call\n            if (i > 0 &&\n                frame.type === nextFrame.type &&\n                frame.sourceReference.range[0] === nextFrame.sourceReference.range[0] &&\n                frame.sourceReference.range[1] === nextFrame.sourceReference.range[1] &&\n                frame.sourceReference.line === nextFrame.sourceReference.line) {\n                return true;\n            }\n            if (frame.sourceReference.range[0] <= nextFrame.sourceReference.range[0] &&\n                frame.sourceReference.range[1] >= nextFrame.sourceReference.range[1]) {\n                return false;\n            }\n            return true;\n        });\n    }\n    // Heuristics\n    /**\n     * Check if the last submessage can be used to generate the stack trace.\n     */\n    _checkLastSubmessage(trace, stacktrace, lastSubmessageData) {\n        if (lastSubmessageData === undefined) {\n            return undefined;\n        }\n        const inferredStacktrace = [...stacktrace];\n        // get the instruction before the submessage and add it to the stack trace\n        const callStep = trace.steps[lastSubmessageData.stepIndex - 1];\n        if (!message_trace_1.isEvmStep(callStep)) {\n            throw new Error(\"This should not happen: MessageTrace should be preceded by a EVM step\");\n        }\n        const callInst = trace.bytecode.getInstruction(callStep.pc);\n        const callStackFrame = instructionToCallstackStackTraceEntry(trace.bytecode, callInst);\n        const lastMessageFailed = lastSubmessageData.messageTrace.error !== undefined;\n        if (lastMessageFailed) {\n            // add the call/create that generated the message to the stack trace\n            inferredStacktrace.push(callStackFrame);\n            if (this._isSubtraceErrorPropagated(trace, lastSubmessageData.stepIndex) ||\n                this._isProxyErrorPropagated(trace, lastSubmessageData.stepIndex)) {\n                inferredStacktrace.push(...lastSubmessageData.stacktrace);\n                if (this._isContractCallRunOutOfGasError(trace, lastSubmessageData.stepIndex)) {\n                    const lastFrame = inferredStacktrace.pop();\n                    inferredStacktrace.push({\n                        type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR,\n                        sourceReference: lastFrame.sourceReference,\n                    });\n                }\n                return this._fixInitialModifier(trace, inferredStacktrace);\n            }\n        }\n        else {\n            const isReturnDataSizeError = this._failsRightAfterCall(trace, lastSubmessageData.stepIndex);\n            if (isReturnDataSizeError) {\n                inferredStacktrace.push({\n                    type: solidity_stack_trace_1.StackTraceEntryType.RETURNDATA_SIZE_ERROR,\n                    sourceReference: callStackFrame.sourceReference,\n                });\n                return this._fixInitialModifier(trace, inferredStacktrace);\n            }\n        }\n    }\n    /**\n     * Check if the last call/create that was done failed.\n     */\n    _checkFailedLastCall(trace, stacktrace) {\n        for (let stepIndex = trace.steps.length - 2; stepIndex >= 0; stepIndex--) {\n            const step = trace.steps[stepIndex];\n            const nextStep = trace.steps[stepIndex + 1];\n            if (!message_trace_1.isEvmStep(step)) {\n                return;\n            }\n            const inst = trace.bytecode.getInstruction(step.pc);\n            const isCallOrCreate = opcodes_1.isCall(inst.opcode) || opcodes_1.isCreate(inst.opcode);\n            if (isCallOrCreate && message_trace_1.isEvmStep(nextStep)) {\n                if (this._isCallFailedError(trace, stepIndex, inst)) {\n                    const inferredStacktrace = [\n                        ...stacktrace,\n                        this._callInstructionToCallFailedToExecuteStackTraceEntry(trace.bytecode, inst),\n                    ];\n                    return this._fixInitialModifier(trace, inferredStacktrace);\n                }\n            }\n        }\n    }\n    /**\n     * Check if the execution stopped with a revert or an invalid opcode.\n     */\n    _checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction) {\n        var _a;\n        if (lastInstruction.opcode !== opcodes_1.Opcode.REVERT &&\n            lastInstruction.opcode !== opcodes_1.Opcode.INVALID) {\n            return;\n        }\n        const inferredStacktrace = [...stacktrace];\n        if (lastInstruction.location !== undefined &&\n            (!message_trace_1.isDecodedCallTrace(trace) || jumpedIntoFunction)) {\n            // There should always be a function here, but that's not the case with optimizations.\n            //\n            // If this is a create trace, we already checked args and nonpayable failures before\n            // calling this function.\n            //\n            // If it's a call trace, we already jumped into a function. But optimizations can happen.\n            const failingFunction = lastInstruction.location.getContainingFunction();\n            // If the failure is in a modifier we add an entry with the function/constructor\n            if (failingFunction !== undefined &&\n                failingFunction.type === model_1.ContractFunctionType.MODIFIER) {\n                inferredStacktrace.push(this._getEntryBeforeFailureInModifier(trace, functionJumpdests));\n            }\n        }\n        const panicStacktrace = this._checkPanic(trace, inferredStacktrace, lastInstruction);\n        if (panicStacktrace !== undefined) {\n            return panicStacktrace;\n        }\n        const customErrorStacktrace = this._checkCustomErrors(trace, inferredStacktrace, lastInstruction);\n        if (customErrorStacktrace !== undefined) {\n            return customErrorStacktrace;\n        }\n        if (lastInstruction.location !== undefined &&\n            (!message_trace_1.isDecodedCallTrace(trace) || jumpedIntoFunction)) {\n            const failingFunction = lastInstruction.location.getContainingFunction();\n            if (failingFunction !== undefined) {\n                inferredStacktrace.push(this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction));\n            }\n            else if (message_trace_1.isDecodedCallTrace(trace)) {\n                // This is here because of the optimizations\n                inferredStacktrace.push({\n                    type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n                    sourceReference: this._getFunctionStartSourceReference(trace, trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4))),\n                    message: new return_data_1.ReturnData(trace.returnData),\n                    isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID,\n                });\n            }\n            else {\n                // This is here because of the optimizations\n                inferredStacktrace.push({\n                    type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n                    sourceReference: this._getConstructorStartSourceReference(trace),\n                    message: new return_data_1.ReturnData(trace.returnData),\n                    isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID,\n                });\n            }\n            return this._fixInitialModifier(trace, inferredStacktrace);\n        }\n        // If the revert instruction is not mapped but there is return data,\n        // we add the frame anyway, sith the best sourceReference we can get\n        if (lastInstruction.location === undefined && trace.returnData.length > 0) {\n            const revertFrame = {\n                type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n                sourceReference: (_a = this._getLastSourceReference(trace)) !== null && _a !== void 0 ? _a : this._getContractStartWithoutFunctionSourceReference(trace),\n                message: new return_data_1.ReturnData(trace.returnData),\n                isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID,\n            };\n            inferredStacktrace.push(revertFrame);\n            return this._fixInitialModifier(trace, inferredStacktrace);\n        }\n    }\n    /**\n     * Check if the trace reverted with a panic error.\n     */\n    _checkPanic(trace, stacktrace, lastInstruction) {\n        if (!this._isPanicReturnData(trace.returnData)) {\n            return;\n        }\n        // If the last frame is an internal function, it means that the trace\n        // jumped there to return the panic. If that's the case, we remove that\n        // frame.\n        const lastFrame = stacktrace[stacktrace.length - 1];\n        if ((lastFrame === null || lastFrame === void 0 ? void 0 : lastFrame.type) === solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY) {\n            stacktrace.splice(-1);\n        }\n        const panicReturnData = new return_data_1.ReturnData(trace.returnData);\n        const errorCode = panicReturnData.decodePanic();\n        // if the error comes from a call to a zero-initialized function,\n        // we remove the last frame, which represents the call, to avoid\n        // having duplicated frames\n        if (errorCode.eqn(0x51)) {\n            stacktrace.splice(-1);\n        }\n        const inferredStacktrace = [...stacktrace];\n        inferredStacktrace.push(this._instructionWithinFunctionToPanicStackTraceEntry(trace, lastInstruction, errorCode));\n        return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n    _checkCustomErrors(trace, stacktrace, lastInstruction) {\n        const returnData = new return_data_1.ReturnData(trace.returnData);\n        if (returnData.isEmpty() || returnData.isErrorReturnData()) {\n            // if there is no return data, or if it's a Error(string),\n            // then it can't be a custom error\n            return;\n        }\n        let errorMessage = \"reverted with an unrecognized custom error\";\n        for (const customError of trace.bytecode.contract.customErrors) {\n            if (returnData.matchesSelector(customError.selector)) {\n                // if the return data matches a custom error in the called contract,\n                // we format the message using the returnData and the custom error instance\n                const decodedValues = abi_1.defaultAbiCoder.decode(customError.paramTypes, returnData.value.slice(4));\n                const params = abi_helpers_1.AbiHelpers.formatValues([...decodedValues]);\n                errorMessage = `reverted with custom error '${customError.name}(${params})'`;\n                break;\n            }\n        }\n        const inferredStacktrace = [...stacktrace];\n        inferredStacktrace.push(this._instructionWithinFunctionToCustomErrorStackTraceEntry(trace, lastInstruction, errorMessage));\n        return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n    /**\n     * Check last instruction to try to infer the error.\n     */\n    _checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction) {\n        const lastStep = trace.steps[trace.steps.length - 1];\n        if (!message_trace_1.isEvmStep(lastStep)) {\n            throw new Error(\"This should not happen: MessageTrace ends with a subtrace\");\n        }\n        const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n        const revertOrInvalidStacktrace = this._checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction);\n        if (revertOrInvalidStacktrace !== undefined) {\n            return revertOrInvalidStacktrace;\n        }\n        if (message_trace_1.isDecodedCallTrace(trace) && !jumpedIntoFunction) {\n            if (this._hasFailedInsideTheFallbackFunction(trace) ||\n                this._hasFailedInsideTheReceiveFunction(trace)) {\n                return [\n                    this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction),\n                ];\n            }\n            // Sometimes we do fail inside of a function but there's no jump into\n            if (lastInstruction.location !== undefined) {\n                const failingFunction = lastInstruction.location.getContainingFunction();\n                if (failingFunction !== undefined) {\n                    return [\n                        {\n                            type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n                            sourceReference: this._getFunctionStartSourceReference(trace, failingFunction),\n                            message: new return_data_1.ReturnData(trace.returnData),\n                            isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID,\n                        },\n                    ];\n                }\n            }\n            const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n            if (calledFunction !== undefined) {\n                return [\n                    {\n                        type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n                        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n                    },\n                ];\n            }\n            if (this._solidity063MaybeUnmappedRevert(trace)) {\n                const revertFrame = this._solidity063GetFrameForUnmappedRevertBeforeFunction(trace);\n                if (revertFrame !== undefined) {\n                    return [revertFrame];\n                }\n            }\n            return [this._getOtherErrorBeforeCalledFunctionStackTraceEntry(trace)];\n        }\n    }\n    _checkNonContractCalled(trace, stacktrace) {\n        if (this._isCalledNonContractAccountError(trace)) {\n            const nonContractCalledFrame = {\n                type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n                // We are sure this is not undefined because there was at least a call instruction\n                sourceReference: this._getLastSourceReference(trace),\n            };\n            return [...stacktrace, nonContractCalledFrame];\n        }\n    }\n    _checkSolidity063UnmappedRevert(trace, stacktrace) {\n        if (this._solidity063MaybeUnmappedRevert(trace)) {\n            const revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n            if (revertFrame !== undefined) {\n                return [...stacktrace, revertFrame];\n            }\n        }\n    }\n    _checkContractTooLarge(trace) {\n        if (message_trace_1.isCreateTrace(trace) && this._isContractTooLargeError(trace)) {\n            return [\n                {\n                    type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR,\n                    sourceReference: this._getConstructorStartSourceReference(trace),\n                },\n            ];\n        }\n    }\n    _otherExecutionErrorStacktrace(trace, stacktrace) {\n        const otherExecutionErrorFrame = {\n            type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n            sourceReference: this._getLastSourceReference(trace),\n        };\n        return [...stacktrace, otherExecutionErrorFrame];\n    }\n    // Helpers\n    _fixInitialModifier(trace, stacktrace) {\n        const firstEntry = stacktrace[0];\n        if (firstEntry !== undefined &&\n            firstEntry.type === solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY &&\n            firstEntry.functionType === model_1.ContractFunctionType.MODIFIER) {\n            return [\n                this._getEntryBeforeInitialModifierCallstackEntry(trace),\n                ...stacktrace,\n            ];\n        }\n        return stacktrace;\n    }\n    _isDirectLibraryCall(trace) {\n        return (trace.depth === 0 && trace.bytecode.contract.type === model_1.ContractType.LIBRARY);\n    }\n    _getDirectLibraryCallErrorStackTrace(trace) {\n        const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n        if (func !== undefined) {\n            return [\n                {\n                    type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n                    sourceReference: this._getFunctionStartSourceReference(trace, func),\n                },\n            ];\n        }\n        return [\n            {\n                type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n                sourceReference: this._getContractStartWithoutFunctionSourceReference(trace),\n            },\n        ];\n    }\n    _isFunctionNotPayableError(trace, calledFunction) {\n        if (calledFunction === undefined) {\n            return false;\n        }\n        // This error doesn't return data\n        if (trace.returnData.length > 0) {\n            return false;\n        }\n        if (trace.value.lten(0)) {\n            return false;\n        }\n        // Libraries don't have a nonpayable check\n        if (trace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n            return false;\n        }\n        return calledFunction.isPayable === undefined || !calledFunction.isPayable;\n    }\n    _getFunctionStartSourceReference(trace, func) {\n        return {\n            file: func.location.file,\n            contract: trace.bytecode.contract.name,\n            function: func.name,\n            line: func.location.getStartingLineNumber(),\n            range: [\n                func.location.offset,\n                func.location.offset + func.location.length,\n            ],\n        };\n    }\n    _isMissingFunctionAndFallbackError(trace, calledFunction) {\n        // This error doesn't return data\n        if (trace.returnData.length > 0) {\n            return false;\n        }\n        // the called function exists in the contract\n        if (calledFunction !== undefined) {\n            return false;\n        }\n        // there's a receive function and no calldata\n        if (trace.calldata.length === 0 &&\n            trace.bytecode.contract.receive !== undefined) {\n            return false;\n        }\n        return trace.bytecode.contract.fallback === undefined;\n    }\n    _emptyCalldataAndNoReceive(trace) {\n        // this only makes sense when receive functions are available\n        if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_RECEIVE_FUNCTION)) {\n            return false;\n        }\n        return (trace.calldata.length === 0 &&\n            trace.bytecode.contract.receive === undefined);\n    }\n    _getContractStartWithoutFunctionSourceReference(trace) {\n        const location = trace.bytecode.contract.location;\n        return {\n            file: location.file,\n            contract: trace.bytecode.contract.name,\n            line: location.getStartingLineNumber(),\n            range: [location.offset, location.offset + location.length],\n        };\n    }\n    _isFallbackNotPayableError(trace, calledFunction) {\n        if (calledFunction !== undefined) {\n            return false;\n        }\n        // This error doesn't return data\n        if (trace.returnData.length > 0) {\n            return false;\n        }\n        if (trace.value.lten(0)) {\n            return false;\n        }\n        if (trace.bytecode.contract.fallback === undefined) {\n            return false;\n        }\n        const isPayable = trace.bytecode.contract.fallback.isPayable;\n        return isPayable === undefined || !isPayable;\n    }\n    _getFallbackStartSourceReference(trace) {\n        const func = trace.bytecode.contract.fallback;\n        if (func === undefined) {\n            throw new Error(\"This shouldn't happen: trying to get fallback source reference from a contract without fallback\");\n        }\n        return {\n            file: func.location.file,\n            contract: trace.bytecode.contract.name,\n            function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n            line: func.location.getStartingLineNumber(),\n            range: [\n                func.location.offset,\n                func.location.offset + func.location.length,\n            ],\n        };\n    }\n    _isConstructorNotPayableError(trace) {\n        // This error doesn't return data\n        if (trace.returnData.length > 0) {\n            return false;\n        }\n        const constructor = trace.bytecode.contract.constructorFunction;\n        // This function is only matters with contracts that have constructors defined. The ones that\n        // don't are abstract contracts, or their constructor doesn't take any argument.\n        if (constructor === undefined) {\n            return false;\n        }\n        return (trace.value.gtn(0) &&\n            (constructor.isPayable === undefined || !constructor.isPayable));\n    }\n    /**\n     * Returns a source reference pointing to the constructor if it exists, or to the contract\n     * otherwise.\n     */\n    _getConstructorStartSourceReference(trace) {\n        const contract = trace.bytecode.contract;\n        const constructor = contract.constructorFunction;\n        const line = constructor !== undefined\n            ? constructor.location.getStartingLineNumber()\n            : contract.location.getStartingLineNumber();\n        return {\n            file: contract.location.file,\n            contract: contract.name,\n            function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n            line,\n            range: [\n                contract.location.offset,\n                contract.location.offset + contract.location.length,\n            ],\n        };\n    }\n    _isConstructorInvalidArgumentsError(trace) {\n        // This error doesn't return data\n        if (trace.returnData.length > 0) {\n            return false;\n        }\n        const contract = trace.bytecode.contract;\n        const constructor = contract.constructorFunction;\n        // This function is only matters with contracts that have constructors defined. The ones that\n        // don't are abstract contracts, or their constructor doesn't take any argument.\n        if (constructor === undefined) {\n            return false;\n        }\n        if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION)) {\n            return false;\n        }\n        const lastStep = trace.steps[trace.steps.length - 1];\n        if (!message_trace_1.isEvmStep(lastStep)) {\n            return false;\n        }\n        const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n        if (lastInst.opcode !== opcodes_1.Opcode.REVERT || lastInst.location !== undefined) {\n            return false;\n        }\n        let hasReadDeploymentCodeSize = false;\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n            const step = trace.steps[stepIndex];\n            if (!message_trace_1.isEvmStep(step)) {\n                return false;\n            }\n            const inst = trace.bytecode.getInstruction(step.pc);\n            if (inst.location !== undefined &&\n                !contract.location.equals(inst.location) &&\n                !constructor.location.equals(inst.location)) {\n                return false;\n            }\n            if (inst.opcode === opcodes_1.Opcode.CODESIZE && message_trace_1.isCreateTrace(trace)) {\n                hasReadDeploymentCodeSize = true;\n            }\n        }\n        return hasReadDeploymentCodeSize;\n    }\n    _getEntryBeforeInitialModifierCallstackEntry(trace) {\n        if (message_trace_1.isDecodedCreateTrace(trace)) {\n            return {\n                type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n                sourceReference: this._getConstructorStartSourceReference(trace),\n                functionType: model_1.ContractFunctionType.CONSTRUCTOR,\n            };\n        }\n        const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n        if (calledFunction !== undefined) {\n            return {\n                type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n                sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n                functionType: model_1.ContractFunctionType.FUNCTION,\n            };\n        }\n        // If it failed or made a call from within a modifier, and the selector doesn't match\n        // any function, it must have a fallback.\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n            sourceReference: this._getFallbackStartSourceReference(trace),\n            functionType: model_1.ContractFunctionType.FALLBACK,\n        };\n    }\n    _getLastSourceReference(trace) {\n        for (let i = trace.steps.length - 1; i >= 0; i--) {\n            const step = trace.steps[i];\n            if (!message_trace_1.isEvmStep(step)) {\n                continue;\n            }\n            const inst = trace.bytecode.getInstruction(step.pc);\n            if (inst.location === undefined) {\n                continue;\n            }\n            return sourceLocationToSourceReference(trace.bytecode, inst.location);\n        }\n        return undefined;\n    }\n    _hasFailedInsideTheFallbackFunction(trace) {\n        const contract = trace.bytecode.contract;\n        if (contract.fallback === undefined) {\n            return false;\n        }\n        return this._hasFailedInsideFunction(trace, contract.fallback);\n    }\n    _hasFailedInsideTheReceiveFunction(trace) {\n        const contract = trace.bytecode.contract;\n        if (contract.receive === undefined) {\n            return false;\n        }\n        return this._hasFailedInsideFunction(trace, contract.receive);\n    }\n    _hasFailedInsideFunction(trace, func) {\n        const lastStep = trace.steps[trace.steps.length - 1];\n        const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n        return (lastInstruction.location !== undefined &&\n            lastInstruction.opcode === opcodes_1.Opcode.REVERT &&\n            func.location.contains(lastInstruction.location));\n    }\n    _instructionWithinFunctionToRevertStackTraceEntry(trace, inst) {\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n            sourceReference: sourceLocationToSourceReference(trace.bytecode, inst.location),\n            message: new return_data_1.ReturnData(trace.returnData),\n            isInvalidOpcodeError: inst.opcode === opcodes_1.Opcode.INVALID,\n        };\n    }\n    _instructionWithinFunctionToPanicStackTraceEntry(trace, inst, errorCode) {\n        var _a;\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.PANIC_ERROR,\n            sourceReference: (_a = sourceLocationToSourceReference(trace.bytecode, inst.location)) !== null && _a !== void 0 ? _a : this._getLastSourceReference(trace),\n            errorCode,\n        };\n    }\n    _instructionWithinFunctionToCustomErrorStackTraceEntry(trace, inst, message) {\n        var _a;\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.CUSTOM_ERROR,\n            sourceReference: (_a = sourceLocationToSourceReference(trace.bytecode, inst.location)) !== null && _a !== void 0 ? _a : this._getLastSourceReference(trace),\n            message,\n        };\n    }\n    _solidity063MaybeUnmappedRevert(trace) {\n        const lastStep = trace.steps[trace.steps.length - 1];\n        if (!message_trace_1.isEvmStep(lastStep)) {\n            return false;\n        }\n        const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n        return (semver_1.default.satisfies(trace.bytecode.compilerVersion, `^${FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS}`) && lastInst.opcode === opcodes_1.Opcode.REVERT);\n    }\n    // Solidity 0.6.3 unmapped reverts special handling\n    // For more info: https://github.com/ethereum/solidity/issues/9006\n    _solidity063GetFrameForUnmappedRevertBeforeFunction(trace) {\n        let revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n        if (revertFrame === undefined ||\n            revertFrame.sourceReference === undefined) {\n            if (trace.bytecode.contract.receive === undefined ||\n                trace.calldata.length > 0) {\n                if (trace.bytecode.contract.fallback !== undefined) {\n                    // Failed within the fallback\n                    const location = trace.bytecode.contract.fallback.location;\n                    revertFrame = {\n                        type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n                        sourceReference: {\n                            contract: trace.bytecode.contract.name,\n                            function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n                            file: location.file,\n                            line: location.getStartingLineNumber(),\n                            range: [location.offset, location.offset + location.length],\n                        },\n                    };\n                    this._solidity063CorrectLineNumber(revertFrame);\n                }\n            }\n            else {\n                // Failed within the receive function\n                const location = trace.bytecode.contract.receive.location;\n                revertFrame = {\n                    type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n                    sourceReference: {\n                        contract: trace.bytecode.contract.name,\n                        function: solidity_stack_trace_1.RECEIVE_FUNCTION_NAME,\n                        file: location.file,\n                        line: location.getStartingLineNumber(),\n                        range: [location.offset, location.offset + location.length],\n                    },\n                };\n                this._solidity063CorrectLineNumber(revertFrame);\n            }\n        }\n        return revertFrame;\n    }\n    _getOtherErrorBeforeCalledFunctionStackTraceEntry(trace) {\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n            sourceReference: this._getContractStartWithoutFunctionSourceReference(trace),\n        };\n    }\n    _isCalledNonContractAccountError(trace) {\n        // We could change this to checking that the last valid location maps to a call, but\n        // it's way more complex as we need to get the ast node from that location.\n        const lastIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n        if (lastIndex === undefined || lastIndex === 0) {\n            return false;\n        }\n        const lastStep = trace.steps[lastIndex]; // We know this is an EVM step\n        const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n        if (lastInst.opcode !== opcodes_1.Opcode.ISZERO) {\n            return false;\n        }\n        const prevStep = trace.steps[lastIndex - 1]; // We know this is an EVM step\n        const prevInst = trace.bytecode.getInstruction(prevStep.pc);\n        return prevInst.opcode === opcodes_1.Opcode.EXTCODESIZE;\n    }\n    _solidity063GetFrameForUnmappedRevertWithinFunction(trace) {\n        // If we are within a function there's a last valid location. It may\n        // be the entire contract.\n        const prevInst = this._getLastInstructionWithValidLocation(trace);\n        const lastStep = trace.steps[trace.steps.length - 1];\n        const nextInstPc = lastStep.pc + 1;\n        const hasNextInst = trace.bytecode.hasInstruction(nextInstPc);\n        if (hasNextInst) {\n            const nextInst = trace.bytecode.getInstruction(nextInstPc);\n            const prevLoc = prevInst.location;\n            const nextLoc = nextInst.location;\n            const prevFunc = prevLoc.getContainingFunction();\n            const nextFunc = nextLoc === null || nextLoc === void 0 ? void 0 : nextLoc.getContainingFunction();\n            // This is probably a require. This means that we have the exact\n            // line, but the stack trace may be degraded (e.g. missing our\n            // synthetic call frames when failing in a modifier) so we still\n            // add this frame as UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n            if (prevFunc !== undefined &&\n                nextLoc !== undefined &&\n                prevLoc.equals(nextLoc)) {\n                return Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, nextInst)), { type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR });\n            }\n            let revertFrame;\n            // If the previous and next location don't match, we try to use the\n            // previous one if it's inside a function, otherwise we use the next one\n            if (prevFunc !== undefined) {\n                revertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), { type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR });\n            }\n            else if (nextFunc !== undefined) {\n                revertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, nextInst)), { type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR });\n            }\n            if (revertFrame !== undefined) {\n                this._solidity063CorrectLineNumber(revertFrame);\n            }\n            return revertFrame;\n        }\n        if (message_trace_1.isCreateTrace(trace)) {\n            // Solidity is smart enough to stop emitting extra instructions after\n            // an unconditional revert happens in a constructor. If this is the case\n            // we just return a special error.\n            const constructorRevertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), { type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR });\n            // When the latest instruction is not within a function we need\n            // some default sourceReference to show to the user\n            if (constructorRevertFrame.sourceReference === undefined) {\n                const location = trace.bytecode.contract.location;\n                const defaultSourceReference = {\n                    function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n                    contract: trace.bytecode.contract.name,\n                    file: location.file,\n                    line: location.getStartingLineNumber(),\n                    range: [location.offset, location.offset + location.length],\n                };\n                if (trace.bytecode.contract.constructorFunction !== undefined) {\n                    defaultSourceReference.line =\n                        trace.bytecode.contract.constructorFunction.location.getStartingLineNumber();\n                }\n                constructorRevertFrame.sourceReference = defaultSourceReference;\n            }\n            else {\n                this._solidity063CorrectLineNumber(constructorRevertFrame);\n            }\n            return constructorRevertFrame;\n        }\n        // We may as well just be in a function or modifier and just happen\n        // to be at the last instruction of the runtime bytecode.\n        // In this case we just return whatever the last mapped intruction\n        // points to.\n        const latestInstructionRevertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), { type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR });\n        if (latestInstructionRevertFrame.sourceReference !== undefined) {\n            this._solidity063CorrectLineNumber(latestInstructionRevertFrame);\n        }\n        return latestInstructionRevertFrame;\n    }\n    _isContractTooLargeError(trace) {\n        if (trace.error === undefined || trace.error.error !== exceptions_1.ERROR.OUT_OF_GAS) {\n            return false;\n        }\n        // This error doesn't come from solidity, but actually from the VM.\n        // The deployment code executes correctly, but it OOGs.\n        const lastStep = trace.steps[trace.steps.length - 1];\n        if (!message_trace_1.isEvmStep(lastStep)) {\n            return false;\n        }\n        const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n        if (lastInst.opcode !== opcodes_1.Opcode.RETURN) {\n            return false;\n        }\n        // TODO: This is an over approximation, as we should be comparing the\n        //  runtime bytecode.\n        if (trace.bytecode.normalizedCode.length <=\n            EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT) {\n            return false;\n        }\n        // TODO: What happens if it's an actual out of gas that OOGs at the return?\n        //   maybe traces should have gasLimit and gasUsed.\n        return true;\n    }\n    _solidity063CorrectLineNumber(revertFrame) {\n        const file = revertFrame.sourceReference.file;\n        const lines = file.content.split(\"\\n\");\n        const currentLine = lines[revertFrame.sourceReference.line - 1];\n        if (currentLine.includes(\"require\") || currentLine.includes(\"revert\")) {\n            return;\n        }\n        const nextLines = lines.slice(revertFrame.sourceReference.line);\n        const firstNonEmptyLine = nextLines.findIndex((l) => l.trim() !== \"\");\n        if (firstNonEmptyLine === -1) {\n            return;\n        }\n        const nextLine = nextLines[firstNonEmptyLine];\n        if (nextLine.includes(\"require\") || nextLine.includes(\"revert\")) {\n            revertFrame.sourceReference.line += 1 + firstNonEmptyLine;\n        }\n    }\n    _getLastInstructionWithValidLocationStepIndex(trace) {\n        for (let i = trace.steps.length - 1; i >= 0; i--) {\n            const step = trace.steps[i];\n            if (!message_trace_1.isEvmStep(step)) {\n                return undefined;\n            }\n            const inst = trace.bytecode.getInstruction(step.pc);\n            if (inst.location !== undefined) {\n                return i;\n            }\n        }\n        return undefined;\n    }\n    _getLastInstructionWithValidLocation(trace) {\n        const lastLocationIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n        if (lastLocationIndex === undefined) {\n            return undefined;\n        }\n        const lastLocationStep = trace.steps[lastLocationIndex];\n        if (message_trace_1.isEvmStep(lastLocationStep)) {\n            const lastInstructionWithLocation = trace.bytecode.getInstruction(lastLocationStep.pc);\n            return lastInstructionWithLocation;\n        }\n        return undefined;\n    }\n    _callInstructionToCallFailedToExecuteStackTraceEntry(bytecode, callInst) {\n        // Calls only happen within functions\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.CALL_FAILED_ERROR,\n            sourceReference: sourceLocationToSourceReference(bytecode, callInst.location),\n        };\n    }\n    _getEntryBeforeFailureInModifier(trace, functionJumpdests) {\n        // If there's a jumpdest, this modifier belongs to the last function that it represents\n        if (functionJumpdests.length > 0) {\n            return instructionToCallstackStackTraceEntry(trace.bytecode, functionJumpdests[functionJumpdests.length - 1]);\n        }\n        // This function is only called after we jumped into the initial function in call traces, so\n        // there should always be at least a function jumpdest.\n        if (!message_trace_1.isDecodedCreateTrace(trace)) {\n            throw new Error(\"This shouldn't happen: a call trace has no functionJumpdest but has already jumped into a function\");\n        }\n        // If there's no jump dest, we point to the constructor.\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n            sourceReference: this._getConstructorStartSourceReference(trace),\n            functionType: model_1.ContractFunctionType.CONSTRUCTOR,\n        };\n    }\n    _failsRightAfterCall(trace, callSubtraceStepIndex) {\n        const lastStep = trace.steps[trace.steps.length - 1];\n        if (!message_trace_1.isEvmStep(lastStep)) {\n            return false;\n        }\n        const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n        if (lastInst.opcode !== opcodes_1.Opcode.REVERT) {\n            return false;\n        }\n        const callOpcodeStep = trace.steps[callSubtraceStepIndex - 1];\n        const callInst = trace.bytecode.getInstruction(callOpcodeStep.pc);\n        return this._isLastLocation(trace, callSubtraceStepIndex + 1, callInst.location // Calls are always made from within functions\n        );\n    }\n    _isCallFailedError(trace, instIndex, callInstruction) {\n        const callLocation = callInstruction.location; // Calls are always made from within functions\n        return this._isLastLocation(trace, instIndex, callLocation);\n    }\n    _isLastLocation(trace, fromStep, location) {\n        for (let i = fromStep; i < trace.steps.length; i++) {\n            const step = trace.steps[i];\n            if (!message_trace_1.isEvmStep(step)) {\n                return false;\n            }\n            const stepInst = trace.bytecode.getInstruction(step.pc);\n            if (stepInst.location === undefined) {\n                continue;\n            }\n            if (!location.equals(stepInst.location)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _isSubtraceErrorPropagated(trace, callSubtraceStepIndex) {\n        var _a, _b;\n        const call = trace.steps[callSubtraceStepIndex];\n        if (!trace.returnData.equals(call.returnData)) {\n            return false;\n        }\n        if (((_a = trace.error) === null || _a === void 0 ? void 0 : _a.error) === exceptions_1.ERROR.OUT_OF_GAS &&\n            ((_b = call.error) === null || _b === void 0 ? void 0 : _b.error) === exceptions_1.ERROR.OUT_OF_GAS) {\n            return true;\n        }\n        return this._failsRightAfterCall(trace, callSubtraceStepIndex);\n    }\n    _isProxyErrorPropagated(trace, callSubtraceStepIndex) {\n        if (!message_trace_1.isDecodedCallTrace(trace)) {\n            return false;\n        }\n        const callStep = trace.steps[callSubtraceStepIndex - 1];\n        if (!message_trace_1.isEvmStep(callStep)) {\n            return false;\n        }\n        const callInst = trace.bytecode.getInstruction(callStep.pc);\n        if (callInst.opcode !== opcodes_1.Opcode.DELEGATECALL) {\n            return false;\n        }\n        const subtrace = trace.steps[callSubtraceStepIndex];\n        if (message_trace_1.isEvmStep(subtrace)) {\n            return false;\n        }\n        if (message_trace_1.isPrecompileTrace(subtrace)) {\n            return false;\n        }\n        // If we can't recognize the implementation we'd better don't consider it as such\n        if (subtrace.bytecode === undefined) {\n            return false;\n        }\n        if (subtrace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n            return false;\n        }\n        if (!trace.returnData.equals(subtrace.returnData)) {\n            return false;\n        }\n        for (let i = callSubtraceStepIndex + 1; i < trace.steps.length; i++) {\n            const step = trace.steps[i];\n            if (!message_trace_1.isEvmStep(step)) {\n                return false;\n            }\n            const inst = trace.bytecode.getInstruction(step.pc);\n            // All the remaining locations should be valid, as they are part of the inline asm\n            if (inst.location === undefined) {\n                return false;\n            }\n            if (inst.jumpType === model_1.JumpType.INTO_FUNCTION ||\n                inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n                return false;\n            }\n        }\n        const lastStep = trace.steps[trace.steps.length - 1];\n        const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n        return lastInst.opcode === opcodes_1.Opcode.REVERT;\n    }\n    _isContractCallRunOutOfGasError(trace, callStepIndex) {\n        var _a, _b;\n        if (trace.returnData.length > 0) {\n            return false;\n        }\n        if (((_a = trace.error) === null || _a === void 0 ? void 0 : _a.error) !== exceptions_1.ERROR.REVERT) {\n            return false;\n        }\n        const call = trace.steps[callStepIndex];\n        if (((_b = call.error) === null || _b === void 0 ? void 0 : _b.error) !== exceptions_1.ERROR.OUT_OF_GAS) {\n            return false;\n        }\n        return this._failsRightAfterCall(trace, callStepIndex);\n    }\n    _isPanicReturnData(returnData) {\n        return new return_data_1.ReturnData(returnData).isPanicReturnData();\n    }\n}\nexports.ErrorInferrer = ErrorInferrer;\nfunction instructionToCallstackStackTraceEntry(bytecode, inst) {\n    // This means that a jump is made from within an internal solc function.\n    // These are normally made from yul code, so they don't map to any Solidity\n    // function\n    if (inst.location === undefined) {\n        const location = bytecode.contract.location;\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY,\n            pc: inst.pc,\n            sourceReference: {\n                file: bytecode.contract.location.file,\n                contract: bytecode.contract.name,\n                function: undefined,\n                line: bytecode.contract.location.getStartingLineNumber(),\n                range: [location.offset, location.offset + location.length],\n            },\n        };\n    }\n    const func = inst.location.getContainingFunction();\n    if (func !== undefined) {\n        return {\n            type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n            sourceReference: sourceLocationToSourceReference(bytecode, inst.location),\n            functionType: func.type,\n        };\n    }\n    return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: {\n            function: undefined,\n            contract: bytecode.contract.name,\n            file: inst.location.file,\n            line: inst.location.getStartingLineNumber(),\n            range: [\n                inst.location.offset,\n                inst.location.offset + inst.location.length,\n            ],\n        },\n        functionType: model_1.ContractFunctionType.FUNCTION,\n    };\n}\nexports.instructionToCallstackStackTraceEntry = instructionToCallstackStackTraceEntry;\nfunction sourceLocationToSourceReference(bytecode, location) {\n    if (location === undefined) {\n        return undefined;\n    }\n    const func = location.getContainingFunction();\n    if (func === undefined) {\n        return undefined;\n    }\n    let funcName = func.name;\n    if (func.type === model_1.ContractFunctionType.CONSTRUCTOR) {\n        funcName = solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME;\n    }\n    else if (func.type === model_1.ContractFunctionType.FALLBACK) {\n        funcName = solidity_stack_trace_1.FALLBACK_FUNCTION_NAME;\n    }\n    else if (func.type === model_1.ContractFunctionType.RECEIVE) {\n        funcName = solidity_stack_trace_1.RECEIVE_FUNCTION_NAME;\n    }\n    return {\n        function: funcName,\n        contract: func.type === model_1.ContractFunctionType.FREE_FUNCTION\n            ? undefined\n            : bytecode.contract.name,\n        file: func.location.file,\n        line: location.getStartingLineNumber(),\n        range: [location.offset, location.offset + location.length],\n    };\n}\n//# sourceMappingURL=error-inferrer.js.map"]},"metadata":{},"sourceType":"script"}