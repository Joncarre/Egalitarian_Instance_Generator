{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NativeCompiler = exports.Compiler = void 0;\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs = __importStar(require(\"fs\"));\n\nclass Compiler {\n  constructor(_pathToSolcJs) {\n    this._pathToSolcJs = _pathToSolcJs;\n  }\n\n  async compile(input) {\n    const solc = await this.getSolc();\n    const jsonOutput = solc.compile(JSON.stringify(input));\n    return JSON.parse(jsonOutput);\n  }\n\n  async getSolc() {\n    if (this._loadedSolc !== undefined) {\n      return this._loadedSolc;\n    }\n\n    const {\n      default: solcWrapper\n    } = await Promise.resolve().then(() => __importStar(require(\"solc/wrapper\")));\n    this._loadedSolc = solcWrapper(this._loadCompilerSources(this._pathToSolcJs));\n    return this._loadedSolc;\n  }\n  /**\n   * This function loads the compiler sources bypassing any require hook.\n   *\n   * The compiler is a huge asm.js file, and using a simple require may trigger\n   * babel/register and hang the process.\n   */\n\n\n  _loadCompilerSources(compilerPath) {\n    const Module = module.constructor;\n    const previousHook = Module._extensions[\".js\"];\n\n    Module._extensions[\".js\"] = function (module, filename) {\n      const content = fs.readFileSync(filename, \"utf8\");\n\n      Object.getPrototypeOf(module)._compile.call(module, content, filename);\n    };\n\n    const loadedSolc = require(compilerPath);\n\n    Module._extensions[\".js\"] = previousHook;\n    return loadedSolc;\n  }\n\n}\n\nexports.Compiler = Compiler;\n\nclass NativeCompiler {\n  constructor(_pathToSolc) {\n    this._pathToSolc = _pathToSolc;\n  }\n\n  async compile(input) {\n    const output = await new Promise((resolve, reject) => {\n      const process = child_process_1.exec(`${this._pathToSolc} --standard-json`, {\n        maxBuffer: 1024 * 1024 * 500\n      }, (err, stdout) => {\n        if (err !== null) {\n          return reject(err);\n        }\n\n        resolve(stdout);\n      });\n      process.stdin.write(JSON.stringify(input));\n      process.stdin.end();\n    });\n    return JSON.parse(output);\n  }\n\n}\n\nexports.NativeCompiler = NativeCompiler;","map":{"version":3,"sources":["../../../src/internal/solidity/compiler/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,EAAA,GAAA,YAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;AAEA,MAAa,QAAb,CAAqB;AAGnB,EAAA,WAAA,CAAoB,aAApB,EAAyC;AAArB,SAAA,aAAA,GAAA,aAAA;AAAyB;;AAEzB,QAAP,OAAO,CAAC,KAAD,EAAW;AAC7B,UAAM,IAAI,GAAG,MAAM,KAAK,OAAL,EAAnB;AAEA,UAAM,UAAU,GAAG,IAAI,CAAC,OAAL,CAAa,IAAI,CAAC,SAAL,CAAe,KAAf,CAAb,CAAnB;AACA,WAAO,IAAI,CAAC,KAAL,CAAW,UAAX,CAAP;AACD;;AAEmB,QAAP,OAAO,GAAA;AAClB,QAAI,KAAK,WAAL,KAAqB,SAAzB,EAAoC;AAClC,aAAO,KAAK,WAAZ;AACD;;AAED,UAAM;AAAE,MAAA,OAAO,EAAE;AAAX,QAA2B,MAAA,OAAA,CAAA,OAAA,GAAA,IAAA,CAAA,MAAA,YAAA,CAAA,OAAA,CAAa,cAAb,CAAA,CAAA,CAAjC;AACA,SAAK,WAAL,GAAmB,WAAW,CAC5B,KAAK,oBAAL,CAA0B,KAAK,aAA/B,CAD4B,CAA9B;AAIA,WAAO,KAAK,WAAZ;AACD;AAED;;;;;AAKG;;;AACK,EAAA,oBAAoB,CAAC,YAAD,EAAqB;AAC/C,UAAM,MAAM,GAAG,MAAM,CAAC,WAAtB;AACA,UAAM,YAAY,GAAG,MAAM,CAAC,WAAP,CAAmB,KAAnB,CAArB;;AAEA,IAAA,MAAM,CAAC,WAAP,CAAmB,KAAnB,IAA4B,UAC1B,MAD0B,EAE1B,QAF0B,EAEV;AAEhB,YAAM,OAAO,GAAG,EAAE,CAAC,YAAH,CAAgB,QAAhB,EAA0B,MAA1B,CAAhB;;AACA,MAAA,MAAM,CAAC,cAAP,CAAsB,MAAtB,EAA8B,QAA9B,CAAuC,IAAvC,CAA4C,MAA5C,EAAoD,OAApD,EAA6D,QAA7D;AACD,KAND;;AAQA,UAAM,UAAU,GAAG,OAAO,CAAC,YAAD,CAA1B;;AAEA,IAAA,MAAM,CAAC,WAAP,CAAmB,KAAnB,IAA4B,YAA5B;AAEA,WAAO,UAAP;AACD;;AAhDkB;;AAArB,OAAA,CAAA,QAAA,GAAA,QAAA;;AAmDA,MAAa,cAAb,CAA2B;AACzB,EAAA,WAAA,CAAoB,WAApB,EAAuC;AAAnB,SAAA,WAAA,GAAA,WAAA;AAAuB;;AAEvB,QAAP,OAAO,CAAC,KAAD,EAAW;AAC7B,UAAM,MAAM,GAAW,MAAM,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAC3D,YAAM,OAAO,GAAG,eAAA,CAAA,IAAA,CACd,GAAG,KAAK,WAAW,kBADL,EAEd;AACE,QAAA,SAAS,EAAE,OAAO,IAAP,GAAc;AAD3B,OAFc,EAKd,CAAC,GAAD,EAAM,MAAN,KAAgB;AACd,YAAI,GAAG,KAAK,IAAZ,EAAkB;AAChB,iBAAO,MAAM,CAAC,GAAD,CAAb;AACD;;AACD,QAAA,OAAO,CAAC,MAAD,CAAP;AACD,OAVa,CAAhB;AAaA,MAAA,OAAO,CAAC,KAAR,CAAe,KAAf,CAAqB,IAAI,CAAC,SAAL,CAAe,KAAf,CAArB;AACA,MAAA,OAAO,CAAC,KAAR,CAAe,GAAf;AACD,KAhB4B,CAA7B;AAkBA,WAAO,IAAI,CAAC,KAAL,CAAW,MAAX,CAAP;AACD;;AAvBwB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NativeCompiler = exports.Compiler = void 0;\nconst child_process_1 = require(\"child_process\");\nconst fs = __importStar(require(\"fs\"));\nclass Compiler {\n    constructor(_pathToSolcJs) {\n        this._pathToSolcJs = _pathToSolcJs;\n    }\n    async compile(input) {\n        const solc = await this.getSolc();\n        const jsonOutput = solc.compile(JSON.stringify(input));\n        return JSON.parse(jsonOutput);\n    }\n    async getSolc() {\n        if (this._loadedSolc !== undefined) {\n            return this._loadedSolc;\n        }\n        const { default: solcWrapper } = await Promise.resolve().then(() => __importStar(require(\"solc/wrapper\")));\n        this._loadedSolc = solcWrapper(this._loadCompilerSources(this._pathToSolcJs));\n        return this._loadedSolc;\n    }\n    /**\n     * This function loads the compiler sources bypassing any require hook.\n     *\n     * The compiler is a huge asm.js file, and using a simple require may trigger\n     * babel/register and hang the process.\n     */\n    _loadCompilerSources(compilerPath) {\n        const Module = module.constructor;\n        const previousHook = Module._extensions[\".js\"];\n        Module._extensions[\".js\"] = function (module, filename) {\n            const content = fs.readFileSync(filename, \"utf8\");\n            Object.getPrototypeOf(module)._compile.call(module, content, filename);\n        };\n        const loadedSolc = require(compilerPath);\n        Module._extensions[\".js\"] = previousHook;\n        return loadedSolc;\n    }\n}\nexports.Compiler = Compiler;\nclass NativeCompiler {\n    constructor(_pathToSolc) {\n        this._pathToSolc = _pathToSolc;\n    }\n    async compile(input) {\n        const output = await new Promise((resolve, reject) => {\n            const process = child_process_1.exec(`${this._pathToSolc} --standard-json`, {\n                maxBuffer: 1024 * 1024 * 500,\n            }, (err, stdout) => {\n                if (err !== null) {\n                    return reject(err);\n                }\n                resolve(stdout);\n            });\n            process.stdin.write(JSON.stringify(input));\n            process.stdin.end();\n        });\n        return JSON.parse(output);\n    }\n}\nexports.NativeCompiler = NativeCompiler;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}