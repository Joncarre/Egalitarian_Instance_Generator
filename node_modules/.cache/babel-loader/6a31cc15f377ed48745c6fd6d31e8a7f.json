{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Resolver = exports.ResolvedFile = void 0;\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst resolve_1 = __importDefault(require(\"resolve\"));\n\nconst source_names_1 = require(\"../../utils/source-names\");\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nconst hash_1 = require(\"../util/hash\");\n\nconst NODE_MODULES = \"node_modules\";\n\nclass ResolvedFile {\n  constructor(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion) {\n    this.sourceName = sourceName;\n    this.absolutePath = absolutePath;\n    this.content = content;\n    this.contentHash = contentHash;\n    this.lastModificationDate = lastModificationDate;\n    errors_1.assertHardhatInvariant(libraryName === undefined && libraryVersion === undefined || libraryName !== undefined && libraryVersion !== undefined, \"Libraries should have both name and version, or neither one\");\n\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion\n      };\n    }\n  }\n\n  getVersionedName() {\n    return this.sourceName + (this.library !== undefined ? `@v${this.library.version}` : \"\");\n  }\n\n}\n\nexports.ResolvedFile = ResolvedFile;\n\nclass Resolver {\n  constructor(_projectRoot, _parser, _readFile) {\n    this._projectRoot = _projectRoot;\n    this._parser = _parser;\n    this._readFile = _readFile;\n  }\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n\n\n  async resolveSourceName(sourceName) {\n    source_names_1.validateSourceNameFormat(sourceName);\n\n    if (await source_names_1.isLocalSourceName(this._projectRoot, sourceName)) {\n      return this._resolveLocalSourceName(sourceName);\n    }\n\n    return this._resolveLibrarySourceName(sourceName);\n  }\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param imported The path in the import statement.\n   */\n\n\n  async resolveImport(from, imported) {\n    const scheme = this._getUriScheme(imported);\n\n    if (scheme !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme\n      });\n    }\n\n    if (source_names_1.replaceBackslashes(imported) !== imported) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    if (source_names_1.isAbsolutePathSourceName(imported)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    try {\n      if (!this._isRelativeImport(imported)) {\n        return await this.resolveSourceName(source_names_1.normalizeSourceName(imported));\n      }\n\n      const sourceName = await this._relativeImportToSourceName(from, imported); // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n\n      if (from.library === undefined && !this._isRelativeImportToLibrary(from, imported)) {\n        return await this._resolveLocalSourceName(sourceName);\n      }\n\n      return await this.resolveSourceName(sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND) || errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED, {\n          library: error.messageArguments.library,\n          from: from.sourceName\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async _resolveLocalSourceName(sourceName) {\n    await this._validateSourceNameExistenceAndCasing(this._projectRoot, sourceName, false);\n    const absolutePath = path_1.default.join(this._projectRoot, sourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n\n  async _resolveLibrarySourceName(sourceName) {\n    const libraryName = this._getLibraryName(sourceName);\n\n    let packageJsonPath;\n\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(path_1.default.join(libraryName, \"package.json\"));\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path_1.default.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path_1.default.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED, {\n          library: libraryName\n        }, error);\n      }\n    }\n\n    let nodeModulesPath = path_1.default.dirname(path_1.default.dirname(packageJsonPath));\n\n    if (this._isScopedPackage(sourceName)) {\n      nodeModulesPath = path_1.default.dirname(nodeModulesPath);\n    }\n\n    await this._validateSourceNameExistenceAndCasing(nodeModulesPath, sourceName, true);\n    const packageInfo = await fs_extra_1.default.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n    return this._resolveFile(sourceName, // We resolve to the real path here, as we may be resolving a linked library\n    await fs_extra_1.default.realpath(path_1.default.join(nodeModulesPath, sourceName)), libraryName, libraryVersion);\n  }\n\n  async _relativeImportToSourceName(from, imported) {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n\n    const sourceName = source_names_1.normalizeSourceName(path_1.default.join(path_1.default.dirname(from.sourceName), imported)); // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    if (from.library !== undefined && !this._isInsideSameDir(from.sourceName, sourceName)) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    return sourceName;\n  }\n\n  async _resolveFile(sourceName, absolutePath, libraryName, libraryVersion) {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fs_extra_1.default.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n    const contentHash = hash_1.createNonCryptographicHashBasedIdentifier(Buffer.from(rawContent)).toString(\"hex\");\n\n    const parsedContent = this._parser.parse(rawContent, absolutePath, contentHash);\n\n    const content = Object.assign({\n      rawContent\n    }, parsedContent);\n    return new ResolvedFile(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion);\n  }\n\n  _isRelativeImport(imported) {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n\n  _resolveNodeModulesFileFromProjectRoot(fileName) {\n    return resolve_1.default.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true\n    });\n  }\n\n  _getLibraryName(sourceName) {\n    let endIndex;\n\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n\n    return sourceName.slice(0, endIndex);\n  }\n\n  _getUriScheme(s) {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n\n    if (match === null) {\n      return undefined;\n    }\n\n    return match[1];\n  }\n\n  _isInsideSameDir(sourceNameInDir, sourceNameToTest) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir = firstSlash !== -1 ? sourceNameInDir.substring(0, firstSlash) : sourceNameInDir;\n    return sourceNameToTest.startsWith(dir);\n  }\n\n  _isScopedPackage(packageOrPackageFile) {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n\n  _isRelativeImportToLibrary(from, imported) {\n    return this._isRelativeImport(imported) && from.library === undefined && imported.includes(`${NODE_MODULES}/`);\n  }\n\n  _relativeImportToLibraryToSourceName(from, imported) {\n    const sourceName = source_names_1.normalizeSourceName(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n\n  async _validateSourceNameExistenceAndCasing(fromDir, sourceName, isLibrary) {\n    try {\n      await source_names_1.validateSourceNameExistenceAndCasing(fromDir, sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(isLibrary ? errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND : errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND, {\n          file: sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING, {\n          incorrect: sourceName,\n          correct: error.messageArguments.correct\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n}\n\nexports.Resolver = Resolver;","map":{"version":3,"sources":["../../src/internal/solidity/resolver.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,UAAA,CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;;AAOA,MAAA,cAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAQA,MAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAQA,MAAM,YAAY,GAAG,cAArB;;AAEA,MAAa,YAAb,CAAyB;AAGvB,EAAA,WAAA,CACkB,UADlB,EAEkB,YAFlB,EAGkB,OAHlB,EAIkB,WAJlB,EAKkB,oBALlB,EAME,WANF,EAOE,cAPF,EAOyB;AANP,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,WAAA,GAAA,WAAA;AACA,SAAA,oBAAA,GAAA,oBAAA;AAIhB,IAAA,QAAA,CAAA,sBAAA,CACG,WAAW,KAAK,SAAhB,IAA6B,cAAc,KAAK,SAAjD,IACG,WAAW,KAAK,SAAhB,IAA6B,cAAc,KAAK,SAFrD,EAGE,6DAHF;;AAMA,QAAI,WAAW,KAAK,SAAhB,IAA6B,cAAc,KAAK,SAApD,EAA+D;AAC7D,WAAK,OAAL,GAAe;AACb,QAAA,IAAI,EAAE,WADO;AAEb,QAAA,OAAO,EAAE;AAFI,OAAf;AAID;AACF;;AAEM,EAAA,gBAAgB,GAAA;AACrB,WACE,KAAK,UAAL,IACC,KAAK,OAAL,KAAiB,SAAjB,GAA6B,KAAK,KAAK,OAAL,CAAa,OAAO,EAAtD,GAA2D,EAD5D,CADF;AAID;;AA/BsB;;AAAzB,OAAA,CAAA,YAAA,GAAA,YAAA;;AAkCA,MAAa,QAAb,CAAqB;AACnB,EAAA,WAAA,CACmB,YADnB,EAEmB,OAFnB,EAGmB,SAHnB,EAGuE;AAFpD,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACf;AAEJ;;;;AAIG;;;AAC2B,QAAjB,iBAAiB,CAAC,UAAD,EAAmB;AAC/C,IAAA,cAAA,CAAA,wBAAA,CAAyB,UAAzB;;AAEA,QAAI,MAAM,cAAA,CAAA,iBAAA,CAAkB,KAAK,YAAvB,EAAqC,UAArC,CAAV,EAA4D;AAC1D,aAAO,KAAK,uBAAL,CAA6B,UAA7B,CAAP;AACD;;AAED,WAAO,KAAK,yBAAL,CAA+B,UAA/B,CAAP;AACD;AAED;;;;AAIG;;;AACuB,QAAb,aAAa,CACxB,IADwB,EAExB,QAFwB,EAER;AAEhB,UAAM,MAAM,GAAG,KAAK,aAAL,CAAmB,QAAnB,CAAf;;AACA,QAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,YAAM,IAAI,QAAA,CAAA,YAAJ,CAAiB,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,uBAAjC,EAA0D;AAC9D,QAAA,IAAI,EAAE,IAAI,CAAC,UADmD;AAE9D,QAAA,QAF8D;AAG9D,QAAA,QAAQ,EAAE;AAHoD,OAA1D,CAAN;AAKD;;AAED,QAAI,cAAA,CAAA,kBAAA,CAAmB,QAAnB,MAAiC,QAArC,EAA+C;AAC7C,YAAM,IAAI,QAAA,CAAA,YAAJ,CAAiB,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,wBAAjC,EAA2D;AAC/D,QAAA,IAAI,EAAE,IAAI,CAAC,UADoD;AAE/D,QAAA;AAF+D,OAA3D,CAAN;AAID;;AAED,QAAI,cAAA,CAAA,wBAAA,CAAyB,QAAzB,CAAJ,EAAwC;AACtC,YAAM,IAAI,QAAA,CAAA,YAAJ,CAAiB,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,4BAAjC,EAA+D;AACnE,QAAA,IAAI,EAAE,IAAI,CAAC,UADwD;AAEnE,QAAA;AAFmE,OAA/D,CAAN;AAID;;AAED,QAAI;AACF,UAAI,CAAC,KAAK,iBAAL,CAAuB,QAAvB,CAAL,EAAuC;AACrC,eAAO,MAAM,KAAK,iBAAL,CAAuB,cAAA,CAAA,mBAAA,CAAoB,QAApB,CAAvB,CAAb;AACD;;AAED,YAAM,UAAU,GAAG,MAAM,KAAK,2BAAL,CAAiC,IAAjC,EAAuC,QAAvC,CAAzB,CALE,CAOF;AACA;AACA;;AACA,UACE,IAAI,CAAC,OAAL,KAAiB,SAAjB,IACA,CAAC,KAAK,0BAAL,CAAgC,IAAhC,EAAsC,QAAtC,CAFH,EAGE;AACA,eAAO,MAAM,KAAK,uBAAL,CAA6B,UAA7B,CAAb;AACD;;AAED,aAAO,MAAM,KAAK,iBAAL,CAAuB,UAAvB,CAAb;AACD,KAlBD,CAkBE,OAAO,KAAP,EAAc;AACd,UACE,QAAA,CAAA,YAAA,CAAa,kBAAb,CACE,KADF,EAEE,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,cAFlB,KAIA,QAAA,CAAA,YAAA,CAAa,kBAAb,CACE,KADF,EAEE,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,sBAFlB,CALF,EASE;AACA,cAAM,IAAI,QAAA,CAAA,YAAJ,CACJ,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,uBADZ,EAEJ;AACE,UAAA,QADF;AAEE,UAAA,IAAI,EAAE,IAAI,CAAC;AAFb,SAFI,EAMJ,KANI,CAAN;AAQD;;AAED,UACE,QAAA,CAAA,YAAA,CAAa,kBAAb,CACE,KADF,EAEE,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,wBAFlB,CADF,EAKE;AACA,cAAM,IAAI,QAAA,CAAA,YAAJ,CACJ,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,2BADZ,EAEJ;AACE,UAAA,QADF;AAEE,UAAA,IAAI,EAAE,IAAI,CAAC;AAFb,SAFI,EAMJ,KANI,CAAN;AAQD;;AAED,UACE,QAAA,CAAA,YAAA,CAAa,kBAAb,CACE,KADF,EAEE,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,qBAFlB,CADF,EAKE;AACA,cAAM,IAAI,QAAA,CAAA,YAAJ,CACJ,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,8BADZ,EAEJ;AACE,UAAA,OAAO,EAAE,KAAK,CAAC,gBAAN,CAAuB,OADlC;AAEE,UAAA,IAAI,EAAE,IAAI,CAAC;AAFb,SAFI,EAMJ,KANI,CAAN;AAQD,OAnDa,CAqDd;;;AACA,YAAM,KAAN;AACD;AACF;;AAEoC,QAAvB,uBAAuB,CACnC,UADmC,EACjB;AAElB,UAAM,KAAK,qCAAL,CACJ,KAAK,YADD,EAEJ,UAFI,EAGJ,KAHI,CAAN;AAMA,UAAM,YAAY,GAAG,MAAA,CAAA,OAAA,CAAK,IAAL,CAAU,KAAK,YAAf,EAA6B,UAA7B,CAArB;AACA,WAAO,KAAK,YAAL,CAAkB,UAAlB,EAA8B,YAA9B,CAAP;AACD;;AAEsC,QAAzB,yBAAyB,CACrC,UADqC,EACnB;AAElB,UAAM,WAAW,GAAG,KAAK,eAAL,CAAqB,UAArB,CAApB;;AAEA,QAAI,eAAJ;;AACA,QAAI;AACF,MAAA,eAAe,GAAG,KAAK,sCAAL,CAChB,MAAA,CAAA,OAAA,CAAK,IAAL,CAAU,WAAV,EAAuB,cAAvB,CADgB,CAAlB;AAGD,KAJD,CAIE,OAAO,KAAP,EAAc;AACd;AACA;AACA;AACA,UAAI,WAAW,KAAK,SAApB,EAA+B;AAC7B,cAAM,cAAc,GAAG,MAAA,CAAA,OAAA,CAAK,IAAL,CAAU,SAAV,EAAqB,IAArB,EAA2B,IAA3B,CAAvB;AACA,QAAA,eAAe,GAAG,MAAA,CAAA,OAAA,CAAK,IAAL,CAAU,cAAV,EAA0B,cAA1B,CAAlB;AACD,OAHD,MAGO;AACL,cAAM,IAAI,QAAA,CAAA,YAAJ,CACJ,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,qBADZ,EAEJ;AACE,UAAA,OAAO,EAAE;AADX,SAFI,EAKJ,KALI,CAAN;AAOD;AACF;;AAED,QAAI,eAAe,GAAG,MAAA,CAAA,OAAA,CAAK,OAAL,CAAa,MAAA,CAAA,OAAA,CAAK,OAAL,CAAa,eAAb,CAAb,CAAtB;;AACA,QAAI,KAAK,gBAAL,CAAsB,UAAtB,CAAJ,EAAuC;AACrC,MAAA,eAAe,GAAG,MAAA,CAAA,OAAA,CAAK,OAAL,CAAa,eAAb,CAAlB;AACD;;AAED,UAAM,KAAK,qCAAL,CACJ,eADI,EAEJ,UAFI,EAGJ,IAHI,CAAN;AAMA,UAAM,WAAW,GAGb,MAAM,UAAA,CAAA,OAAA,CAAQ,QAAR,CAAiB,eAAjB,CAHV;AAIA,UAAM,cAAc,GAAG,WAAW,CAAC,OAAnC;AAEA,WAAO,KAAK,YAAL,CACL,UADK,EAEL;AACA,UAAM,UAAA,CAAA,OAAA,CAAQ,QAAR,CAAiB,MAAA,CAAA,OAAA,CAAK,IAAL,CAAU,eAAV,EAA2B,UAA3B,CAAjB,CAHD,EAIL,WAJK,EAKL,cALK,CAAP;AAOD;;AAEwC,QAA3B,2BAA2B,CACvC,IADuC,EAEvC,QAFuC,EAEvB;AAEhB;AACA;AACA;AACA,QAAI,KAAK,0BAAL,CAAgC,IAAhC,EAAsC,QAAtC,CAAJ,EAAqD;AACnD,aAAO,KAAK,oCAAL,CAA0C,IAA1C,EAAgD,QAAhD,CAAP;AACD;;AAED,UAAM,UAAU,GAAG,cAAA,CAAA,mBAAA,CACjB,MAAA,CAAA,OAAA,CAAK,IAAL,CAAU,MAAA,CAAA,OAAA,CAAK,OAAL,CAAa,IAAI,CAAC,UAAlB,CAAV,EAAyC,QAAzC,CADiB,CAAnB,CATgB,CAahB;AACA;;AACA,QAAI,IAAI,CAAC,OAAL,KAAiB,SAAjB,IAA8B,UAAU,CAAC,UAAX,CAAsB,KAAtB,CAAlC,EAAgE;AAC9D,YAAM,IAAI,QAAA,CAAA,YAAJ,CACJ,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,iCADZ,EAEJ;AAAE,QAAA,IAAI,EAAE,IAAI,CAAC,UAAb;AAAyB,QAAA;AAAzB,OAFI,CAAN;AAID;;AAED,QACE,IAAI,CAAC,OAAL,KAAiB,SAAjB,IACA,CAAC,KAAK,gBAAL,CAAsB,IAAI,CAAC,UAA3B,EAAuC,UAAvC,CAFH,EAGE;AACA;AACA;AACA,YAAM,IAAI,QAAA,CAAA,YAAJ,CAAiB,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,cAAjC,EAAiD;AACrD,QAAA,IAAI,EAAE,IAAI,CAAC,UAD0C;AAErD,QAAA;AAFqD,OAAjD,CAAN;AAID;;AAED,WAAO,UAAP;AACD;;AAEyB,QAAZ,YAAY,CACxB,UADwB,EAExB,YAFwB,EAGxB,WAHwB,EAIxB,cAJwB,EAID;AAEvB,UAAM,UAAU,GAAG,MAAM,KAAK,SAAL,CAAe,YAAf,CAAzB;AACA,UAAM,KAAK,GAAG,MAAM,UAAA,CAAA,OAAA,CAAQ,IAAR,CAAa,YAAb,CAApB;AACA,UAAM,oBAAoB,GAAG,IAAI,IAAJ,CAAS,KAAK,CAAC,KAAf,CAA7B;AAEA,UAAM,WAAW,GAAG,MAAA,CAAA,yCAAA,CAClB,MAAM,CAAC,IAAP,CAAY,UAAZ,CADkB,EAElB,QAFkB,CAET,KAFS,CAApB;;AAIA,UAAM,aAAa,GAAG,KAAK,OAAL,CAAa,KAAb,CACpB,UADoB,EAEpB,YAFoB,EAGpB,WAHoB,CAAtB;;AAMA,UAAM,OAAO,GAAA,MAAA,CAAA,MAAA,CAAA;AACX,MAAA;AADW,KAAA,EAER,aAFQ,CAAb;AAKA,WAAO,IAAI,YAAJ,CACL,UADK,EAEL,YAFK,EAGL,OAHK,EAIL,WAJK,EAKL,oBALK,EAML,WANK,EAOL,cAPK,CAAP;AASD;;AAEO,EAAA,iBAAiB,CAAC,QAAD,EAAiB;AACxC,WAAO,QAAQ,CAAC,UAAT,CAAoB,IAApB,KAA6B,QAAQ,CAAC,UAAT,CAAoB,KAApB,CAApC;AACD;;AAEO,EAAA,sCAAsC,CAAC,QAAD,EAAiB;AAC7D,WAAO,SAAA,CAAA,OAAA,CAAQ,IAAR,CAAa,QAAb,EAAuB;AAC5B,MAAA,OAAO,EAAE,KAAK,YADc;AAE5B,MAAA,gBAAgB,EAAE;AAFU,KAAvB,CAAP;AAID;;AAEO,EAAA,eAAe,CAAC,UAAD,EAAmB;AACxC,QAAI,QAAJ;;AACA,QAAI,KAAK,gBAAL,CAAsB,UAAtB,CAAJ,EAAuC;AACrC,MAAA,QAAQ,GAAG,UAAU,CAAC,OAAX,CAAmB,GAAnB,EAAwB,UAAU,CAAC,OAAX,CAAmB,GAAnB,IAA0B,CAAlD,CAAX;AACD,KAFD,MAEO,IAAI,UAAU,CAAC,OAAX,CAAmB,GAAnB,MAA4B,CAAC,CAAjC,EAAoC;AACzC,MAAA,QAAQ,GAAG,UAAU,CAAC,MAAtB;AACD,KAFM,MAEA;AACL,MAAA,QAAQ,GAAG,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAX;AACD;;AAED,WAAO,UAAU,CAAC,KAAX,CAAiB,CAAjB,EAAoB,QAApB,CAAP;AACD;;AAEO,EAAA,aAAa,CAAC,CAAD,EAAU;AAC7B,UAAM,EAAE,GAAG,kBAAX;AACA,UAAM,KAAK,GAAG,EAAE,CAAC,IAAH,CAAQ,CAAR,CAAd;;AACA,QAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,aAAO,SAAP;AACD;;AAED,WAAO,KAAK,CAAC,CAAD,CAAZ;AACD;;AAEO,EAAA,gBAAgB,CAAC,eAAD,EAA0B,gBAA1B,EAAkD;AACxE,UAAM,UAAU,GAAG,eAAe,CAAC,OAAhB,CAAwB,GAAxB,CAAnB;AACA,UAAM,GAAG,GACP,UAAU,KAAK,CAAC,CAAhB,GACI,eAAe,CAAC,SAAhB,CAA0B,CAA1B,EAA6B,UAA7B,CADJ,GAEI,eAHN;AAKA,WAAO,gBAAgB,CAAC,UAAjB,CAA4B,GAA5B,CAAP;AACD;;AAEO,EAAA,gBAAgB,CAAC,oBAAD,EAA6B;AACnD,WAAO,oBAAoB,CAAC,UAArB,CAAgC,GAAhC,CAAP;AACD;;AAEO,EAAA,0BAA0B,CAChC,IADgC,EAEhC,QAFgC,EAEhB;AAEhB,WACE,KAAK,iBAAL,CAAuB,QAAvB,KACA,IAAI,CAAC,OAAL,KAAiB,SADjB,IAEA,QAAQ,CAAC,QAAT,CAAkB,GAAG,YAAY,GAAjC,CAHF;AAKD;;AAEO,EAAA,oCAAoC,CAC1C,IAD0C,EAE1C,QAF0C,EAE1B;AAEhB,UAAM,UAAU,GAAG,cAAA,CAAA,mBAAA,CACjB,MAAA,CAAA,OAAA,CAAK,IAAL,CAAU,MAAA,CAAA,OAAA,CAAK,OAAL,CAAa,IAAI,CAAC,UAAlB,CAAV,EAAyC,QAAzC,CADiB,CAAnB;AAIA,UAAM,OAAO,GAAG,UAAU,CAAC,OAAX,CAAmB,GAAG,YAAY,GAAlC,CAAhB;AACA,WAAO,UAAU,CAAC,MAAX,CAAkB,OAAO,GAAG,YAAY,CAAC,MAAvB,GAAgC,CAAlD,CAAP;AACD;;AAEkD,QAArC,qCAAqC,CACjD,OADiD,EAEjD,UAFiD,EAGjD,SAHiD,EAG/B;AAElB,QAAI;AACF,YAAM,cAAA,CAAA,oCAAA,CAAqC,OAArC,EAA8C,UAA9C,CAAN;AACD,KAFD,CAEE,OAAO,KAAP,EAAc;AACd,UACE,QAAA,CAAA,YAAA,CAAa,kBAAb,CACE,KADF,EAEE,aAAA,CAAA,MAAA,CAAO,YAAP,CAAoB,cAFtB,CADF,EAKE;AACA,cAAM,IAAI,QAAA,CAAA,YAAJ,CACJ,SAAS,GACL,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,sBADX,GAEL,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,cAHhB,EAIJ;AAAE,UAAA,IAAI,EAAE;AAAR,SAJI,EAKJ,KALI,CAAN;AAOD;;AAED,UACE,QAAA,CAAA,YAAA,CAAa,kBAAb,CAAgC,KAAhC,EAAuC,aAAA,CAAA,MAAA,CAAO,YAAP,CAAoB,YAA3D,CADF,EAEE;AACA,cAAM,IAAI,QAAA,CAAA,YAAJ,CACJ,aAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,wBADZ,EAEJ;AACE,UAAA,SAAS,EAAE,UADb;AAEE,UAAA,OAAO,EAAE,KAAK,CAAC,gBAAN,CAAuB;AAFlC,SAFI,EAMJ,KANI,CAAN;AAQD,OA3Ba,CA6Bd;;;AACA,YAAM,KAAN;AACD;AACF;;AA9XkB;;AAArB,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Resolver = exports.ResolvedFile = void 0;\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst resolve_1 = __importDefault(require(\"resolve\"));\nconst source_names_1 = require(\"../../utils/source-names\");\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nconst hash_1 = require(\"../util/hash\");\nconst NODE_MODULES = \"node_modules\";\nclass ResolvedFile {\n    constructor(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion) {\n        this.sourceName = sourceName;\n        this.absolutePath = absolutePath;\n        this.content = content;\n        this.contentHash = contentHash;\n        this.lastModificationDate = lastModificationDate;\n        errors_1.assertHardhatInvariant((libraryName === undefined && libraryVersion === undefined) ||\n            (libraryName !== undefined && libraryVersion !== undefined), \"Libraries should have both name and version, or neither one\");\n        if (libraryName !== undefined && libraryVersion !== undefined) {\n            this.library = {\n                name: libraryName,\n                version: libraryVersion,\n            };\n        }\n    }\n    getVersionedName() {\n        return (this.sourceName +\n            (this.library !== undefined ? `@v${this.library.version}` : \"\"));\n    }\n}\nexports.ResolvedFile = ResolvedFile;\nclass Resolver {\n    constructor(_projectRoot, _parser, _readFile) {\n        this._projectRoot = _projectRoot;\n        this._parser = _parser;\n        this._readFile = _readFile;\n    }\n    /**\n     * Resolves a source name into a ResolvedFile.\n     *\n     * @param sourceName The source name as it would be provided to solc.\n     */\n    async resolveSourceName(sourceName) {\n        source_names_1.validateSourceNameFormat(sourceName);\n        if (await source_names_1.isLocalSourceName(this._projectRoot, sourceName)) {\n            return this._resolveLocalSourceName(sourceName);\n        }\n        return this._resolveLibrarySourceName(sourceName);\n    }\n    /**\n     * Resolves an import from an already resolved file.\n     * @param from The file were the import statement is present.\n     * @param imported The path in the import statement.\n     */\n    async resolveImport(from, imported) {\n        const scheme = this._getUriScheme(imported);\n        if (scheme !== undefined) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n                from: from.sourceName,\n                imported,\n                protocol: scheme,\n            });\n        }\n        if (source_names_1.replaceBackslashes(imported) !== imported) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n                from: from.sourceName,\n                imported,\n            });\n        }\n        if (source_names_1.isAbsolutePathSourceName(imported)) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n                from: from.sourceName,\n                imported,\n            });\n        }\n        try {\n            if (!this._isRelativeImport(imported)) {\n                return await this.resolveSourceName(source_names_1.normalizeSourceName(imported));\n            }\n            const sourceName = await this._relativeImportToSourceName(from, imported);\n            // We have this special case here, because otherwise local relative\n            // imports can be treated as library imports. For example if\n            // `contracts/c.sol` imports `../non-existent/a.sol`\n            if (from.library === undefined &&\n                !this._isRelativeImportToLibrary(from, imported)) {\n                return await this._resolveLocalSourceName(sourceName);\n            }\n            return await this.resolveSourceName(sourceName);\n        }\n        catch (error) {\n            if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND) ||\n                errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND)) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND, {\n                    imported,\n                    from: from.sourceName,\n                }, error);\n            }\n            if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING)) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING, {\n                    imported,\n                    from: from.sourceName,\n                }, error);\n            }\n            if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED)) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED, {\n                    library: error.messageArguments.library,\n                    from: from.sourceName,\n                }, error);\n            }\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n    }\n    async _resolveLocalSourceName(sourceName) {\n        await this._validateSourceNameExistenceAndCasing(this._projectRoot, sourceName, false);\n        const absolutePath = path_1.default.join(this._projectRoot, sourceName);\n        return this._resolveFile(sourceName, absolutePath);\n    }\n    async _resolveLibrarySourceName(sourceName) {\n        const libraryName = this._getLibraryName(sourceName);\n        let packageJsonPath;\n        try {\n            packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(path_1.default.join(libraryName, \"package.json\"));\n        }\n        catch (error) {\n            // if the project is using a dependency from hardhat itself but it can't\n            // be found, this means that a global installation is being used, so we\n            // resolve the dependency relative to this file\n            if (libraryName === \"hardhat\") {\n                const hardhatCoreDir = path_1.default.join(__dirname, \"..\", \"..\");\n                packageJsonPath = path_1.default.join(hardhatCoreDir, \"package.json\");\n            }\n            else {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED, {\n                    library: libraryName,\n                }, error);\n            }\n        }\n        let nodeModulesPath = path_1.default.dirname(path_1.default.dirname(packageJsonPath));\n        if (this._isScopedPackage(sourceName)) {\n            nodeModulesPath = path_1.default.dirname(nodeModulesPath);\n        }\n        await this._validateSourceNameExistenceAndCasing(nodeModulesPath, sourceName, true);\n        const packageInfo = await fs_extra_1.default.readJson(packageJsonPath);\n        const libraryVersion = packageInfo.version;\n        return this._resolveFile(sourceName, \n        // We resolve to the real path here, as we may be resolving a linked library\n        await fs_extra_1.default.realpath(path_1.default.join(nodeModulesPath, sourceName)), libraryName, libraryVersion);\n    }\n    async _relativeImportToSourceName(from, imported) {\n        // This is a special case, were we turn relative imports from local files\n        // into library imports if necessary. The reason for this is that many\n        // users just do `import \"../node_modules/lib/a.sol\";`.\n        if (this._isRelativeImportToLibrary(from, imported)) {\n            return this._relativeImportToLibraryToSourceName(from, imported);\n        }\n        const sourceName = source_names_1.normalizeSourceName(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n        // If the file with the import is local, and the normalized version\n        // starts with ../ means that it's trying to get outside of the project.\n        if (from.library === undefined && sourceName.startsWith(\"../\")) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT, { from: from.sourceName, imported });\n        }\n        if (from.library !== undefined &&\n            !this._isInsideSameDir(from.sourceName, sourceName)) {\n            // If the file is being imported from a library, this means that it's\n            // trying to reach another one.\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n                from: from.sourceName,\n                imported,\n            });\n        }\n        return sourceName;\n    }\n    async _resolveFile(sourceName, absolutePath, libraryName, libraryVersion) {\n        const rawContent = await this._readFile(absolutePath);\n        const stats = await fs_extra_1.default.stat(absolutePath);\n        const lastModificationDate = new Date(stats.ctime);\n        const contentHash = hash_1.createNonCryptographicHashBasedIdentifier(Buffer.from(rawContent)).toString(\"hex\");\n        const parsedContent = this._parser.parse(rawContent, absolutePath, contentHash);\n        const content = Object.assign({ rawContent }, parsedContent);\n        return new ResolvedFile(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion);\n    }\n    _isRelativeImport(imported) {\n        return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n    }\n    _resolveNodeModulesFileFromProjectRoot(fileName) {\n        return resolve_1.default.sync(fileName, {\n            basedir: this._projectRoot,\n            preserveSymlinks: true,\n        });\n    }\n    _getLibraryName(sourceName) {\n        let endIndex;\n        if (this._isScopedPackage(sourceName)) {\n            endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n        }\n        else if (sourceName.indexOf(\"/\") === -1) {\n            endIndex = sourceName.length;\n        }\n        else {\n            endIndex = sourceName.indexOf(\"/\");\n        }\n        return sourceName.slice(0, endIndex);\n    }\n    _getUriScheme(s) {\n        const re = /([a-zA-Z]+):\\/\\//;\n        const match = re.exec(s);\n        if (match === null) {\n            return undefined;\n        }\n        return match[1];\n    }\n    _isInsideSameDir(sourceNameInDir, sourceNameToTest) {\n        const firstSlash = sourceNameInDir.indexOf(\"/\");\n        const dir = firstSlash !== -1\n            ? sourceNameInDir.substring(0, firstSlash)\n            : sourceNameInDir;\n        return sourceNameToTest.startsWith(dir);\n    }\n    _isScopedPackage(packageOrPackageFile) {\n        return packageOrPackageFile.startsWith(\"@\");\n    }\n    _isRelativeImportToLibrary(from, imported) {\n        return (this._isRelativeImport(imported) &&\n            from.library === undefined &&\n            imported.includes(`${NODE_MODULES}/`));\n    }\n    _relativeImportToLibraryToSourceName(from, imported) {\n        const sourceName = source_names_1.normalizeSourceName(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n        const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n        return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n    }\n    async _validateSourceNameExistenceAndCasing(fromDir, sourceName, isLibrary) {\n        try {\n            await source_names_1.validateSourceNameExistenceAndCasing(fromDir, sourceName);\n        }\n        catch (error) {\n            if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n                throw new errors_1.HardhatError(isLibrary\n                    ? errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n                    : errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND, { file: sourceName }, error);\n            }\n            if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING)) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING, {\n                    incorrect: sourceName,\n                    correct: error.messageArguments.correct,\n                }, error);\n            }\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n    }\n}\nexports.Resolver = Resolver;\n//# sourceMappingURL=resolver.js.map"]},"metadata":{},"sourceType":"script"}