{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst constants_1 = require(\"../internal/constants\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst construction_1 = require(\"../internal/core/providers/construction\");\n\nconst util_1 = require(\"../internal/core/providers/util\");\n\nconst server_1 = require(\"../internal/hardhat-network/jsonrpc/server\");\n\nconst reporter_1 = require(\"../internal/sentry/reporter\");\n\nconst task_names_1 = require(\"./task-names\");\n\nconst watch_1 = require(\"./utils/watch\");\n\nconst log = debug_1.default(\"hardhat:core:tasks:node\");\n\nfunction logHardhatNetworkAccounts(networkConfig) {\n  if (networkConfig.accounts === undefined) {\n    return;\n  }\n\n  const {\n    BN,\n    bufferToHex,\n    privateToAddress,\n    toBuffer\n  } = require(\"ethereumjs-util\");\n\n  console.log(\"Accounts\");\n  console.log(\"========\");\n  const accounts = util_1.normalizeHardhatNetworkAccountsConfig(networkConfig.accounts);\n\n  for (const [index, account] of accounts.entries()) {\n    const address = bufferToHex(privateToAddress(toBuffer(account.privateKey)));\n    const privateKey = bufferToHex(toBuffer(account.privateKey));\n    const balance = new BN(account.balance).div(new BN(10).pow(new BN(18))).toString(10);\n    console.log(`Account #${index}: ${address} (${balance} ETH)\nPrivate Key: ${privateKey}\n`);\n  }\n}\n\nconfig_env_1.subtask(task_names_1.TASK_NODE_GET_PROVIDER).addOptionalParam(\"forkUrl\", undefined, undefined, config_env_1.types.string).addOptionalParam(\"forkBlockNumber\", undefined, undefined, config_env_1.types.int).setAction(async ({\n  forkBlockNumber: forkBlockNumberParam,\n  forkUrl: forkUrlParam\n}, {\n  artifacts,\n  config,\n  network\n}) => {\n  var _a, _b;\n\n  let provider = network.provider;\n\n  if (network.name !== constants_1.HARDHAT_NETWORK_NAME) {\n    const networkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n    log(`Creating hardhat provider for JSON-RPC server`);\n    provider = construction_1.createProvider(constants_1.HARDHAT_NETWORK_NAME, networkConfig, config.paths, artifacts);\n  }\n\n  const hardhatNetworkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n  const forkUrlConfig = (_a = hardhatNetworkConfig.forking) === null || _a === void 0 ? void 0 : _a.url;\n  const forkBlockNumberConfig = (_b = hardhatNetworkConfig.forking) === null || _b === void 0 ? void 0 : _b.blockNumber;\n  const forkUrl = forkUrlParam !== null && forkUrlParam !== void 0 ? forkUrlParam : forkUrlConfig;\n  const forkBlockNumber = forkBlockNumberParam !== null && forkBlockNumberParam !== void 0 ? forkBlockNumberParam : forkBlockNumberConfig; // we throw an error if the user specified a forkBlockNumber but not a\n  // forkUrl\n\n  if (forkBlockNumber !== undefined && forkUrl === undefined) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.NODE_FORK_BLOCK_NUMBER_WITHOUT_URL);\n  } // if the url or the block is different to the one in the configuration,\n  // we use hardhat_reset to set the fork\n\n\n  if (forkUrl !== forkUrlConfig || forkBlockNumber !== forkBlockNumberConfig) {\n    await provider.request({\n      method: \"hardhat_reset\",\n      params: [{\n        forking: {\n          jsonRpcUrl: forkUrl,\n          blockNumber: forkBlockNumber\n        }\n      }]\n    });\n  } // enable logging\n\n\n  await provider.request({\n    method: \"hardhat_setLoggingEnabled\",\n    params: [true]\n  });\n  return provider;\n});\nconfig_env_1.subtask(task_names_1.TASK_NODE_CREATE_SERVER).addParam(\"hostname\", undefined, undefined, config_env_1.types.string).addParam(\"port\", undefined, undefined, config_env_1.types.int).addParam(\"provider\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  hostname,\n  port,\n  provider\n}) => {\n  const serverConfig = {\n    hostname,\n    port,\n    provider\n  };\n  const server = new server_1.JsonRpcServer(serverConfig);\n  return server;\n});\n/**\n * This task will be called when the server was successfully created, but it's\n * not ready for receiving requests yet.\n */\n\nconfig_env_1.subtask(task_names_1.TASK_NODE_SERVER_CREATED).addParam(\"hostname\", undefined, undefined, config_env_1.types.string).addParam(\"port\", undefined, undefined, config_env_1.types.int).addParam(\"provider\", undefined, undefined, config_env_1.types.any).addParam(\"server\", undefined, undefined, config_env_1.types.any).setAction(async ({}) => {// this task is meant to be overriden by plugin writers\n});\n/**\n * This subtask will be run when the server is ready to accept requests\n */\n\nconfig_env_1.subtask(task_names_1.TASK_NODE_SERVER_READY).addParam(\"address\", undefined, undefined, config_env_1.types.string).addParam(\"port\", undefined, undefined, config_env_1.types.int).addParam(\"provider\", undefined, undefined, config_env_1.types.any).addParam(\"server\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  address,\n  port\n}, {\n  config\n}) => {\n  console.log(chalk_1.default.green(`Started HTTP and WebSocket JSON-RPC server at http://${address}:${port}/`));\n  console.log();\n  const networkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n  logHardhatNetworkAccounts(networkConfig);\n});\nconfig_env_1.task(task_names_1.TASK_NODE, \"Starts a JSON-RPC server on top of Hardhat Network\").addOptionalParam(\"hostname\", \"The host to which to bind to for new connections (Defaults to 127.0.0.1 running locally, and 0.0.0.0 in Docker)\", undefined, config_env_1.types.string).addOptionalParam(\"port\", \"The port on which to listen for new connections\", 8545, config_env_1.types.int).addOptionalParam(\"fork\", \"The URL of the JSON-RPC server to fork from\", undefined, config_env_1.types.string).addOptionalParam(\"forkBlockNumber\", \"The block number to fork from\", undefined, config_env_1.types.int).setAction(async ({\n  forkBlockNumber,\n  fork: forkUrl,\n  hostname: hostnameParam,\n  port\n}, {\n  config,\n  hardhatArguments,\n  network,\n  run\n}) => {\n  // we throw if the user specified a network argument and it's not hardhat\n  if (network.name !== constants_1.HARDHAT_NETWORK_NAME && hardhatArguments.network !== undefined) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_UNSUPPORTED_NETWORK);\n  }\n\n  try {\n    const provider = await run(task_names_1.TASK_NODE_GET_PROVIDER, {\n      forkBlockNumber,\n      forkUrl\n    }); // the default hostname is \"localhost\" unless we are inside a docker\n    // container, in that case we use \"0.0.0.0\"\n\n    let hostname;\n\n    if (hostnameParam !== undefined) {\n      hostname = hostnameParam;\n    } else {\n      const insideDocker = fs_extra_1.default.existsSync(\"/.dockerenv\");\n\n      if (insideDocker) {\n        hostname = \"0.0.0.0\";\n      } else {\n        hostname = \"localhost\";\n      }\n    }\n\n    const server = await run(task_names_1.TASK_NODE_CREATE_SERVER, {\n      hostname,\n      port,\n      provider\n    });\n    await run(task_names_1.TASK_NODE_SERVER_CREATED, {\n      hostname,\n      port,\n      provider,\n      server\n    });\n    const {\n      port: actualPort,\n      address\n    } = await server.listen();\n\n    try {\n      await watch_1.watchCompilerOutput(provider, config.paths);\n    } catch (error) {\n      console.warn(chalk_1.default.yellow(\"There was a problem watching the compiler output, changes in the contracts won't be reflected in the Hardhat Network. Run Hardhat with --verbose to learn more.\"));\n      log(\"Compilation output can't be watched. Please report this to help us improve Hardhat.\\n\", error);\n      reporter_1.Reporter.reportError(error);\n    }\n\n    await run(task_names_1.TASK_NODE_SERVER_READY, {\n      address,\n      port: actualPort,\n      provider,\n      server\n    });\n    await server.waitUntilClosed();\n  } catch (error) {\n    if (errors_1.HardhatError.isHardhatError(error)) {\n      throw error;\n    }\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_SERVER_ERROR, {\n      error: error.message\n    }, error);\n  }\n});","map":{"version":3,"sources":["../src/builtin-tasks/node.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chalk_1 = __importDefault(require(\"chalk\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst constants_1 = require(\"../internal/constants\");\nconst config_env_1 = require(\"../internal/core/config/config-env\");\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\nconst construction_1 = require(\"../internal/core/providers/construction\");\nconst util_1 = require(\"../internal/core/providers/util\");\nconst server_1 = require(\"../internal/hardhat-network/jsonrpc/server\");\nconst reporter_1 = require(\"../internal/sentry/reporter\");\nconst task_names_1 = require(\"./task-names\");\nconst watch_1 = require(\"./utils/watch\");\nconst log = debug_1.default(\"hardhat:core:tasks:node\");\nfunction logHardhatNetworkAccounts(networkConfig) {\n    if (networkConfig.accounts === undefined) {\n        return;\n    }\n    const { BN, bufferToHex, privateToAddress, toBuffer } = require(\"ethereumjs-util\");\n    console.log(\"Accounts\");\n    console.log(\"========\");\n    const accounts = util_1.normalizeHardhatNetworkAccountsConfig(networkConfig.accounts);\n    for (const [index, account] of accounts.entries()) {\n        const address = bufferToHex(privateToAddress(toBuffer(account.privateKey)));\n        const privateKey = bufferToHex(toBuffer(account.privateKey));\n        const balance = new BN(account.balance)\n            .div(new BN(10).pow(new BN(18)))\n            .toString(10);\n        console.log(`Account #${index}: ${address} (${balance} ETH)\nPrivate Key: ${privateKey}\n`);\n    }\n}\nconfig_env_1.subtask(task_names_1.TASK_NODE_GET_PROVIDER)\n    .addOptionalParam(\"forkUrl\", undefined, undefined, config_env_1.types.string)\n    .addOptionalParam(\"forkBlockNumber\", undefined, undefined, config_env_1.types.int)\n    .setAction(async ({ forkBlockNumber: forkBlockNumberParam, forkUrl: forkUrlParam, }, { artifacts, config, network }) => {\n    var _a, _b;\n    let provider = network.provider;\n    if (network.name !== constants_1.HARDHAT_NETWORK_NAME) {\n        const networkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n        log(`Creating hardhat provider for JSON-RPC server`);\n        provider = construction_1.createProvider(constants_1.HARDHAT_NETWORK_NAME, networkConfig, config.paths, artifacts);\n    }\n    const hardhatNetworkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n    const forkUrlConfig = (_a = hardhatNetworkConfig.forking) === null || _a === void 0 ? void 0 : _a.url;\n    const forkBlockNumberConfig = (_b = hardhatNetworkConfig.forking) === null || _b === void 0 ? void 0 : _b.blockNumber;\n    const forkUrl = forkUrlParam !== null && forkUrlParam !== void 0 ? forkUrlParam : forkUrlConfig;\n    const forkBlockNumber = forkBlockNumberParam !== null && forkBlockNumberParam !== void 0 ? forkBlockNumberParam : forkBlockNumberConfig;\n    // we throw an error if the user specified a forkBlockNumber but not a\n    // forkUrl\n    if (forkBlockNumber !== undefined && forkUrl === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.NODE_FORK_BLOCK_NUMBER_WITHOUT_URL);\n    }\n    // if the url or the block is different to the one in the configuration,\n    // we use hardhat_reset to set the fork\n    if (forkUrl !== forkUrlConfig ||\n        forkBlockNumber !== forkBlockNumberConfig) {\n        await provider.request({\n            method: \"hardhat_reset\",\n            params: [\n                {\n                    forking: {\n                        jsonRpcUrl: forkUrl,\n                        blockNumber: forkBlockNumber,\n                    },\n                },\n            ],\n        });\n    }\n    // enable logging\n    await provider.request({\n        method: \"hardhat_setLoggingEnabled\",\n        params: [true],\n    });\n    return provider;\n});\nconfig_env_1.subtask(task_names_1.TASK_NODE_CREATE_SERVER)\n    .addParam(\"hostname\", undefined, undefined, config_env_1.types.string)\n    .addParam(\"port\", undefined, undefined, config_env_1.types.int)\n    .addParam(\"provider\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ hostname, port, provider, }) => {\n    const serverConfig = {\n        hostname,\n        port,\n        provider,\n    };\n    const server = new server_1.JsonRpcServer(serverConfig);\n    return server;\n});\n/**\n * This task will be called when the server was successfully created, but it's\n * not ready for receiving requests yet.\n */\nconfig_env_1.subtask(task_names_1.TASK_NODE_SERVER_CREATED)\n    .addParam(\"hostname\", undefined, undefined, config_env_1.types.string)\n    .addParam(\"port\", undefined, undefined, config_env_1.types.int)\n    .addParam(\"provider\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"server\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({}) => {\n    // this task is meant to be overriden by plugin writers\n});\n/**\n * This subtask will be run when the server is ready to accept requests\n */\nconfig_env_1.subtask(task_names_1.TASK_NODE_SERVER_READY)\n    .addParam(\"address\", undefined, undefined, config_env_1.types.string)\n    .addParam(\"port\", undefined, undefined, config_env_1.types.int)\n    .addParam(\"provider\", undefined, undefined, config_env_1.types.any)\n    .addParam(\"server\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ address, port, }, { config }) => {\n    console.log(chalk_1.default.green(`Started HTTP and WebSocket JSON-RPC server at http://${address}:${port}/`));\n    console.log();\n    const networkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n    logHardhatNetworkAccounts(networkConfig);\n});\nconfig_env_1.task(task_names_1.TASK_NODE, \"Starts a JSON-RPC server on top of Hardhat Network\")\n    .addOptionalParam(\"hostname\", \"The host to which to bind to for new connections (Defaults to 127.0.0.1 running locally, and 0.0.0.0 in Docker)\", undefined, config_env_1.types.string)\n    .addOptionalParam(\"port\", \"The port on which to listen for new connections\", 8545, config_env_1.types.int)\n    .addOptionalParam(\"fork\", \"The URL of the JSON-RPC server to fork from\", undefined, config_env_1.types.string)\n    .addOptionalParam(\"forkBlockNumber\", \"The block number to fork from\", undefined, config_env_1.types.int)\n    .setAction(async ({ forkBlockNumber, fork: forkUrl, hostname: hostnameParam, port, }, { config, hardhatArguments, network, run }) => {\n    // we throw if the user specified a network argument and it's not hardhat\n    if (network.name !== constants_1.HARDHAT_NETWORK_NAME &&\n        hardhatArguments.network !== undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_UNSUPPORTED_NETWORK);\n    }\n    try {\n        const provider = await run(task_names_1.TASK_NODE_GET_PROVIDER, {\n            forkBlockNumber,\n            forkUrl,\n        });\n        // the default hostname is \"localhost\" unless we are inside a docker\n        // container, in that case we use \"0.0.0.0\"\n        let hostname;\n        if (hostnameParam !== undefined) {\n            hostname = hostnameParam;\n        }\n        else {\n            const insideDocker = fs_extra_1.default.existsSync(\"/.dockerenv\");\n            if (insideDocker) {\n                hostname = \"0.0.0.0\";\n            }\n            else {\n                hostname = \"localhost\";\n            }\n        }\n        const server = await run(task_names_1.TASK_NODE_CREATE_SERVER, {\n            hostname,\n            port,\n            provider,\n        });\n        await run(task_names_1.TASK_NODE_SERVER_CREATED, {\n            hostname,\n            port,\n            provider,\n            server,\n        });\n        const { port: actualPort, address } = await server.listen();\n        try {\n            await watch_1.watchCompilerOutput(provider, config.paths);\n        }\n        catch (error) {\n            console.warn(chalk_1.default.yellow(\"There was a problem watching the compiler output, changes in the contracts won't be reflected in the Hardhat Network. Run Hardhat with --verbose to learn more.\"));\n            log(\"Compilation output can't be watched. Please report this to help us improve Hardhat.\\n\", error);\n            reporter_1.Reporter.reportError(error);\n        }\n        await run(task_names_1.TASK_NODE_SERVER_READY, {\n            address,\n            port: actualPort,\n            provider,\n            server,\n        });\n        await server.waitUntilClosed();\n    }\n    catch (error) {\n        if (errors_1.HardhatError.isHardhatError(error)) {\n            throw error;\n        }\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_SERVER_ERROR, {\n            error: error.message,\n        }, error);\n    }\n});\n//# sourceMappingURL=node.js.map"]},"metadata":{},"sourceType":"script"}