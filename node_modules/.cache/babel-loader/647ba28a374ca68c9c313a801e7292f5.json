{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst solidity_files_cache_1 = require(\"../../builtin-tasks/utils/solidity-files-cache\");\n\nconst log = debug_1.default(\"hardhat:core:solidity:imports\");\n\nclass Parser {\n  constructor(_solidityFilesCache) {\n    this._cache = new Map();\n    this._solidityFilesCache = _solidityFilesCache !== null && _solidityFilesCache !== void 0 ? _solidityFilesCache : solidity_files_cache_1.SolidityFilesCache.createEmpty();\n  }\n\n  parse(fileContent, absolutePath, contentHash) {\n    const cacheResult = this._getFromCache(absolutePath, contentHash);\n\n    if (cacheResult !== null) {\n      return cacheResult;\n    }\n\n    let result;\n\n    try {\n      const parser = require(\"@solidity-parser/parser\");\n\n      const ast = parser.parse(fileContent, {\n        tolerant: true\n      });\n      const imports = [];\n      const versionPragmas = [];\n      parser.visit(ast, {\n        ImportDirective: node => imports.push(node.path),\n        PragmaDirective: node => {\n          if (node.name === \"solidity\") {\n            versionPragmas.push(node.value);\n          }\n        }\n      });\n      result = {\n        imports,\n        versionPragmas\n      };\n    } catch (error) {\n      log(\"Failed to parse Solidity file to extract its imports, using regex fallback\\n\", error);\n      result = {\n        imports: findImportsWithRegexps(fileContent),\n        versionPragmas: findVersionPragmasWithRegexps(fileContent)\n      };\n    }\n\n    this._cache.set(contentHash, result);\n\n    return result;\n  }\n  /**\n   * Get parsed data from the internal cache, or from the solidity files cache.\n   *\n   * Returns null if cannot find it in either one.\n   */\n\n\n  _getFromCache(absolutePath, contentHash) {\n    const internalCacheEntry = this._cache.get(contentHash);\n\n    if (internalCacheEntry !== undefined) {\n      return internalCacheEntry;\n    }\n\n    const solidityFilesCacheEntry = this._solidityFilesCache.getEntry(absolutePath);\n\n    if (solidityFilesCacheEntry === undefined) {\n      return null;\n    }\n\n    const {\n      imports,\n      versionPragmas\n    } = solidityFilesCacheEntry;\n\n    if (solidityFilesCacheEntry.contentHash !== contentHash) {\n      return null;\n    }\n\n    return {\n      imports,\n      versionPragmas\n    };\n  }\n\n}\n\nexports.Parser = Parser;\n\nfunction findImportsWithRegexps(fileContent) {\n  const importsRegexp = /import\\s+(?:(?:\"([^;]*)\"|'([^;]*)')(?:;|\\s+as\\s+[^;]*;)|.+from\\s+(?:\"(.*)\"|'(.*)');)/g;\n  let imports = [];\n  let result;\n\n  while (true) {\n    result = importsRegexp.exec(fileContent);\n\n    if (result === null) {\n      return imports;\n    }\n\n    imports = [...imports, ...result.slice(1).filter(m => m !== undefined)];\n  }\n}\n\nfunction findVersionPragmasWithRegexps(fileContent) {\n  const versionPragmasRegexp = /pragma\\s+solidity\\s+(.+?);/g;\n  let versionPragmas = [];\n  let result;\n\n  while (true) {\n    result = versionPragmasRegexp.exec(fileContent);\n\n    if (result === null) {\n      return versionPragmas;\n    }\n\n    versionPragmas = [...versionPragmas, ...result.slice(1).filter(m => m !== undefined)];\n  }\n}","map":{"version":3,"sources":["../../src/internal/solidity/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst solidity_files_cache_1 = require(\"../../builtin-tasks/utils/solidity-files-cache\");\nconst log = debug_1.default(\"hardhat:core:solidity:imports\");\nclass Parser {\n    constructor(_solidityFilesCache) {\n        this._cache = new Map();\n        this._solidityFilesCache = _solidityFilesCache !== null && _solidityFilesCache !== void 0 ? _solidityFilesCache : solidity_files_cache_1.SolidityFilesCache.createEmpty();\n    }\n    parse(fileContent, absolutePath, contentHash) {\n        const cacheResult = this._getFromCache(absolutePath, contentHash);\n        if (cacheResult !== null) {\n            return cacheResult;\n        }\n        let result;\n        try {\n            const parser = require(\"@solidity-parser/parser\");\n            const ast = parser.parse(fileContent, { tolerant: true });\n            const imports = [];\n            const versionPragmas = [];\n            parser.visit(ast, {\n                ImportDirective: (node) => imports.push(node.path),\n                PragmaDirective: (node) => {\n                    if (node.name === \"solidity\") {\n                        versionPragmas.push(node.value);\n                    }\n                },\n            });\n            result = { imports, versionPragmas };\n        }\n        catch (error) {\n            log(\"Failed to parse Solidity file to extract its imports, using regex fallback\\n\", error);\n            result = {\n                imports: findImportsWithRegexps(fileContent),\n                versionPragmas: findVersionPragmasWithRegexps(fileContent),\n            };\n        }\n        this._cache.set(contentHash, result);\n        return result;\n    }\n    /**\n     * Get parsed data from the internal cache, or from the solidity files cache.\n     *\n     * Returns null if cannot find it in either one.\n     */\n    _getFromCache(absolutePath, contentHash) {\n        const internalCacheEntry = this._cache.get(contentHash);\n        if (internalCacheEntry !== undefined) {\n            return internalCacheEntry;\n        }\n        const solidityFilesCacheEntry = this._solidityFilesCache.getEntry(absolutePath);\n        if (solidityFilesCacheEntry === undefined) {\n            return null;\n        }\n        const { imports, versionPragmas } = solidityFilesCacheEntry;\n        if (solidityFilesCacheEntry.contentHash !== contentHash) {\n            return null;\n        }\n        return { imports, versionPragmas };\n    }\n}\nexports.Parser = Parser;\nfunction findImportsWithRegexps(fileContent) {\n    const importsRegexp = /import\\s+(?:(?:\"([^;]*)\"|'([^;]*)')(?:;|\\s+as\\s+[^;]*;)|.+from\\s+(?:\"(.*)\"|'(.*)');)/g;\n    let imports = [];\n    let result;\n    while (true) {\n        result = importsRegexp.exec(fileContent);\n        if (result === null) {\n            return imports;\n        }\n        imports = [\n            ...imports,\n            ...result.slice(1).filter((m) => m !== undefined),\n        ];\n    }\n}\nfunction findVersionPragmasWithRegexps(fileContent) {\n    const versionPragmasRegexp = /pragma\\s+solidity\\s+(.+?);/g;\n    let versionPragmas = [];\n    let result;\n    while (true) {\n        result = versionPragmasRegexp.exec(fileContent);\n        if (result === null) {\n            return versionPragmas;\n        }\n        versionPragmas = [\n            ...versionPragmas,\n            ...result.slice(1).filter((m) => m !== undefined),\n        ];\n    }\n}\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"script"}