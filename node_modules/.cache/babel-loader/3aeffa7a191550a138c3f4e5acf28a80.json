{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiHelpers = void 0;\n\nconst abi = __importStar(require(\"@ethersproject/abi\"));\n\nclass AbiHelpers {\n  /**\n   * Try to compute the selector for the function/event/error\n   * with the given name and param types. Return undefined\n   * if it cannot do it. This can happen if some ParamType is\n   * not understood by @ethersproject/abi\n   */\n  static computeSelector(name, inputs) {\n    try {\n      const fragment = abi.FunctionFragment.from({\n        type: \"function\",\n        constant: true,\n        name,\n        inputs: inputs.map(i => abi.ParamType.from(i))\n      });\n      const selectorHex = abi.Interface.getSighash(fragment);\n      return Buffer.from(selectorHex.slice(2), \"hex\");\n    } catch (e) {\n      return;\n    }\n  }\n\n  static formatValues(values) {\n    return values.map(x => AbiHelpers._formatValue(x)).join(\", \");\n  }\n\n  static _formatValue(value) {\n    // print nested values as [value1, value2, ...]\n    if (Array.isArray(value)) {\n      return `[${value.map(v => AbiHelpers._formatValue(v)).join(\", \")}]`;\n    } // surround string values with quotes\n\n\n    if (typeof value === \"string\") {\n      return `\"${value}\"`;\n    }\n\n    return value.toString();\n  }\n\n}\n\nexports.AbiHelpers = AbiHelpers;","map":{"version":3,"sources":["../../src/internal/util/abi-helpers.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,oBAAA,CAAA,CAAA;;AAEA,MAAa,UAAb,CAAuB;AACrB;;;;;AAKG;AAC0B,SAAf,eAAe,CAC3B,IAD2B,EAE3B,MAF2B,EAEd;AAEb,QAAI;AACF,YAAM,QAAQ,GAAG,GAAG,CAAC,gBAAJ,CAAqB,IAArB,CAA0B;AACzC,QAAA,IAAI,EAAE,UADmC;AAEzC,QAAA,QAAQ,EAAE,IAF+B;AAGzC,QAAA,IAHyC;AAIzC,QAAA,MAAM,EAAE,MAAM,CAAC,GAAP,CAAY,CAAD,IAAO,GAAG,CAAC,SAAJ,CAAc,IAAd,CAAmB,CAAnB,CAAlB;AAJiC,OAA1B,CAAjB;AAMA,YAAM,WAAW,GAAG,GAAG,CAAC,SAAJ,CAAc,UAAd,CAAyB,QAAzB,CAApB;AAEA,aAAO,MAAM,CAAC,IAAP,CAAY,WAAW,CAAC,KAAZ,CAAkB,CAAlB,CAAZ,EAAkC,KAAlC,CAAP;AACD,KAVD,CAUE,OAAO,CAAP,EAAU;AACV;AACD;AACF;;AAEyB,SAAZ,YAAY,CAAC,MAAD,EAAc;AACtC,WAAO,MAAM,CAAC,GAAP,CAAY,CAAD,IAAO,UAAU,CAAC,YAAX,CAAwB,CAAxB,CAAlB,EAA8C,IAA9C,CAAmD,IAAnD,CAAP;AACD;;AAE0B,SAAZ,YAAY,CAAC,KAAD,EAAW;AACpC;AACA,QAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,aAAO,IAAI,KAAK,CAAC,GAAN,CAAW,CAAD,IAAO,UAAU,CAAC,YAAX,CAAwB,CAAxB,CAAjB,EAA6C,IAA7C,CAAkD,IAAlD,CAAuD,GAAlE;AACD,KAJmC,CAMpC;;;AACA,QAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,aAAO,IAAI,KAAK,GAAhB;AACD;;AAED,WAAO,KAAK,CAAC,QAAN,EAAP;AACD;;AA1CoB;;AAAvB,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbiHelpers = void 0;\nconst abi = __importStar(require(\"@ethersproject/abi\"));\nclass AbiHelpers {\n    /**\n     * Try to compute the selector for the function/event/error\n     * with the given name and param types. Return undefined\n     * if it cannot do it. This can happen if some ParamType is\n     * not understood by @ethersproject/abi\n     */\n    static computeSelector(name, inputs) {\n        try {\n            const fragment = abi.FunctionFragment.from({\n                type: \"function\",\n                constant: true,\n                name,\n                inputs: inputs.map((i) => abi.ParamType.from(i)),\n            });\n            const selectorHex = abi.Interface.getSighash(fragment);\n            return Buffer.from(selectorHex.slice(2), \"hex\");\n        }\n        catch (e) {\n            return;\n        }\n    }\n    static formatValues(values) {\n        return values.map((x) => AbiHelpers._formatValue(x)).join(\", \");\n    }\n    static _formatValue(value) {\n        // print nested values as [value1, value2, ...]\n        if (Array.isArray(value)) {\n            return `[${value.map((v) => AbiHelpers._formatValue(v)).join(\", \")}]`;\n        }\n        // surround string values with quotes\n        if (typeof value === \"string\") {\n            return `\"${value}\"`;\n        }\n        return value.toString();\n    }\n}\nexports.AbiHelpers = AbiHelpers;\n//# sourceMappingURL=abi-helpers.js.map"]},"metadata":{},"sourceType":"script"}