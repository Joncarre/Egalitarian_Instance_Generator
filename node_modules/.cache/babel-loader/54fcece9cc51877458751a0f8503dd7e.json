{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fs = __importStar(require(\"fs\"));\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst packageInfo_1 = require(\"../internal/util/packageInfo\");\n\nconst task_names_1 = require(\"./task-names\");\n\nfunction getSortedFiles(dependenciesGraph) {\n  const tsort = require(\"tsort\");\n\n  const graph = tsort();\n  const filesMap = {};\n  const resolvedFiles = dependenciesGraph.getResolvedFiles();\n  resolvedFiles.forEach(f => filesMap[f.sourceName] = f);\n\n  for (const [from, deps] of dependenciesGraph.entries()) {\n    for (const to of deps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n\n  try {\n    const topologicalSortedNames = graph.sort(); // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n\n    const withEntries = topologicalSortedNames.concat(resolvedFiles.map(f => f.sourceName));\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map(n => filesMap[n]);\n  } catch (error) {\n    if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, error);\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n}\n\nfunction getFileWithoutImports(resolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n  return resolvedFile.content.rawContent.replace(IMPORT_SOLIDITY_REGEX, \"\").trim();\n}\n\nconfig_env_1.subtask(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, \"Returns all contracts and their dependencies flattened\").addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  files\n}, {\n  run\n}) => {\n  const dependencyGraph = await run(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH, {\n    files\n  });\n  let flattened = \"\";\n\n  if (dependencyGraph.getResolvedFiles().length === 0) {\n    return flattened;\n  }\n\n  const packageJson = await packageInfo_1.getPackageJson();\n  flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n  const sortedFiles = getSortedFiles(dependencyGraph);\n\n  for (const file of sortedFiles) {\n    flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n    flattened += `\\n${getFileWithoutImports(file)}\\n`;\n  }\n\n  return flattened.trim();\n});\nconfig_env_1.subtask(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH).addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async ({\n  files\n}, {\n  run\n}) => {\n  const sourcePaths = files === undefined ? await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS) : files.map(f => fs.realpathSync(f));\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames\n  });\n  return dependencyGraph;\n});\nconfig_env_1.task(task_names_1.TASK_FLATTEN, \"Flattens and prints contracts and their dependencies\").addOptionalVariadicPositionalParam(\"files\", \"The files to flatten\", undefined, config_env_1.types.inputFile).setAction(async ({\n  files\n}, {\n  run\n}) => {\n  console.log(await run(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, {\n    files\n  }));\n});","map":{"version":3,"sources":["../src/builtin-tasks/flatten.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst config_env_1 = require(\"../internal/core/config/config-env\");\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\nconst packageInfo_1 = require(\"../internal/util/packageInfo\");\nconst task_names_1 = require(\"./task-names\");\nfunction getSortedFiles(dependenciesGraph) {\n    const tsort = require(\"tsort\");\n    const graph = tsort();\n    const filesMap = {};\n    const resolvedFiles = dependenciesGraph.getResolvedFiles();\n    resolvedFiles.forEach((f) => (filesMap[f.sourceName] = f));\n    for (const [from, deps] of dependenciesGraph.entries()) {\n        for (const to of deps) {\n            graph.add(to.sourceName, from.sourceName);\n        }\n    }\n    try {\n        const topologicalSortedNames = graph.sort();\n        // If an entry has no dependency it won't be included in the graph, so we\n        // add them and then dedup the array\n        const withEntries = topologicalSortedNames.concat(resolvedFiles.map((f) => f.sourceName));\n        const sortedNames = [...new Set(withEntries)];\n        return sortedNames.map((n) => filesMap[n]);\n    }\n    catch (error) {\n        if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, error);\n        }\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n    }\n}\nfunction getFileWithoutImports(resolvedFile) {\n    const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n    return resolvedFile.content.rawContent\n        .replace(IMPORT_SOLIDITY_REGEX, \"\")\n        .trim();\n}\nconfig_env_1.subtask(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, \"Returns all contracts and their dependencies flattened\")\n    .addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ files }, { run }) => {\n    const dependencyGraph = await run(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH, { files });\n    let flattened = \"\";\n    if (dependencyGraph.getResolvedFiles().length === 0) {\n        return flattened;\n    }\n    const packageJson = await packageInfo_1.getPackageJson();\n    flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n    const sortedFiles = getSortedFiles(dependencyGraph);\n    for (const file of sortedFiles) {\n        flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n        flattened += `\\n${getFileWithoutImports(file)}\\n`;\n    }\n    return flattened.trim();\n});\nconfig_env_1.subtask(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH)\n    .addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any)\n    .setAction(async ({ files }, { run }) => {\n    const sourcePaths = files === undefined\n        ? await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS)\n        : files.map((f) => fs.realpathSync(f));\n    const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n        sourcePaths,\n    });\n    const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, { sourceNames });\n    return dependencyGraph;\n});\nconfig_env_1.task(task_names_1.TASK_FLATTEN, \"Flattens and prints contracts and their dependencies\")\n    .addOptionalVariadicPositionalParam(\"files\", \"The files to flatten\", undefined, config_env_1.types.inputFile)\n    .setAction(async ({ files }, { run }) => {\n    console.log(await run(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, { files }));\n});\n//# sourceMappingURL=flatten.js.map"]},"metadata":{},"sourceType":"script"}