{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSolidityFilesCachePath = exports.SolidityFilesCache = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst t = __importStar(require(\"io-ts\"));\n\nconst path = __importStar(require(\"path\"));\n\nconst constants_1 = require(\"../../internal/constants\");\n\nconst log = debug_1.default(\"hardhat:core:tasks:compile:cache\");\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string)\n});\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec)\n});\n\nclass SolidityFilesCache {\n  constructor(_cache) {\n    this._cache = _cache;\n  }\n\n  static createEmpty() {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n\n  static async readFromFile(solidityFilesCachePath) {\n    let cacheRaw = {\n      _format: FORMAT_VERSION,\n      files: {}\n    };\n\n    if (fs_extra_1.default.existsSync(solidityFilesCachePath)) {\n      cacheRaw = await fs_extra_1.default.readJson(solidityFilesCachePath);\n    }\n\n    const result = CacheCodec.decode(cacheRaw);\n\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n\n    log(\"There was a problem reading the cache\");\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n\n  async removeNonExistingFiles() {\n    for (const absolutePath of Object.keys(this._cache.files)) {\n      if (!fs_extra_1.default.existsSync(absolutePath)) {\n        this.removeEntry(absolutePath);\n        continue;\n      }\n    }\n  }\n\n  async writeToFile(solidityFilesCachePath) {\n    await fs_extra_1.default.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2\n    });\n  }\n\n  addFile(absolutePath, entry) {\n    this._cache.files[absolutePath] = entry;\n  }\n\n  getEntries() {\n    return Object.values(this._cache.files);\n  }\n\n  getEntry(file) {\n    return this._cache.files[file];\n  }\n\n  removeEntry(file) {\n    delete this._cache.files[file];\n  }\n\n  hasFileChanged(absolutePath, contentHash, solcConfig) {\n    const {\n      isEqual\n    } = require(\"lodash\");\n\n    const cacheEntry = this.getEntry(absolutePath);\n\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n\n    if (solcConfig !== undefined && !isEqual(solcConfig, cacheEntry.solcConfig)) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexports.SolidityFilesCache = SolidityFilesCache;\n\nfunction getSolidityFilesCachePath(paths) {\n  return path.join(paths.cache, constants_1.SOLIDITY_FILES_CACHE_FILENAME);\n}\n\nexports.getSolidityFilesCachePath = getSolidityFilesCachePath;","map":{"version":3,"sources":["../../src/builtin-tasks/utils/solidity-files-cache.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSolidityFilesCachePath = exports.SolidityFilesCache = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst t = __importStar(require(\"io-ts\"));\nconst path = __importStar(require(\"path\"));\nconst constants_1 = require(\"../../internal/constants\");\nconst log = debug_1.default(\"hardhat:core:tasks:compile:cache\");\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\nconst CacheEntryCodec = t.type({\n    lastModificationDate: t.number,\n    contentHash: t.string,\n    sourceName: t.string,\n    solcConfig: t.any,\n    imports: t.array(t.string),\n    versionPragmas: t.array(t.string),\n    artifacts: t.array(t.string),\n});\nconst CacheCodec = t.type({\n    _format: t.string,\n    files: t.record(t.string, CacheEntryCodec),\n});\nclass SolidityFilesCache {\n    constructor(_cache) {\n        this._cache = _cache;\n    }\n    static createEmpty() {\n        return new SolidityFilesCache({\n            _format: FORMAT_VERSION,\n            files: {},\n        });\n    }\n    static async readFromFile(solidityFilesCachePath) {\n        let cacheRaw = {\n            _format: FORMAT_VERSION,\n            files: {},\n        };\n        if (fs_extra_1.default.existsSync(solidityFilesCachePath)) {\n            cacheRaw = await fs_extra_1.default.readJson(solidityFilesCachePath);\n        }\n        const result = CacheCodec.decode(cacheRaw);\n        if (result.isRight()) {\n            const solidityFilesCache = new SolidityFilesCache(result.value);\n            await solidityFilesCache.removeNonExistingFiles();\n            return solidityFilesCache;\n        }\n        log(\"There was a problem reading the cache\");\n        return new SolidityFilesCache({\n            _format: FORMAT_VERSION,\n            files: {},\n        });\n    }\n    async removeNonExistingFiles() {\n        for (const absolutePath of Object.keys(this._cache.files)) {\n            if (!fs_extra_1.default.existsSync(absolutePath)) {\n                this.removeEntry(absolutePath);\n                continue;\n            }\n        }\n    }\n    async writeToFile(solidityFilesCachePath) {\n        await fs_extra_1.default.outputJson(solidityFilesCachePath, this._cache, {\n            spaces: 2,\n        });\n    }\n    addFile(absolutePath, entry) {\n        this._cache.files[absolutePath] = entry;\n    }\n    getEntries() {\n        return Object.values(this._cache.files);\n    }\n    getEntry(file) {\n        return this._cache.files[file];\n    }\n    removeEntry(file) {\n        delete this._cache.files[file];\n    }\n    hasFileChanged(absolutePath, contentHash, solcConfig) {\n        const { isEqual } = require(\"lodash\");\n        const cacheEntry = this.getEntry(absolutePath);\n        if (cacheEntry === undefined) {\n            // new file or no cache available, assume it's new\n            return true;\n        }\n        if (cacheEntry.contentHash !== contentHash) {\n            return true;\n        }\n        if (solcConfig !== undefined &&\n            !isEqual(solcConfig, cacheEntry.solcConfig)) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.SolidityFilesCache = SolidityFilesCache;\nfunction getSolidityFilesCachePath(paths) {\n    return path.join(paths.cache, constants_1.SOLIDITY_FILES_CACHE_FILENAME);\n}\nexports.getSolidityFilesCachePath = getSolidityFilesCachePath;\n//# sourceMappingURL=solidity-files-cache.js.map"]},"metadata":{},"sourceType":"script"}