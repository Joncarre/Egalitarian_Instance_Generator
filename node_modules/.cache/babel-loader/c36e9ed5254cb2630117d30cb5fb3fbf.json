{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\n\nconst errors_1 = require(\"../../core/providers/errors\");\n\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\n\nclass JsonRpcHandler {\n  constructor(_provider) {\n    this._provider = _provider;\n\n    this.handleHttp = async (req, res) => {\n      this._setCorsHeaders(res);\n\n      if (req.method === \"OPTIONS\") {\n        this._sendEmptyResponse(res);\n\n        return;\n      }\n\n      let jsonHttpRequest;\n\n      try {\n        jsonHttpRequest = await _readJsonHttpRequest(req);\n      } catch (error) {\n        this._sendResponse(res, _handleError(error));\n\n        return;\n      }\n\n      if (Array.isArray(jsonHttpRequest)) {\n        const responses = await Promise.all(jsonHttpRequest.map(singleReq => this._handleSingleRequest(singleReq)));\n\n        this._sendResponse(res, responses);\n\n        return;\n      }\n\n      const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n\n      this._sendResponse(res, rpcResp);\n    };\n\n    this.handleWs = async ws => {\n      const subscriptions = [];\n      let isClosed = false;\n\n      const listener = payload => {\n        // Don't attempt to send a message to the websocket if we already know it is closed,\n        // or the current websocket connection isn't interested in the particular subscription.\n        if (isClosed || !subscriptions.includes(payload.subscription)) {\n          return;\n        }\n\n        try {\n          ws.send(JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload\n          }));\n        } catch (error) {\n          _handleError(error);\n        }\n      }; // Handle eth_subscribe notifications.\n\n\n      this._provider.addListener(\"notification\", listener);\n\n      ws.on(\"message\", async msg => {\n        let rpcReq;\n        let rpcResp;\n\n        try {\n          rpcReq = _readWsRequest(msg);\n\n          if (!jsonrpc_1.isValidJsonRequest(rpcReq)) {\n            throw new errors_1.InvalidRequestError(\"Invalid request\");\n          }\n\n          rpcResp = await this._handleRequest(rpcReq); // If eth_subscribe was successful, keep track of the subscription id,\n          // so we can cleanup on websocket close.\n\n          if (rpcReq.method === \"eth_subscribe\" && jsonrpc_1.isSuccessfulJsonResponse(rpcResp)) {\n            subscriptions.push(rpcResp.result);\n          }\n        } catch (error) {\n          rpcResp = _handleError(error);\n        } // Validate the RPC response.\n\n\n        if (!jsonrpc_1.isValidJsonResponse(rpcResp)) {\n          // Malformed response coming from the provider, report to user as an internal error.\n          rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n        }\n\n        if (rpcReq !== undefined) {\n          rpcResp.id = rpcReq.id;\n        }\n\n        ws.send(JSON.stringify(rpcResp));\n      });\n      ws.on(\"close\", () => {\n        // Remove eth_subscribe listener.\n        this._provider.removeListener(\"notification\", listener); // Clear any active subscriptions for the closed websocket connection.\n\n\n        isClosed = true;\n        subscriptions.forEach(async subscriptionId => {\n          await this._provider.request({\n            method: \"eth_unsubscribe\",\n            params: [subscriptionId]\n          });\n        });\n      });\n    };\n\n    this._handleRequest = async req => {\n      const result = await this._provider.request({\n        method: req.method,\n        params: req.params\n      });\n      return {\n        jsonrpc: \"2.0\",\n        id: req.id,\n        result\n      };\n    };\n  }\n\n  _sendEmptyResponse(res) {\n    res.writeHead(200);\n    res.end();\n  }\n\n  _setCorsHeaders(res) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n\n  _sendResponse(res, rpcResp) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n\n  async _handleSingleRequest(req) {\n    if (!jsonrpc_1.isValidJsonRequest(req)) {\n      return _handleError(new errors_1.InvalidRequestError(\"Invalid request\"));\n    }\n\n    const rpcReq = req;\n    let rpcResp;\n\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    } // Validate the RPC response.\n\n\n    if (!jsonrpc_1.isValidJsonResponse(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n    }\n\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n\n    return rpcResp;\n  }\n\n}\n\nexports.default = JsonRpcHandler;\n\nconst _readJsonHttpRequest = async req => {\n  let json;\n\n  try {\n    const buf = await raw_body_1.default(req);\n    const text = buf.toString();\n    json = JSON.parse(text);\n  } catch (error) {\n    throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n  }\n\n  return json;\n};\n\nconst _readWsRequest = msg => {\n  let json;\n\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n  }\n\n  return json;\n};\n\nconst _handleError = error => {\n  let txHash;\n\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  } // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n\n\n  if (!errors_1.ProviderError.isProviderError(error)) {\n    error = new errors_1.InternalError(error);\n  }\n\n  const response = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message\n    }\n  };\n\n  if (txHash !== undefined) {\n    response.error.data = {\n      txHash\n    };\n  }\n\n  return response;\n};","map":{"version":3,"sources":["../../../src/internal/hardhat-network/jsonrpc/handler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\nconst errors_1 = require(\"../../core/providers/errors\");\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\nclass JsonRpcHandler {\n    constructor(_provider) {\n        this._provider = _provider;\n        this.handleHttp = async (req, res) => {\n            this._setCorsHeaders(res);\n            if (req.method === \"OPTIONS\") {\n                this._sendEmptyResponse(res);\n                return;\n            }\n            let jsonHttpRequest;\n            try {\n                jsonHttpRequest = await _readJsonHttpRequest(req);\n            }\n            catch (error) {\n                this._sendResponse(res, _handleError(error));\n                return;\n            }\n            if (Array.isArray(jsonHttpRequest)) {\n                const responses = await Promise.all(jsonHttpRequest.map((singleReq) => this._handleSingleRequest(singleReq)));\n                this._sendResponse(res, responses);\n                return;\n            }\n            const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n            this._sendResponse(res, rpcResp);\n        };\n        this.handleWs = async (ws) => {\n            const subscriptions = [];\n            let isClosed = false;\n            const listener = (payload) => {\n                // Don't attempt to send a message to the websocket if we already know it is closed,\n                // or the current websocket connection isn't interested in the particular subscription.\n                if (isClosed || !subscriptions.includes(payload.subscription)) {\n                    return;\n                }\n                try {\n                    ws.send(JSON.stringify({\n                        jsonrpc: \"2.0\",\n                        method: \"eth_subscription\",\n                        params: payload,\n                    }));\n                }\n                catch (error) {\n                    _handleError(error);\n                }\n            };\n            // Handle eth_subscribe notifications.\n            this._provider.addListener(\"notification\", listener);\n            ws.on(\"message\", async (msg) => {\n                let rpcReq;\n                let rpcResp;\n                try {\n                    rpcReq = _readWsRequest(msg);\n                    if (!jsonrpc_1.isValidJsonRequest(rpcReq)) {\n                        throw new errors_1.InvalidRequestError(\"Invalid request\");\n                    }\n                    rpcResp = await this._handleRequest(rpcReq);\n                    // If eth_subscribe was successful, keep track of the subscription id,\n                    // so we can cleanup on websocket close.\n                    if (rpcReq.method === \"eth_subscribe\" &&\n                        jsonrpc_1.isSuccessfulJsonResponse(rpcResp)) {\n                        subscriptions.push(rpcResp.result);\n                    }\n                }\n                catch (error) {\n                    rpcResp = _handleError(error);\n                }\n                // Validate the RPC response.\n                if (!jsonrpc_1.isValidJsonResponse(rpcResp)) {\n                    // Malformed response coming from the provider, report to user as an internal error.\n                    rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n                }\n                if (rpcReq !== undefined) {\n                    rpcResp.id = rpcReq.id;\n                }\n                ws.send(JSON.stringify(rpcResp));\n            });\n            ws.on(\"close\", () => {\n                // Remove eth_subscribe listener.\n                this._provider.removeListener(\"notification\", listener);\n                // Clear any active subscriptions for the closed websocket connection.\n                isClosed = true;\n                subscriptions.forEach(async (subscriptionId) => {\n                    await this._provider.request({\n                        method: \"eth_unsubscribe\",\n                        params: [subscriptionId],\n                    });\n                });\n            });\n        };\n        this._handleRequest = async (req) => {\n            const result = await this._provider.request({\n                method: req.method,\n                params: req.params,\n            });\n            return {\n                jsonrpc: \"2.0\",\n                id: req.id,\n                result,\n            };\n        };\n    }\n    _sendEmptyResponse(res) {\n        res.writeHead(200);\n        res.end();\n    }\n    _setCorsHeaders(res) {\n        res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        res.setHeader(\"Access-Control-Request-Method\", \"*\");\n        res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n        res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n    }\n    _sendResponse(res, rpcResp) {\n        res.statusCode = 200;\n        res.setHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify(rpcResp));\n    }\n    async _handleSingleRequest(req) {\n        if (!jsonrpc_1.isValidJsonRequest(req)) {\n            return _handleError(new errors_1.InvalidRequestError(\"Invalid request\"));\n        }\n        const rpcReq = req;\n        let rpcResp;\n        try {\n            rpcResp = await this._handleRequest(rpcReq);\n        }\n        catch (error) {\n            rpcResp = _handleError(error);\n        }\n        // Validate the RPC response.\n        if (!jsonrpc_1.isValidJsonResponse(rpcResp)) {\n            // Malformed response coming from the provider, report to user as an internal error.\n            rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n        }\n        if (rpcReq !== undefined) {\n            rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n        }\n        return rpcResp;\n    }\n}\nexports.default = JsonRpcHandler;\nconst _readJsonHttpRequest = async (req) => {\n    let json;\n    try {\n        const buf = await raw_body_1.default(req);\n        const text = buf.toString();\n        json = JSON.parse(text);\n    }\n    catch (error) {\n        throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n    return json;\n};\nconst _readWsRequest = (msg) => {\n    let json;\n    try {\n        json = JSON.parse(msg);\n    }\n    catch (error) {\n        throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n    return json;\n};\nconst _handleError = (error) => {\n    let txHash;\n    if (error.transactionHash !== undefined) {\n        txHash = error.transactionHash;\n    }\n    // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n    if (!errors_1.ProviderError.isProviderError(error)) {\n        error = new errors_1.InternalError(error);\n    }\n    const response = {\n        jsonrpc: \"2.0\",\n        id: null,\n        error: {\n            code: error.code,\n            message: error.message,\n        },\n    };\n    if (txHash !== undefined) {\n        response.error.data = {\n            txHash,\n        };\n    }\n    return response;\n};\n//# sourceMappingURL=handler.js.map"]},"metadata":{},"sourceType":"script"}