{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst constants_1 = require(\"../internal/constants\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst typescript_support_1 = require(\"../internal/core/typescript-support\");\n\nconst disk_cache_1 = require(\"../internal/hardhat-network/provider/utils/disk-cache\");\n\nconst fork_recomendations_banner_1 = require(\"../internal/hardhat-network/provider/utils/fork-recomendations-banner\");\n\nconst glob_1 = require(\"../internal/util/glob\");\n\nconst strings_1 = require(\"../internal/util/strings\");\n\nconst task_names_1 = require(\"./task-names\");\n\nconfig_env_1.subtask(task_names_1.TASK_TEST_GET_TEST_FILES).addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).setAction(async ({\n  testFiles\n}, {\n  config\n}) => {\n  if (testFiles.length !== 0) {\n    return testFiles;\n  }\n\n  const jsFiles = await glob_1.glob(path_1.default.join(config.paths.tests, \"**/*.js\"));\n\n  if (!typescript_support_1.isRunningWithTypescript(config)) {\n    return jsFiles;\n  }\n\n  const tsFiles = await glob_1.glob(path_1.default.join(config.paths.tests, \"**/*.ts\"));\n  return [...jsFiles, ...tsFiles];\n});\nconfig_env_1.subtask(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT, async () => {});\nconfig_env_1.subtask(task_names_1.TASK_TEST_RUN_MOCHA_TESTS).addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).setAction(async ({\n  testFiles\n}, {\n  config\n}) => {\n  const {\n    default: Mocha\n  } = await Promise.resolve().then(() => __importStar(require(\"mocha\")));\n  const mocha = new Mocha(config.mocha);\n  testFiles.forEach(file => mocha.addFile(file));\n  const testFailures = await new Promise(resolve => {\n    mocha.run(resolve);\n  });\n  return testFailures;\n});\nconfig_env_1.subtask(task_names_1.TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS).setAction(async (_, {\n  config,\n  network\n}) => {\n  if (network.name !== constants_1.HARDHAT_NETWORK_NAME) {\n    return;\n  }\n\n  const forkCache = disk_cache_1.getForkCacheDirPath(config.paths);\n  await fork_recomendations_banner_1.showForkRecommendationsBannerIfNecessary(network.config, forkCache);\n});\nconfig_env_1.task(task_names_1.TASK_TEST, \"Runs mocha tests\").addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).addFlag(\"noCompile\", \"Don't compile before running this task\").setAction(async ({\n  testFiles,\n  noCompile\n}, {\n  run,\n  network\n}) => {\n  if (!noCompile) {\n    await run(task_names_1.TASK_COMPILE, {\n      quiet: true\n    });\n  }\n\n  const files = await run(task_names_1.TASK_TEST_GET_TEST_FILES, {\n    testFiles\n  });\n  await run(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT);\n  await run(task_names_1.TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS);\n  const testFailures = await run(task_names_1.TASK_TEST_RUN_MOCHA_TESTS, {\n    testFiles: files\n  });\n\n  if (network.name === constants_1.HARDHAT_NETWORK_NAME) {\n    const stackTracesFailures = await network.provider.send(\"hardhat_getStackTraceFailuresCount\");\n\n    if (stackTracesFailures !== 0) {\n      console.warn(chalk_1.default.yellow(`Failed to generate ${stackTracesFailures} ${strings_1.pluralize(stackTracesFailures, \"stack trace\")}. Run Hardhat with --verbose to learn more.`));\n    }\n  }\n\n  process.exitCode = testFailures;\n  return testFailures;\n});","map":{"version":3,"sources":["../src/builtin-tasks/test.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chalk_1 = __importDefault(require(\"chalk\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst constants_1 = require(\"../internal/constants\");\nconst config_env_1 = require(\"../internal/core/config/config-env\");\nconst typescript_support_1 = require(\"../internal/core/typescript-support\");\nconst disk_cache_1 = require(\"../internal/hardhat-network/provider/utils/disk-cache\");\nconst fork_recomendations_banner_1 = require(\"../internal/hardhat-network/provider/utils/fork-recomendations-banner\");\nconst glob_1 = require(\"../internal/util/glob\");\nconst strings_1 = require(\"../internal/util/strings\");\nconst task_names_1 = require(\"./task-names\");\nconfig_env_1.subtask(task_names_1.TASK_TEST_GET_TEST_FILES)\n    .addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", [])\n    .setAction(async ({ testFiles }, { config }) => {\n    if (testFiles.length !== 0) {\n        return testFiles;\n    }\n    const jsFiles = await glob_1.glob(path_1.default.join(config.paths.tests, \"**/*.js\"));\n    if (!typescript_support_1.isRunningWithTypescript(config)) {\n        return jsFiles;\n    }\n    const tsFiles = await glob_1.glob(path_1.default.join(config.paths.tests, \"**/*.ts\"));\n    return [...jsFiles, ...tsFiles];\n});\nconfig_env_1.subtask(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT, async () => { });\nconfig_env_1.subtask(task_names_1.TASK_TEST_RUN_MOCHA_TESTS)\n    .addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", [])\n    .setAction(async ({ testFiles }, { config }) => {\n    const { default: Mocha } = await Promise.resolve().then(() => __importStar(require(\"mocha\")));\n    const mocha = new Mocha(config.mocha);\n    testFiles.forEach((file) => mocha.addFile(file));\n    const testFailures = await new Promise((resolve) => {\n        mocha.run(resolve);\n    });\n    return testFailures;\n});\nconfig_env_1.subtask(task_names_1.TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS).setAction(async (_, { config, network }) => {\n    if (network.name !== constants_1.HARDHAT_NETWORK_NAME) {\n        return;\n    }\n    const forkCache = disk_cache_1.getForkCacheDirPath(config.paths);\n    await fork_recomendations_banner_1.showForkRecommendationsBannerIfNecessary(network.config, forkCache);\n});\nconfig_env_1.task(task_names_1.TASK_TEST, \"Runs mocha tests\")\n    .addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", [])\n    .addFlag(\"noCompile\", \"Don't compile before running this task\")\n    .setAction(async ({ testFiles, noCompile, }, { run, network }) => {\n    if (!noCompile) {\n        await run(task_names_1.TASK_COMPILE, { quiet: true });\n    }\n    const files = await run(task_names_1.TASK_TEST_GET_TEST_FILES, { testFiles });\n    await run(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT);\n    await run(task_names_1.TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS);\n    const testFailures = await run(task_names_1.TASK_TEST_RUN_MOCHA_TESTS, {\n        testFiles: files,\n    });\n    if (network.name === constants_1.HARDHAT_NETWORK_NAME) {\n        const stackTracesFailures = await network.provider.send(\"hardhat_getStackTraceFailuresCount\");\n        if (stackTracesFailures !== 0) {\n            console.warn(chalk_1.default.yellow(`Failed to generate ${stackTracesFailures} ${strings_1.pluralize(stackTracesFailures, \"stack trace\")}. Run Hardhat with --verbose to learn more.`));\n        }\n    }\n    process.exitCode = testFailures;\n    return testFailures;\n});\n//# sourceMappingURL=test.js.map"]},"metadata":{},"sourceType":"script"}