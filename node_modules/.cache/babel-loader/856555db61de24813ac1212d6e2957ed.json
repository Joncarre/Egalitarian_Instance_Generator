{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModulesLogger = void 0;\n\nconst ansi_escapes_1 = __importDefault(require(\"ansi-escapes\"));\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst errors_1 = require(\"../../../core/errors\");\n\nconst errors_2 = require(\"../../../core/providers/errors\");\n\nconst wei_values_1 = require(\"../../../util/wei-values\");\n\nconst message_trace_1 = require(\"../../stack-traces/message-trace\");\n\nconst model_1 = require(\"../../stack-traces/model\");\n\nconst solidity_errors_1 = require(\"../../stack-traces/solidity-errors\");\n\nconst solidity_stack_trace_1 = require(\"../../stack-traces/solidity-stack-trace\");\n\nfunction printLine(line) {\n  console.log(line);\n}\n\nfunction replaceLastLine(newLine) {\n  process.stdout.write( // eslint-disable-next-line prefer-template\n  ansi_escapes_1.default.cursorHide + ansi_escapes_1.default.cursorPrevLine + newLine + ansi_escapes_1.default.eraseEndLine + \"\\n\" + ansi_escapes_1.default.cursorShow);\n}\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\n\n\nclass ModulesLogger {\n  constructor(_enabled, _printLine = printLine, _replaceLastLine = replaceLastLine) {\n    this._enabled = _enabled;\n    this._printLine = _printLine;\n    this._replaceLastLine = _replaceLastLine;\n    this._logs = [];\n    this._titleLength = 0;\n    this._currentIndent = 0;\n    this._emptyMinedBlocksRangeStart = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  isEnabled() {\n    return this._enabled;\n  }\n\n  setEnabled(enabled) {\n    this._enabled = enabled;\n  }\n\n  isLoggedError(err) {\n    return err instanceof solidity_errors_1.SolidityError || err instanceof errors_2.TransactionExecutionError;\n  }\n\n  logBlockFromAutomine(result, codes, txHashToHighlight) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    errors_1.assertHardhatInvariant(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n\n    this._indent(() => {\n      this._logBlockNumber(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].gasUsed.toNumber();\n          const txTrace = traces[i];\n          const code = codes[i];\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  logMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    errors_1.assertHardhatInvariant(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    const blockNumber = result.block.header.number.toNumber();\n    const isEmpty = result.block.transactions.length === 0;\n\n    this._indent(() => {\n      this.logMinedBlockNumber(blockNumber, isEmpty, block.header.baseFeePerGas);\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._indent(() => {\n        this._logBlockHash(block);\n\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].gasUsed.toNumber();\n            const txTrace = traces[i];\n            const code = codes[i];\n\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false\n            });\n\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n\n  logIntervalMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    errors_1.assertHardhatInvariant(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n\n    this._indent(() => {\n      this._logBlockHash(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].gasUsed.toNumber();\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  logSingleTransaction(tx, block, txGasUsed, txTrace, code) {\n    this._indent(() => {\n      var _a;\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = ethereumjs_util_1.bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n\n      this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n\n      this._logWithTitle(`Block #${block.header.number.toNumber()}`, ethereumjs_util_1.bufferToHex(block.hash()));\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  logCurrentlySentTransaction(tx, txGasUsed, txTrace, code, block) {\n    this._indent(() => {\n      var _a;\n\n      this._log(\"Currently sent transaction:\");\n\n      this.logEmptyLine();\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = ethereumjs_util_1.bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n\n      this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n\n      this._logWithTitle(`Block #${block.header.number.toNumber()}`, ethereumjs_util_1.bufferToHex(block.hash()));\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  logEstimateGasTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n\n      this._logTxFrom(callParams.from);\n\n      this._logTxTo(callParams.to, trace);\n\n      this._logTxValue(new ethereumjs_util_1.BN(callParams.value));\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      this._logError(error);\n    });\n  }\n\n  logCallTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n\n      this._logTxFrom(callParams.from);\n\n      this._logTxTo(callParams.to, trace);\n\n      if (callParams.value.gtn(0)) {\n        this._logTxValue(callParams.value);\n      }\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n\n  logMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (isEmpty) {\n      this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas}` : \"\"}`);\n\n      return;\n    }\n\n    this._log(`Mined block #${blockNumber}`);\n  }\n\n  logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions mined in the same block:\");\n    });\n\n    this.logEmptyLine();\n  }\n\n  logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions. More than one block had to be mined:\");\n    });\n\n    this.logEmptyLine();\n  }\n\n  logEmptyLine() {\n    this._log(\"\");\n  }\n\n  _logBaseFeePerGas(block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas}`);\n    }\n  }\n\n  printErrorMessage(errorMessage) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n\n  printFailedMethod(method) {\n    this._print(method, {\n      color: chalk_1.default.red\n    });\n  }\n  /**\n   * Print all accumulated logs\n   */\n\n\n  printLogs() {\n    const logs = this._getLogs();\n\n    if (logs.length === 0) {\n      return false;\n    }\n\n    for (const msg of logs) {\n      this._print(msg);\n    }\n\n    this._clearLogs();\n\n    return true;\n  }\n\n  printMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (this._emptyMinedBlocksRangeStart !== undefined) {\n      this._print(`Mined empty block range #${this._emptyMinedBlocksRangeStart} to #${blockNumber}`, {\n        collapseMinedBlock: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._emptyMinedBlocksRangeStart = blockNumber;\n\n      if (isEmpty) {\n        this._print(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas}` : \"\"}`, {\n          collapseMinedBlock: true\n        });\n\n        return;\n      }\n\n      this._print(`Mined block #${blockNumber}`, {\n        collapseMinedBlock: true\n      });\n    }\n  }\n\n  printMetaMaskWarning() {\n    const message = \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n\n    this._indent(() => {\n      this._print(message, {\n        color: chalk_1.default.yellow\n      });\n    });\n  }\n\n  printMethod(method) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n\n      this._print(chalk_1.default.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._startCollapsingMethod(method);\n\n      this._print(method, {\n        color: chalk_1.default.green,\n        collapsePrintedMethod: true\n      });\n    }\n  }\n\n  printMethodNotSupported(method) {\n    this._print(`${method} - Method not supported`, {\n      color: chalk_1.default.red\n    });\n  }\n\n  printEmptyLine() {\n    this._print(\"\");\n  }\n\n  printUnknownError(err) {\n    this._indent(() => {\n      this._printError(err);\n\n      this.printEmptyLine();\n\n      this._print(\"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/reportbug\");\n    });\n  }\n\n  _format(msg, {\n    color\n  } = {}) {\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n\n    if (this._currentIndent > 0) {\n      msg = msg.split(\"\\n\").map(line => \" \".repeat(this._currentIndent) + line).join(\"\\n\");\n    }\n\n    if (color !== undefined) {\n      return color(msg);\n    }\n\n    return msg;\n  }\n\n  _indent(cb, enabled = true) {\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n\n  _indentSingleLine(message) {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n\n  _log(msg, printOptions = {}) {\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n\n    if (printOptions.collapseMinedBlock !== true) {\n      this._emptyMinedBlocksRangeStart = undefined;\n    }\n\n    const formattedMessage = this._format(msg, printOptions);\n\n    this._logs.push(formattedMessage);\n  }\n\n  _logError(err) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n\n      this._log(util_1.default.inspect(err));\n    }\n  }\n\n  _logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n    highlightTxHash\n  }) {\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = ethereumjs_util_1.bufferToHex(tx.hash());\n\n    if (highlightTxHash) {\n      txHash = chalk_1.default.bold(txHash);\n    }\n\n    this._logWithTitle(\"Transaction\", txHash);\n\n    this._indent(() => {\n      var _a;\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n\n      this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n\n\n  _print(msg, printOptions = {}) {\n    if (!this._enabled) {\n      return;\n    }\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n\n    if (printOptions.collapseMinedBlock !== true) {\n      this._emptyMinedBlocksRangeStart = undefined;\n    }\n\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n\n  _printError(err) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n\n      this._print(util_1.default.inspect(err));\n    }\n  }\n\n  _logContractAndFunctionName(trace, code, {\n    printNonContractCalled = false\n  } = {}) {\n    if (trace === undefined) {\n      return;\n    }\n\n    if (message_trace_1.isPrecompileTrace(trace)) {\n      this._logWithTitle(\"Precompile call\", `<PrecompileContract ${trace.precompile}>`);\n\n      return;\n    }\n\n    if (message_trace_1.isCreateTrace(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\"Contract address\", ethereumjs_util_1.bufferToHex(trace.deployedContract));\n      }\n\n      return;\n    }\n\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n\n      return;\n    }\n\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n\n      return;\n    }\n\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n    const functionName = func === undefined ? solidity_stack_trace_1.UNRECOGNIZED_FUNCTION_NAME : func.type === model_1.ContractFunctionType.FALLBACK ? solidity_stack_trace_1.FALLBACK_FUNCTION_NAME : func.type === model_1.ContractFunctionType.RECEIVE ? solidity_stack_trace_1.RECEIVE_FUNCTION_NAME : func.name;\n\n    this._logWithTitle(\"Contract call\", `${trace.bytecode.contract.name}#${functionName}`);\n  }\n\n  _shouldCollapseMethod(method) {\n    return method === this._methodBeingCollapsed && !this._hasLogs() && this._methodCollapsedCount > 0;\n  }\n\n  _startCollapsingMethod(method) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n\n  _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  _logTxTo(to, trace) {\n    if (trace !== undefined && message_trace_1.isCreateTrace(trace)) {\n      return;\n    }\n\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n\n    const toString = ethereumjs_util_1.bufferToHex(to);\n\n    this._logWithTitle(\"To\", toString);\n  }\n\n  _logTxValue(value) {\n    this._logWithTitle(\"Value\", wei_values_1.weiToHumanReadableString(value));\n  }\n\n  _logTxFrom(from) {\n    this._logWithTitle(\"From\", ethereumjs_util_1.bufferToHex(from));\n  }\n\n  _logBlockNumber(block) {\n    this._log(`Block #${block.header.number.toNumber()}: ${ethereumjs_util_1.bufferToHex(block.hash())}`);\n  }\n\n  _logEmptyLineBetweenTransactions(currentIndex, totalTransactions) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n\n  _logBlockHash(block) {\n    this._log(`Block: ${ethereumjs_util_1.bufferToHex(block.hash())}`);\n  }\n\n  _logConsoleLogMessages(messages) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n\n      return;\n    }\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    this.logEmptyLine();\n\n    this._log(\"console.log:\");\n\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n\n  _logWithTitle(title, message) {\n    title = this._indentSingleLine(title); // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n\n    this._logs.push([title, message]);\n  }\n\n  _clearLogs() {\n    this._logs = [];\n  }\n\n  _hasLogs() {\n    return this._logs.length > 0;\n  }\n\n  _getLogs() {\n    return this._logs.map(l => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n\n      const title = `${l[0]}:`;\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n\n}\n\nexports.ModulesLogger = ModulesLogger;","map":{"version":3,"sources":["../../../../src/internal/hardhat-network/provider/modules/logger.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ModulesLogger = void 0;\nconst ansi_escapes_1 = __importDefault(require(\"ansi-escapes\"));\nconst chalk_1 = __importDefault(require(\"chalk\"));\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\nconst util_1 = __importDefault(require(\"util\"));\nconst errors_1 = require(\"../../../core/errors\");\nconst errors_2 = require(\"../../../core/providers/errors\");\nconst wei_values_1 = require(\"../../../util/wei-values\");\nconst message_trace_1 = require(\"../../stack-traces/message-trace\");\nconst model_1 = require(\"../../stack-traces/model\");\nconst solidity_errors_1 = require(\"../../stack-traces/solidity-errors\");\nconst solidity_stack_trace_1 = require(\"../../stack-traces/solidity-stack-trace\");\nfunction printLine(line) {\n    console.log(line);\n}\nfunction replaceLastLine(newLine) {\n    process.stdout.write(\n    // eslint-disable-next-line prefer-template\n    ansi_escapes_1.default.cursorHide +\n        ansi_escapes_1.default.cursorPrevLine +\n        newLine +\n        ansi_escapes_1.default.eraseEndLine +\n        \"\\n\" +\n        ansi_escapes_1.default.cursorShow);\n}\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\nclass ModulesLogger {\n    constructor(_enabled, _printLine = printLine, _replaceLastLine = replaceLastLine) {\n        this._enabled = _enabled;\n        this._printLine = _printLine;\n        this._replaceLastLine = _replaceLastLine;\n        this._logs = [];\n        this._titleLength = 0;\n        this._currentIndent = 0;\n        this._emptyMinedBlocksRangeStart = undefined;\n        this._methodCollapsedCount = 0;\n    }\n    isEnabled() {\n        return this._enabled;\n    }\n    setEnabled(enabled) {\n        this._enabled = enabled;\n    }\n    isLoggedError(err) {\n        return (err instanceof solidity_errors_1.SolidityError || err instanceof errors_2.TransactionExecutionError);\n    }\n    logBlockFromAutomine(result, codes, txHashToHighlight) {\n        const { block, blockResult, traces } = result;\n        const { results } = blockResult;\n        errors_1.assertHardhatInvariant(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n        this._indent(() => {\n            this._logBlockNumber(block);\n            this._indent(() => {\n                this._logBaseFeePerGas(block);\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    const txGasUsed = results[i].gasUsed.toNumber();\n                    const txTrace = traces[i];\n                    const code = codes[i];\n                    const highlightTxHash = tx.hash().equals(txHashToHighlight);\n                    this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n                        highlightTxHash,\n                    });\n                    this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n                }\n            });\n        });\n    }\n    logMinedBlock(result, codes) {\n        const { block, blockResult, traces } = result;\n        const { results } = blockResult;\n        errors_1.assertHardhatInvariant(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n        const blockNumber = result.block.header.number.toNumber();\n        const isEmpty = result.block.transactions.length === 0;\n        this._indent(() => {\n            this.logMinedBlockNumber(blockNumber, isEmpty, block.header.baseFeePerGas);\n            if (isEmpty) {\n                return;\n            }\n            this._indent(() => {\n                this._logBlockHash(block);\n                this._indent(() => {\n                    this._logBaseFeePerGas(block);\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        const txGasUsed = results[i].gasUsed.toNumber();\n                        const txTrace = traces[i];\n                        const code = codes[i];\n                        this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n                            highlightTxHash: false,\n                        });\n                        this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n                    }\n                });\n            });\n        });\n    }\n    logIntervalMinedBlock(result, codes) {\n        const { block, blockResult, traces } = result;\n        const { results } = blockResult;\n        errors_1.assertHardhatInvariant(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n        this._indent(() => {\n            this._logBlockHash(block);\n            this._indent(() => {\n                this._logBaseFeePerGas(block);\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    const txGasUsed = results[i].gasUsed.toNumber();\n                    const txTrace = traces[i];\n                    const code = codes[i];\n                    this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n                        highlightTxHash: false,\n                    });\n                    this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n                }\n            });\n        });\n    }\n    logSingleTransaction(tx, block, txGasUsed, txTrace, code) {\n        this._indent(() => {\n            var _a;\n            this._logContractAndFunctionName(txTrace.trace, code);\n            const txHash = ethereumjs_util_1.bufferToHex(tx.hash());\n            this._logWithTitle(\"Transaction\", txHash);\n            this._logTxFrom(tx.getSenderAddress().toBuffer());\n            this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n            this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n            this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n            this._logWithTitle(`Block #${block.header.number.toNumber()}`, ethereumjs_util_1.bufferToHex(block.hash()));\n            this._logConsoleLogMessages(txTrace.consoleLogMessages);\n            if (txTrace.error !== undefined) {\n                this._logError(txTrace.error);\n            }\n        });\n    }\n    logCurrentlySentTransaction(tx, txGasUsed, txTrace, code, block) {\n        this._indent(() => {\n            var _a;\n            this._log(\"Currently sent transaction:\");\n            this.logEmptyLine();\n            this._logContractAndFunctionName(txTrace.trace, code);\n            const txHash = ethereumjs_util_1.bufferToHex(tx.hash());\n            this._logWithTitle(\"Transaction\", txHash);\n            this._logTxFrom(tx.getSenderAddress().toBuffer());\n            this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n            this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n            this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n            this._logWithTitle(`Block #${block.header.number.toNumber()}`, ethereumjs_util_1.bufferToHex(block.hash()));\n            this._logConsoleLogMessages(txTrace.consoleLogMessages);\n            if (txTrace.error !== undefined) {\n                this._logError(txTrace.error);\n            }\n        });\n    }\n    logEstimateGasTrace(callParams, code, trace, consoleLogMessages, error) {\n        this._indent(() => {\n            this._logContractAndFunctionName(trace, code, {\n                printNonContractCalled: true,\n            });\n            this._logTxFrom(callParams.from);\n            this._logTxTo(callParams.to, trace);\n            this._logTxValue(new ethereumjs_util_1.BN(callParams.value));\n            this._logConsoleLogMessages(consoleLogMessages);\n            this._logError(error);\n        });\n    }\n    logCallTrace(callParams, code, trace, consoleLogMessages, error) {\n        this._indent(() => {\n            this._logContractAndFunctionName(trace, code, {\n                printNonContractCalled: true,\n            });\n            this._logTxFrom(callParams.from);\n            this._logTxTo(callParams.to, trace);\n            if (callParams.value.gtn(0)) {\n                this._logTxValue(callParams.value);\n            }\n            this._logConsoleLogMessages(consoleLogMessages);\n            if (error !== undefined) {\n                // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n                this._logError(error);\n            }\n        });\n    }\n    logMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n        if (isEmpty) {\n            this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas}` : \"\"}`);\n            return;\n        }\n        this._log(`Mined block #${blockNumber}`);\n    }\n    logMultipleTransactionsWarning() {\n        this._indent(() => {\n            this._log(\"There were other pending transactions mined in the same block:\");\n        });\n        this.logEmptyLine();\n    }\n    logMultipleBlocksWarning() {\n        this._indent(() => {\n            this._log(\"There were other pending transactions. More than one block had to be mined:\");\n        });\n        this.logEmptyLine();\n    }\n    logEmptyLine() {\n        this._log(\"\");\n    }\n    _logBaseFeePerGas(block) {\n        if (block.header.baseFeePerGas !== undefined) {\n            this._log(`Base fee: ${block.header.baseFeePerGas}`);\n        }\n    }\n    printErrorMessage(errorMessage) {\n        this._indent(() => {\n            this._print(errorMessage);\n        });\n    }\n    printFailedMethod(method) {\n        this._print(method, { color: chalk_1.default.red });\n    }\n    /**\n     * Print all accumulated logs\n     */\n    printLogs() {\n        const logs = this._getLogs();\n        if (logs.length === 0) {\n            return false;\n        }\n        for (const msg of logs) {\n            this._print(msg);\n        }\n        this._clearLogs();\n        return true;\n    }\n    printMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n        if (this._emptyMinedBlocksRangeStart !== undefined) {\n            this._print(`Mined empty block range #${this._emptyMinedBlocksRangeStart} to #${blockNumber}`, { collapseMinedBlock: true, replaceLastLine: true });\n        }\n        else {\n            this._emptyMinedBlocksRangeStart = blockNumber;\n            if (isEmpty) {\n                this._print(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas}` : \"\"}`, {\n                    collapseMinedBlock: true,\n                });\n                return;\n            }\n            this._print(`Mined block #${blockNumber}`, {\n                collapseMinedBlock: true,\n            });\n        }\n    }\n    printMetaMaskWarning() {\n        const message = \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n        this._indent(() => {\n            this._print(message, { color: chalk_1.default.yellow });\n        });\n    }\n    printMethod(method) {\n        if (this._shouldCollapseMethod(method)) {\n            this._methodCollapsedCount += 1;\n            this._print(chalk_1.default.green(`${method} (${this._methodCollapsedCount})`), {\n                collapsePrintedMethod: true,\n                replaceLastLine: true,\n            });\n        }\n        else {\n            this._startCollapsingMethod(method);\n            this._print(method, { color: chalk_1.default.green, collapsePrintedMethod: true });\n        }\n    }\n    printMethodNotSupported(method) {\n        this._print(`${method} - Method not supported`, { color: chalk_1.default.red });\n    }\n    printEmptyLine() {\n        this._print(\"\");\n    }\n    printUnknownError(err) {\n        this._indent(() => {\n            this._printError(err);\n            this.printEmptyLine();\n            this._print(\"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/reportbug\");\n        });\n    }\n    _format(msg, { color } = {}) {\n        if (msg === \"\") {\n            // don't indent empty lines\n            return msg;\n        }\n        if (this._currentIndent > 0) {\n            msg = msg\n                .split(\"\\n\")\n                .map((line) => \" \".repeat(this._currentIndent) + line)\n                .join(\"\\n\");\n        }\n        if (color !== undefined) {\n            return color(msg);\n        }\n        return msg;\n    }\n    _indent(cb, enabled = true) {\n        if (enabled) {\n            this._currentIndent += 2;\n        }\n        try {\n            return cb();\n        }\n        finally {\n            if (enabled) {\n                this._currentIndent -= 2;\n            }\n        }\n    }\n    _indentSingleLine(message) {\n        return \" \".repeat(this._currentIndent) + message;\n    }\n    _log(msg, printOptions = {}) {\n        if (printOptions.collapsePrintedMethod !== true) {\n            this._stopCollapsingMethod();\n        }\n        if (printOptions.collapseMinedBlock !== true) {\n            this._emptyMinedBlocksRangeStart = undefined;\n        }\n        const formattedMessage = this._format(msg, printOptions);\n        this._logs.push(formattedMessage);\n    }\n    _logError(err) {\n        if (this.isLoggedError(err)) {\n            this.logEmptyLine();\n            this._log(util_1.default.inspect(err));\n        }\n    }\n    _logTxInsideBlock(tx, txTrace, code, txGasUsed, { highlightTxHash, }) {\n        // indentAfterTransactionHash: true,\n        // printTxBlockNumber: false,\n        // startWithTxHash: true,\n        let txHash = ethereumjs_util_1.bufferToHex(tx.hash());\n        if (highlightTxHash) {\n            txHash = chalk_1.default.bold(txHash);\n        }\n        this._logWithTitle(\"Transaction\", txHash);\n        this._indent(() => {\n            var _a;\n            this._logContractAndFunctionName(txTrace.trace, code);\n            this._logTxFrom(tx.getSenderAddress().toBuffer());\n            this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n            this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n            this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n            this._logConsoleLogMessages(txTrace.consoleLogMessages);\n            if (txTrace.error !== undefined) {\n                this._logError(txTrace.error);\n            }\n        });\n    }\n    /**\n     *  This should be the only function that calls _printLine and\n     *  _replaceLastLine (except for the special console.sol case),\n     *  because it's the only function that checks if the logger\n     *  is enabled.\n     */\n    _print(msg, printOptions = {}) {\n        if (!this._enabled) {\n            return;\n        }\n        if (printOptions.collapsePrintedMethod !== true) {\n            this._stopCollapsingMethod();\n        }\n        if (printOptions.collapseMinedBlock !== true) {\n            this._emptyMinedBlocksRangeStart = undefined;\n        }\n        const formattedMessage = this._format(msg, printOptions);\n        if (printOptions.replaceLastLine === true) {\n            this._replaceLastLine(formattedMessage);\n        }\n        else {\n            this._printLine(formattedMessage);\n        }\n    }\n    _printError(err) {\n        if (this.isLoggedError(err)) {\n            this.printEmptyLine();\n            this._print(util_1.default.inspect(err));\n        }\n    }\n    _logContractAndFunctionName(trace, code, { printNonContractCalled = false, } = {}) {\n        if (trace === undefined) {\n            return;\n        }\n        if (message_trace_1.isPrecompileTrace(trace)) {\n            this._logWithTitle(\"Precompile call\", `<PrecompileContract ${trace.precompile}>`);\n            return;\n        }\n        if (message_trace_1.isCreateTrace(trace)) {\n            if (trace.bytecode === undefined) {\n                this._logWithTitle(\"Contract deployment\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n            }\n            else {\n                this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n            }\n            if (trace.deployedContract !== undefined && trace.error === undefined) {\n                this._logWithTitle(\"Contract address\", ethereumjs_util_1.bufferToHex(trace.deployedContract));\n            }\n            return;\n        }\n        if (code.length === 0) {\n            if (printNonContractCalled) {\n                this._log(`WARNING: Calling an account which is not a contract`);\n            }\n            return;\n        }\n        if (trace.bytecode === undefined) {\n            this._logWithTitle(\"Contract call\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n            return;\n        }\n        const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n        const functionName = func === undefined\n            ? solidity_stack_trace_1.UNRECOGNIZED_FUNCTION_NAME\n            : func.type === model_1.ContractFunctionType.FALLBACK\n                ? solidity_stack_trace_1.FALLBACK_FUNCTION_NAME\n                : func.type === model_1.ContractFunctionType.RECEIVE\n                    ? solidity_stack_trace_1.RECEIVE_FUNCTION_NAME\n                    : func.name;\n        this._logWithTitle(\"Contract call\", `${trace.bytecode.contract.name}#${functionName}`);\n    }\n    _shouldCollapseMethod(method) {\n        return (method === this._methodBeingCollapsed &&\n            !this._hasLogs() &&\n            this._methodCollapsedCount > 0);\n    }\n    _startCollapsingMethod(method) {\n        this._methodBeingCollapsed = method;\n        this._methodCollapsedCount = 1;\n    }\n    _stopCollapsingMethod() {\n        this._methodBeingCollapsed = undefined;\n        this._methodCollapsedCount = 0;\n    }\n    _logTxTo(to, trace) {\n        if (trace !== undefined && message_trace_1.isCreateTrace(trace)) {\n            return;\n        }\n        if (to === undefined) {\n            // only for the type-checker, since `to` is undefined only when\n            // the message is a create trace\n            return;\n        }\n        const toString = ethereumjs_util_1.bufferToHex(to);\n        this._logWithTitle(\"To\", toString);\n    }\n    _logTxValue(value) {\n        this._logWithTitle(\"Value\", wei_values_1.weiToHumanReadableString(value));\n    }\n    _logTxFrom(from) {\n        this._logWithTitle(\"From\", ethereumjs_util_1.bufferToHex(from));\n    }\n    _logBlockNumber(block) {\n        this._log(`Block #${block.header.number.toNumber()}: ${ethereumjs_util_1.bufferToHex(block.hash())}`);\n    }\n    _logEmptyLineBetweenTransactions(currentIndex, totalTransactions) {\n        if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n            this.logEmptyLine();\n        }\n    }\n    _logBlockHash(block) {\n        this._log(`Block: ${ethereumjs_util_1.bufferToHex(block.hash())}`);\n    }\n    _logConsoleLogMessages(messages) {\n        // This is a especial case, as we always want to print the console.log\n        // messages. The difference is how.\n        // If we have a logger, we should use that, so that logs are printed in\n        // order. If we don't, we just print the messages here.\n        if (!this._enabled) {\n            for (const msg of messages) {\n                this._printLine(msg);\n            }\n            return;\n        }\n        if (messages.length === 0) {\n            return;\n        }\n        this.logEmptyLine();\n        this._log(\"console.log:\");\n        for (const msg of messages) {\n            this._log(`  ${msg}`);\n        }\n    }\n    _logWithTitle(title, message) {\n        title = this._indentSingleLine(title);\n        // We always use the max title length we've seen. Otherwise the value move\n        // a lot with each tx/call.\n        if (title.length > this._titleLength) {\n            this._titleLength = title.length;\n        }\n        this._logs.push([title, message]);\n    }\n    _clearLogs() {\n        this._logs = [];\n    }\n    _hasLogs() {\n        return this._logs.length > 0;\n    }\n    _getLogs() {\n        return this._logs.map((l) => {\n            if (typeof l === \"string\") {\n                return l;\n            }\n            const title = `${l[0]}:`;\n            return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n        });\n    }\n}\nexports.ModulesLogger = ModulesLogger;\n//# sourceMappingURL=logger.js.map"]},"metadata":{},"sourceType":"script"}