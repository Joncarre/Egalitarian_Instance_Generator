{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazyFunction = exports.lazyObject = void 0;\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\n\nfunction lazyObject(objectCreator) {\n  return createLazyProxy(objectCreator, getRealTarget => ({\n    [inspect]() {\n      const realTarget = getRealTarget();\n      return util_1.default.inspect(realTarget);\n    }\n\n  }), object => {\n    if (object instanceof Function) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Creating lazy functions or classes with lazyObject\"\n      });\n    }\n\n    if (typeof object !== \"object\" || object === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyObject with anything other than objects\"\n      });\n    }\n  });\n}\n\nexports.lazyObject = lazyObject; // eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction lazyFunction(functionCreator) {\n  return createLazyProxy(functionCreator, getRealTarget => {\n    function dummyTarget() {}\n\n    dummyTarget[inspect] = function () {\n      const realTarget = getRealTarget();\n      return util_1.default.inspect(realTarget);\n    };\n\n    return dummyTarget;\n  }, object => {\n    if (!(object instanceof Function)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyFunction with anything other than functions or classes\"\n      });\n    }\n  });\n}\n\nexports.lazyFunction = lazyFunction;\n\nfunction createLazyProxy(targetCreator, dummyTargetCreator, validator) {\n  let realTarget;\n  const dummyTarget = dummyTargetCreator(getRealTarget);\n\n  function getRealTarget() {\n    if (realTarget === undefined) {\n      const target = targetCreator();\n      validator(target); // We copy all properties. We won't use them, but help us avoid Proxy\n      // invariant violations\n\n      const properties = Object.getOwnPropertyNames(target);\n\n      for (const property of properties) {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property);\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target)); // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n      // See: https://github.com/nodejs/node/issues/29730\n\n      if (Object.getPrototypeOf(target) === null) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\"\n        });\n      }\n\n      if (!Object.isExtensible(target)) {\n        Object.preventExtensions(dummyTarget);\n      }\n\n      realTarget = target;\n    }\n\n    return realTarget;\n  }\n\n  const handler = {\n    defineProperty(target, property, descriptor) {\n      Reflect.defineProperty(dummyTarget, property, descriptor);\n      return Reflect.defineProperty(getRealTarget(), property, descriptor);\n    },\n\n    deleteProperty(target, property) {\n      Reflect.deleteProperty(dummyTarget, property);\n      return Reflect.deleteProperty(getRealTarget(), property);\n    },\n\n    get(target, property, receiver) {\n      // We have this short-circuit logic here to avoid a cyclic require when\n      // loading Web3.js.\n      //\n      // If a lazy object is somehow accessed while its real target is being\n      // created, it would trigger an endless loop of recreation, which node\n      // detects and resolve to an empty object.\n      //\n      // This happens with Web3.js because we a lazyObject that loads it,\n      // and expose it as `global.web3`. This Web3.js file accesses\n      // `global.web3` when it's being loaded, triggering the loop we mentioned\n      // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n      //\n      // We just return `undefined` in that case, to not enter into the loop.\n      //\n      // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n      // is a horrible hack. The most obvious approach for doing so is to\n      // remove the `global` elements that trigger this crazy behavior right\n      // before doing our `require(\"web3\")`, and restore them afterwards.\n      // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n      // `require`s that we can't control and will trigger the same bug.\n      const stack = new Error().stack;\n\n      if (stack !== undefined && stack.includes(\"givenProvider.js\") && realTarget === undefined) {\n        return undefined;\n      }\n\n      return Reflect.get(getRealTarget(), property, receiver);\n    },\n\n    getOwnPropertyDescriptor(target, property) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(getRealTarget(), property);\n\n      if (descriptor !== undefined) {\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      return descriptor;\n    },\n\n    getPrototypeOf(_target) {\n      return Reflect.getPrototypeOf(getRealTarget());\n    },\n\n    has(target, property) {\n      return Reflect.has(getRealTarget(), property);\n    },\n\n    isExtensible(_target) {\n      return Reflect.isExtensible(getRealTarget());\n    },\n\n    ownKeys(_target) {\n      return Reflect.ownKeys(getRealTarget());\n    },\n\n    preventExtensions(_target) {\n      Object.preventExtensions(dummyTarget);\n      return Reflect.preventExtensions(getRealTarget());\n    },\n\n    set(target, property, value, receiver) {\n      Reflect.set(dummyTarget, property, value, receiver);\n      return Reflect.set(getRealTarget(), property, value, receiver);\n    },\n\n    setPrototypeOf(target, prototype) {\n      Reflect.setPrototypeOf(dummyTarget, prototype);\n      return Reflect.setPrototypeOf(getRealTarget(), prototype);\n    }\n\n  };\n\n  if (dummyTarget instanceof Function) {\n    // If dummy target is a function, the actual target must be a function too.\n    handler.apply = (target, thisArg, argArray) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.apply(getRealTarget(), thisArg, argArray);\n    };\n\n    handler.construct = (target, argArray, _newTarget) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.construct(getRealTarget(), argArray);\n    };\n  }\n\n  return new Proxy(dummyTarget, handler);\n}","map":{"version":3,"sources":["../../src/internal/util/lazy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lazyFunction = exports.lazyObject = void 0;\nconst util_1 = __importDefault(require(\"util\"));\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\nfunction lazyObject(objectCreator) {\n    return createLazyProxy(objectCreator, (getRealTarget) => ({\n        [inspect]() {\n            const realTarget = getRealTarget();\n            return util_1.default.inspect(realTarget);\n        },\n    }), (object) => {\n        if (object instanceof Function) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n                operation: \"Creating lazy functions or classes with lazyObject\",\n            });\n        }\n        if (typeof object !== \"object\" || object === null) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n                operation: \"Using lazyObject with anything other than objects\",\n            });\n        }\n    });\n}\nexports.lazyObject = lazyObject;\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction lazyFunction(functionCreator) {\n    return createLazyProxy(functionCreator, (getRealTarget) => {\n        function dummyTarget() { }\n        dummyTarget[inspect] = function () {\n            const realTarget = getRealTarget();\n            return util_1.default.inspect(realTarget);\n        };\n        return dummyTarget;\n    }, (object) => {\n        if (!(object instanceof Function)) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n                operation: \"Using lazyFunction with anything other than functions or classes\",\n            });\n        }\n    });\n}\nexports.lazyFunction = lazyFunction;\nfunction createLazyProxy(targetCreator, dummyTargetCreator, validator) {\n    let realTarget;\n    const dummyTarget = dummyTargetCreator(getRealTarget);\n    function getRealTarget() {\n        if (realTarget === undefined) {\n            const target = targetCreator();\n            validator(target);\n            // We copy all properties. We won't use them, but help us avoid Proxy\n            // invariant violations\n            const properties = Object.getOwnPropertyNames(target);\n            for (const property of properties) {\n                const descriptor = Object.getOwnPropertyDescriptor(target, property);\n                Object.defineProperty(dummyTarget, property, descriptor);\n            }\n            Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target));\n            // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n            // See: https://github.com/nodejs/node/issues/29730\n            if (Object.getPrototypeOf(target) === null) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n                    operation: \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\",\n                });\n            }\n            if (!Object.isExtensible(target)) {\n                Object.preventExtensions(dummyTarget);\n            }\n            realTarget = target;\n        }\n        return realTarget;\n    }\n    const handler = {\n        defineProperty(target, property, descriptor) {\n            Reflect.defineProperty(dummyTarget, property, descriptor);\n            return Reflect.defineProperty(getRealTarget(), property, descriptor);\n        },\n        deleteProperty(target, property) {\n            Reflect.deleteProperty(dummyTarget, property);\n            return Reflect.deleteProperty(getRealTarget(), property);\n        },\n        get(target, property, receiver) {\n            // We have this short-circuit logic here to avoid a cyclic require when\n            // loading Web3.js.\n            //\n            // If a lazy object is somehow accessed while its real target is being\n            // created, it would trigger an endless loop of recreation, which node\n            // detects and resolve to an empty object.\n            //\n            // This happens with Web3.js because we a lazyObject that loads it,\n            // and expose it as `global.web3`. This Web3.js file accesses\n            // `global.web3` when it's being loaded, triggering the loop we mentioned\n            // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n            //\n            // We just return `undefined` in that case, to not enter into the loop.\n            //\n            // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n            // is a horrible hack. The most obvious approach for doing so is to\n            // remove the `global` elements that trigger this crazy behavior right\n            // before doing our `require(\"web3\")`, and restore them afterwards.\n            // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n            // `require`s that we can't control and will trigger the same bug.\n            const stack = new Error().stack;\n            if (stack !== undefined &&\n                stack.includes(\"givenProvider.js\") &&\n                realTarget === undefined) {\n                return undefined;\n            }\n            return Reflect.get(getRealTarget(), property, receiver);\n        },\n        getOwnPropertyDescriptor(target, property) {\n            const descriptor = Reflect.getOwnPropertyDescriptor(getRealTarget(), property);\n            if (descriptor !== undefined) {\n                Object.defineProperty(dummyTarget, property, descriptor);\n            }\n            return descriptor;\n        },\n        getPrototypeOf(_target) {\n            return Reflect.getPrototypeOf(getRealTarget());\n        },\n        has(target, property) {\n            return Reflect.has(getRealTarget(), property);\n        },\n        isExtensible(_target) {\n            return Reflect.isExtensible(getRealTarget());\n        },\n        ownKeys(_target) {\n            return Reflect.ownKeys(getRealTarget());\n        },\n        preventExtensions(_target) {\n            Object.preventExtensions(dummyTarget);\n            return Reflect.preventExtensions(getRealTarget());\n        },\n        set(target, property, value, receiver) {\n            Reflect.set(dummyTarget, property, value, receiver);\n            return Reflect.set(getRealTarget(), property, value, receiver);\n        },\n        setPrototypeOf(target, prototype) {\n            Reflect.setPrototypeOf(dummyTarget, prototype);\n            return Reflect.setPrototypeOf(getRealTarget(), prototype);\n        },\n    };\n    if (dummyTarget instanceof Function) {\n        // If dummy target is a function, the actual target must be a function too.\n        handler.apply = (target, thisArg, argArray) => {\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            return Reflect.apply(getRealTarget(), thisArg, argArray);\n        };\n        handler.construct = (target, argArray, _newTarget) => {\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            return Reflect.construct(getRealTarget(), argArray);\n        };\n    }\n    return new Proxy(dummyTarget, handler);\n}\n//# sourceMappingURL=lazy.js.map"]},"metadata":{},"sourceType":"script"}