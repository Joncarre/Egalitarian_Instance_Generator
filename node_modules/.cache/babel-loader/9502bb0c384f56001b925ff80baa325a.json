{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeCompilationJobsWithoutBug = exports.mergeCompilationJobsWithBug = exports.createCompilationJobFromFile = exports.createCompilationJobsFromConnectedComponent = exports.CompilationJob = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst builtin_tasks_1 = require(\"../../types/builtin-tasks\");\n\nconst errors_1 = require(\"../core/errors\");\n\nconst log = debug_1.default(\"hardhat:core:compilation-job\"); // this should have a proper version range when it's fixed\n\nconst SOLC_BUG_9573_VERSIONS = \"*\";\n\nfunction isCompilationJobCreationError(x) {\n  return \"reason\" in x;\n}\n\nclass CompilationJob {\n  constructor(solidityConfig) {\n    this.solidityConfig = solidityConfig;\n    this._filesToCompile = new Map();\n  }\n\n  addFileToCompile(file, emitsArtifacts) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName); // if the file doesn't exist, we add it\n    // we also add it if emitsArtifacts is true, to override it in case it was\n    // previously added but with a false emitsArtifacts\n\n\n    if (fileToCompile === undefined || emitsArtifacts) {\n      this._filesToCompile.set(file.sourceName, {\n        file,\n        emitsArtifacts\n      });\n    }\n  }\n\n  hasSolc9573Bug() {\n    var _a, _b, _c;\n\n    return ((_c = (_b = (_a = this.solidityConfig) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.optimizer) === null || _c === void 0 ? void 0 : _c.enabled) === true && semver_1.default.satisfies(this.solidityConfig.version, SOLC_BUG_9573_VERSIONS);\n  }\n\n  merge(job) {\n    const {\n      isEqual\n    } = require(\"lodash\");\n\n    errors_1.assertHardhatInvariant(isEqual(this.solidityConfig, job.getSolcConfig()), \"Merging jobs with different solidity configurations\");\n    const mergedJobs = new CompilationJob(job.getSolcConfig());\n\n    for (const file of this.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, this.emitsArtifacts(file));\n    }\n\n    for (const file of job.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, job.emitsArtifacts(file));\n    }\n\n    return mergedJobs;\n  }\n\n  getSolcConfig() {\n    return this.solidityConfig;\n  }\n\n  isEmpty() {\n    return this._filesToCompile.size === 0;\n  }\n\n  getResolvedFiles() {\n    return [...this._filesToCompile.values()].map(x => x.file);\n  }\n  /**\n   * Check if the given file emits artifacts.\n   *\n   * If no file is given, check if *some* file in the job emits artifacts.\n   */\n\n\n  emitsArtifacts(file) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    errors_1.assertHardhatInvariant(fileToCompile !== undefined, `File '${file.sourceName}' does not exist in this compilation job`);\n    return fileToCompile.emitsArtifacts;\n  }\n\n}\n\nexports.CompilationJob = CompilationJob;\n\nfunction mergeCompilationJobs(jobs, isMergeable) {\n  const {\n    flatten\n  } = require(\"lodash\");\n\n  const jobsMap = new Map();\n\n  for (const job of jobs) {\n    const mergedJobs = jobsMap.get(job.getSolcConfig());\n\n    if (isMergeable(job)) {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else if (mergedJobs.length === 1) {\n        const newJob = mergedJobs[0].merge(job);\n        jobsMap.set(job.getSolcConfig(), [newJob]);\n      } else {\n        errors_1.assertHardhatInvariant(false, \"More than one mergeable job was added for the same configuration\");\n      }\n    } else {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else {\n        jobsMap.set(job.getSolcConfig(), [...mergedJobs, job]);\n      }\n    }\n  }\n\n  return flatten([...jobsMap.values()]);\n}\n/**\n * Creates a list of compilation jobs from a dependency graph. *This function\n * assumes that the given graph is a connected component*.\n * Returns the list of compilation jobs on success, and a list of\n * non-compilable files on failure.\n */\n\n\nasync function createCompilationJobsFromConnectedComponent(connectedComponent, getFromFile) {\n  const compilationJobs = [];\n  const errors = [];\n\n  for (const file of connectedComponent.getResolvedFiles()) {\n    const compilationJobOrError = await getFromFile(file);\n\n    if (isCompilationJobCreationError(compilationJobOrError)) {\n      log(`'${file.absolutePath}' couldn't be compiled. Reason: '${compilationJobOrError}'`);\n      errors.push(compilationJobOrError);\n      continue;\n    }\n\n    compilationJobs.push(compilationJobOrError);\n  }\n\n  const jobs = mergeCompilationJobsWithBug(compilationJobs);\n  return {\n    jobs,\n    errors\n  };\n}\n\nexports.createCompilationJobsFromConnectedComponent = createCompilationJobsFromConnectedComponent;\n\nasync function createCompilationJobFromFile(dependencyGraph, file, solidityConfig) {\n  const directDependencies = dependencyGraph.getDependencies(file);\n  const transitiveDependencies = dependencyGraph.getTransitiveDependencies(file);\n  const compilerConfig = getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig); // if the config cannot be obtained, we just return the failure\n\n  if (isCompilationJobCreationError(compilerConfig)) {\n    return compilerConfig;\n  }\n\n  log(`File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`);\n  const compilationJob = new CompilationJob(compilerConfig);\n  compilationJob.addFileToCompile(file, true);\n\n  for (const {\n    dependency\n  } of transitiveDependencies) {\n    log(`File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`);\n    compilationJob.addFileToCompile(dependency, false);\n  }\n\n  return compilationJob;\n}\n\nexports.createCompilationJobFromFile = createCompilationJobFromFile;\n/**\n * Merge compilation jobs affected by the solc #9573 bug\n */\n\nfunction mergeCompilationJobsWithBug(compilationJobs) {\n  return mergeCompilationJobs(compilationJobs, job => job.hasSolc9573Bug());\n}\n\nexports.mergeCompilationJobsWithBug = mergeCompilationJobsWithBug;\n/**\n * Merge compilation jobs not affected by the solc #9573 bug\n */\n\nfunction mergeCompilationJobsWithoutBug(compilationJobs) {\n  return mergeCompilationJobs(compilationJobs, job => !job.hasSolc9573Bug());\n}\n\nexports.mergeCompilationJobsWithoutBug = mergeCompilationJobsWithoutBug;\n/**\n * Return the compiler config with the newest version that satisfies the given\n * version ranges, or a value indicating why the compiler couldn't be obtained.\n */\n\nfunction getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig) {\n  var _a;\n\n  const {\n    uniq\n  } = require(\"lodash\");\n\n  const transitiveDependenciesVersionPragmas = transitiveDependencies.map(({\n    dependency\n  }) => dependency.content.versionPragmas);\n  const versionRange = uniq([...file.content.versionPragmas, ...transitiveDependenciesVersionPragmas]).join(\" \");\n  const overrides = (_a = solidityConfig.overrides) !== null && _a !== void 0 ? _a : {};\n  const overriddenCompiler = overrides[file.sourceName]; // if there's an override, we only check that\n\n  if (overriddenCompiler !== undefined) {\n    if (!semver_1.default.satisfies(overriddenCompiler.version, versionRange)) {\n      return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, [overriddenCompiler.version], true);\n    }\n\n    return overriddenCompiler;\n  } // if there's no override, we find a compiler that matches the version range\n\n\n  const compilerVersions = solidityConfig.compilers.map(x => x.version);\n  const matchingVersion = semver_1.default.maxSatisfying(compilerVersions, versionRange);\n\n  if (matchingVersion === null) {\n    return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, false);\n  }\n\n  const matchingConfig = solidityConfig.compilers.find(x => x.version === matchingVersion);\n  return matchingConfig;\n}\n\nfunction getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, overriden) {\n  const fileVersionRange = file.content.versionPragmas.join(\" \");\n\n  if (semver_1.default.maxSatisfying(compilerVersions, fileVersionRange) === null) {\n    const reason = overriden ? builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION : builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;\n    return {\n      reason,\n      file\n    };\n  }\n\n  const incompatibleDirectImports = [];\n\n  for (const dependency of directDependencies) {\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n\n    if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleDirectImports.push(dependency);\n    }\n  }\n\n  if (incompatibleDirectImports.length > 0) {\n    return {\n      reason: builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleDirectImports\n      }\n    };\n  }\n\n  const incompatibleIndirectImports = [];\n\n  for (const transitiveDependency of transitiveDependencies) {\n    const {\n      dependency\n    } = transitiveDependency;\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n\n    if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleIndirectImports.push(transitiveDependency);\n    }\n  }\n\n  if (incompatibleIndirectImports.length > 0) {\n    return {\n      reason: builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleIndirectImports\n      }\n    };\n  }\n\n  return {\n    reason: builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR,\n    file\n  };\n}","map":{"version":3,"sources":["../../src/internal/solidity/compilation-job.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeCompilationJobsWithoutBug = exports.mergeCompilationJobsWithBug = exports.createCompilationJobFromFile = exports.createCompilationJobsFromConnectedComponent = exports.CompilationJob = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst semver_1 = __importDefault(require(\"semver\"));\nconst builtin_tasks_1 = require(\"../../types/builtin-tasks\");\nconst errors_1 = require(\"../core/errors\");\nconst log = debug_1.default(\"hardhat:core:compilation-job\");\n// this should have a proper version range when it's fixed\nconst SOLC_BUG_9573_VERSIONS = \"*\";\nfunction isCompilationJobCreationError(x) {\n    return \"reason\" in x;\n}\nclass CompilationJob {\n    constructor(solidityConfig) {\n        this.solidityConfig = solidityConfig;\n        this._filesToCompile = new Map();\n    }\n    addFileToCompile(file, emitsArtifacts) {\n        const fileToCompile = this._filesToCompile.get(file.sourceName);\n        // if the file doesn't exist, we add it\n        // we also add it if emitsArtifacts is true, to override it in case it was\n        // previously added but with a false emitsArtifacts\n        if (fileToCompile === undefined || emitsArtifacts) {\n            this._filesToCompile.set(file.sourceName, { file, emitsArtifacts });\n        }\n    }\n    hasSolc9573Bug() {\n        var _a, _b, _c;\n        return (((_c = (_b = (_a = this.solidityConfig) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.optimizer) === null || _c === void 0 ? void 0 : _c.enabled) === true &&\n            semver_1.default.satisfies(this.solidityConfig.version, SOLC_BUG_9573_VERSIONS));\n    }\n    merge(job) {\n        const { isEqual } = require(\"lodash\");\n        errors_1.assertHardhatInvariant(isEqual(this.solidityConfig, job.getSolcConfig()), \"Merging jobs with different solidity configurations\");\n        const mergedJobs = new CompilationJob(job.getSolcConfig());\n        for (const file of this.getResolvedFiles()) {\n            mergedJobs.addFileToCompile(file, this.emitsArtifacts(file));\n        }\n        for (const file of job.getResolvedFiles()) {\n            mergedJobs.addFileToCompile(file, job.emitsArtifacts(file));\n        }\n        return mergedJobs;\n    }\n    getSolcConfig() {\n        return this.solidityConfig;\n    }\n    isEmpty() {\n        return this._filesToCompile.size === 0;\n    }\n    getResolvedFiles() {\n        return [...this._filesToCompile.values()].map((x) => x.file);\n    }\n    /**\n     * Check if the given file emits artifacts.\n     *\n     * If no file is given, check if *some* file in the job emits artifacts.\n     */\n    emitsArtifacts(file) {\n        const fileToCompile = this._filesToCompile.get(file.sourceName);\n        errors_1.assertHardhatInvariant(fileToCompile !== undefined, `File '${file.sourceName}' does not exist in this compilation job`);\n        return fileToCompile.emitsArtifacts;\n    }\n}\nexports.CompilationJob = CompilationJob;\nfunction mergeCompilationJobs(jobs, isMergeable) {\n    const { flatten } = require(\"lodash\");\n    const jobsMap = new Map();\n    for (const job of jobs) {\n        const mergedJobs = jobsMap.get(job.getSolcConfig());\n        if (isMergeable(job)) {\n            if (mergedJobs === undefined) {\n                jobsMap.set(job.getSolcConfig(), [job]);\n            }\n            else if (mergedJobs.length === 1) {\n                const newJob = mergedJobs[0].merge(job);\n                jobsMap.set(job.getSolcConfig(), [newJob]);\n            }\n            else {\n                errors_1.assertHardhatInvariant(false, \"More than one mergeable job was added for the same configuration\");\n            }\n        }\n        else {\n            if (mergedJobs === undefined) {\n                jobsMap.set(job.getSolcConfig(), [job]);\n            }\n            else {\n                jobsMap.set(job.getSolcConfig(), [...mergedJobs, job]);\n            }\n        }\n    }\n    return flatten([...jobsMap.values()]);\n}\n/**\n * Creates a list of compilation jobs from a dependency graph. *This function\n * assumes that the given graph is a connected component*.\n * Returns the list of compilation jobs on success, and a list of\n * non-compilable files on failure.\n */\nasync function createCompilationJobsFromConnectedComponent(connectedComponent, getFromFile) {\n    const compilationJobs = [];\n    const errors = [];\n    for (const file of connectedComponent.getResolvedFiles()) {\n        const compilationJobOrError = await getFromFile(file);\n        if (isCompilationJobCreationError(compilationJobOrError)) {\n            log(`'${file.absolutePath}' couldn't be compiled. Reason: '${compilationJobOrError}'`);\n            errors.push(compilationJobOrError);\n            continue;\n        }\n        compilationJobs.push(compilationJobOrError);\n    }\n    const jobs = mergeCompilationJobsWithBug(compilationJobs);\n    return { jobs, errors };\n}\nexports.createCompilationJobsFromConnectedComponent = createCompilationJobsFromConnectedComponent;\nasync function createCompilationJobFromFile(dependencyGraph, file, solidityConfig) {\n    const directDependencies = dependencyGraph.getDependencies(file);\n    const transitiveDependencies = dependencyGraph.getTransitiveDependencies(file);\n    const compilerConfig = getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig);\n    // if the config cannot be obtained, we just return the failure\n    if (isCompilationJobCreationError(compilerConfig)) {\n        return compilerConfig;\n    }\n    log(`File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`);\n    const compilationJob = new CompilationJob(compilerConfig);\n    compilationJob.addFileToCompile(file, true);\n    for (const { dependency } of transitiveDependencies) {\n        log(`File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`);\n        compilationJob.addFileToCompile(dependency, false);\n    }\n    return compilationJob;\n}\nexports.createCompilationJobFromFile = createCompilationJobFromFile;\n/**\n * Merge compilation jobs affected by the solc #9573 bug\n */\nfunction mergeCompilationJobsWithBug(compilationJobs) {\n    return mergeCompilationJobs(compilationJobs, (job) => job.hasSolc9573Bug());\n}\nexports.mergeCompilationJobsWithBug = mergeCompilationJobsWithBug;\n/**\n * Merge compilation jobs not affected by the solc #9573 bug\n */\nfunction mergeCompilationJobsWithoutBug(compilationJobs) {\n    return mergeCompilationJobs(compilationJobs, (job) => !job.hasSolc9573Bug());\n}\nexports.mergeCompilationJobsWithoutBug = mergeCompilationJobsWithoutBug;\n/**\n * Return the compiler config with the newest version that satisfies the given\n * version ranges, or a value indicating why the compiler couldn't be obtained.\n */\nfunction getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig) {\n    var _a;\n    const { uniq } = require(\"lodash\");\n    const transitiveDependenciesVersionPragmas = transitiveDependencies.map(({ dependency }) => dependency.content.versionPragmas);\n    const versionRange = uniq([\n        ...file.content.versionPragmas,\n        ...transitiveDependenciesVersionPragmas,\n    ]).join(\" \");\n    const overrides = (_a = solidityConfig.overrides) !== null && _a !== void 0 ? _a : {};\n    const overriddenCompiler = overrides[file.sourceName];\n    // if there's an override, we only check that\n    if (overriddenCompiler !== undefined) {\n        if (!semver_1.default.satisfies(overriddenCompiler.version, versionRange)) {\n            return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, [overriddenCompiler.version], true);\n        }\n        return overriddenCompiler;\n    }\n    // if there's no override, we find a compiler that matches the version range\n    const compilerVersions = solidityConfig.compilers.map((x) => x.version);\n    const matchingVersion = semver_1.default.maxSatisfying(compilerVersions, versionRange);\n    if (matchingVersion === null) {\n        return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, false);\n    }\n    const matchingConfig = solidityConfig.compilers.find((x) => x.version === matchingVersion);\n    return matchingConfig;\n}\nfunction getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, overriden) {\n    const fileVersionRange = file.content.versionPragmas.join(\" \");\n    if (semver_1.default.maxSatisfying(compilerVersions, fileVersionRange) === null) {\n        const reason = overriden\n            ? builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION\n            : builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;\n        return { reason, file };\n    }\n    const incompatibleDirectImports = [];\n    for (const dependency of directDependencies) {\n        const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n        if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n            incompatibleDirectImports.push(dependency);\n        }\n    }\n    if (incompatibleDirectImports.length > 0) {\n        return {\n            reason: builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n            file,\n            extra: {\n                incompatibleDirectImports,\n            },\n        };\n    }\n    const incompatibleIndirectImports = [];\n    for (const transitiveDependency of transitiveDependencies) {\n        const { dependency } = transitiveDependency;\n        const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n        if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n            incompatibleIndirectImports.push(transitiveDependency);\n        }\n    }\n    if (incompatibleIndirectImports.length > 0) {\n        return {\n            reason: builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n            file,\n            extra: {\n                incompatibleIndirectImports,\n            },\n        };\n    }\n    return { reason: builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR, file };\n}\n//# sourceMappingURL=compilation-job.js.map"]},"metadata":{},"sourceType":"script"}