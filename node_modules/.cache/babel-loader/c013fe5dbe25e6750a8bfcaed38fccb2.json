{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runScriptWithHardhat = exports.runScript = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst execution_mode_1 = require(\"../core/execution-mode\");\n\nconst env_variables_1 = require(\"../core/params/env-variables\");\n\nconst log = debug_1.default(\"hardhat:core:scripts-runner\");\n\nasync function runScript(scriptPath, scriptArgs = [], extraNodeArgs = [], extraEnvVars = {}) {\n  const {\n    fork\n  } = await Promise.resolve().then(() => __importStar(require(\"child_process\")));\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n    const nodeArgs = [...processExecArgv, ...getTsNodeArgsIfNeeded(scriptPath), ...extraNodeArgs];\n    const envVars = Object.assign(Object.assign({}, process.env), extraEnvVars);\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars\n    });\n    childProcess.once(\"close\", status => {\n      log(`Script ${scriptPath} exited with status code ${status}`);\n      resolve(status);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\n\nexports.runScript = runScript;\n\nasync function runScriptWithHardhat(hardhatArguments, scriptPath, scriptArgs = [], extraNodeArgs = [], extraEnvVars = {}) {\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n  return runScript(scriptPath, scriptArgs, [...extraNodeArgs, \"--require\", path_1.default.join(__dirname, \"..\", \"..\", \"register\")], Object.assign(Object.assign({}, env_variables_1.getEnvVariablesMap(hardhatArguments)), extraEnvVars));\n}\n\nexports.runScriptWithHardhat = runScriptWithHardhat;\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\n\nfunction withFixedInspectArg(argv) {\n  const fixIfInspectArg = arg => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n\n    return arg;\n  };\n\n  return argv.map(fixIfInspectArg);\n}\n\nfunction getTsNodeArgsIfNeeded(scriptPath) {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  } // if we are running the tests we only want to transpile, or these tests\n  // take forever\n\n\n  if (execution_mode_1.isRunningHardhatCoreTests()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  } // If the script we are going to run is .ts we need ts-node\n\n\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\"--require\", \"ts-node/register\"];\n  }\n\n  return [];\n}","map":{"version":3,"sources":["../../src/internal/util/scripts-runner.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.runScriptWithHardhat = exports.runScript = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst execution_mode_1 = require(\"../core/execution-mode\");\nconst env_variables_1 = require(\"../core/params/env-variables\");\nconst log = debug_1.default(\"hardhat:core:scripts-runner\");\nasync function runScript(scriptPath, scriptArgs = [], extraNodeArgs = [], extraEnvVars = {}) {\n    const { fork } = await Promise.resolve().then(() => __importStar(require(\"child_process\")));\n    return new Promise((resolve, reject) => {\n        const processExecArgv = withFixedInspectArg(process.execArgv);\n        const nodeArgs = [\n            ...processExecArgv,\n            ...getTsNodeArgsIfNeeded(scriptPath),\n            ...extraNodeArgs,\n        ];\n        const envVars = Object.assign(Object.assign({}, process.env), extraEnvVars);\n        const childProcess = fork(scriptPath, scriptArgs, {\n            stdio: \"inherit\",\n            execArgv: nodeArgs,\n            env: envVars,\n        });\n        childProcess.once(\"close\", (status) => {\n            log(`Script ${scriptPath} exited with status code ${status}`);\n            resolve(status);\n        });\n        childProcess.once(\"error\", reject);\n    });\n}\nexports.runScript = runScript;\nasync function runScriptWithHardhat(hardhatArguments, scriptPath, scriptArgs = [], extraNodeArgs = [], extraEnvVars = {}) {\n    log(`Creating Hardhat subprocess to run ${scriptPath}`);\n    return runScript(scriptPath, scriptArgs, [\n        ...extraNodeArgs,\n        \"--require\",\n        path_1.default.join(__dirname, \"..\", \"..\", \"register\"),\n    ], Object.assign(Object.assign({}, env_variables_1.getEnvVariablesMap(hardhatArguments)), extraEnvVars));\n}\nexports.runScriptWithHardhat = runScriptWithHardhat;\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\nfunction withFixedInspectArg(argv) {\n    const fixIfInspectArg = (arg) => {\n        if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n            return \"--inspect\";\n        }\n        return arg;\n    };\n    return argv.map(fixIfInspectArg);\n}\nfunction getTsNodeArgsIfNeeded(scriptPath) {\n    if (process.execArgv.includes(\"ts-node/register\")) {\n        return [];\n    }\n    // if we are running the tests we only want to transpile, or these tests\n    // take forever\n    if (execution_mode_1.isRunningHardhatCoreTests()) {\n        return [\"--require\", \"ts-node/register/transpile-only\"];\n    }\n    // If the script we are going to run is .ts we need ts-node\n    if (/\\.tsx?$/i.test(scriptPath)) {\n        return [\"--require\", \"ts-node/register\"];\n    }\n    return [];\n}\n//# sourceMappingURL=scripts-runner.js.map"]},"metadata":{},"sourceType":"script"}