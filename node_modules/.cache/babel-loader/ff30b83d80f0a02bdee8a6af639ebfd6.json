{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DependencyGraph = void 0;\n\nclass DependencyGraph {\n  constructor() {\n    this._resolvedFiles = new Map();\n    this._dependenciesPerFile = new Map();\n    this._visitedFiles = new Set();\n  }\n\n  static async createFromResolvedFiles(resolver, resolvedFiles) {\n    const graph = new DependencyGraph();\n\n    for (const resolvedFile of resolvedFiles) {\n      await graph._addDependenciesFrom(resolver, resolvedFile);\n    }\n\n    return graph;\n  }\n\n  getResolvedFiles() {\n    return Array.from(this._resolvedFiles.values());\n  }\n\n  has(file) {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n\n  isEmpty() {\n    return this._resolvedFiles.size === 0;\n  }\n\n  entries() {\n    return Array.from(this._dependenciesPerFile.entries()).map(([key, value]) => [this._resolvedFiles.get(key), value]);\n  }\n\n  getDependencies(file) {\n    var _a;\n\n    const dependencies = (_a = this._dependenciesPerFile.get(file.sourceName)) !== null && _a !== void 0 ? _a : new Set();\n    return [...dependencies];\n  }\n\n  getTransitiveDependencies(file) {\n    const visited = new Set();\n\n    const transitiveDependencies = this._getTransitiveDependencies(file, visited, []);\n\n    return [...transitiveDependencies];\n  }\n\n  getConnectedComponents() {\n    var _a, _b;\n\n    const undirectedGraph = {};\n\n    for (const [sourceName, dependencies] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = (_a = undirectedGraph[sourceName]) !== null && _a !== void 0 ? _a : new Set();\n\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] = (_b = undirectedGraph[dependency.sourceName]) !== null && _b !== void 0 ? _b : new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n\n    const components = [];\n    const visited = new Set();\n\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n\n      while (stack.length > 0) {\n        const newNode = stack.pop();\n\n        if (visited.has(newNode)) {\n          continue;\n        }\n\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach(adjacent => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n\n      components.push(component);\n    }\n\n    const connectedComponents = [];\n\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName);\n\n        const dependencies = this._dependenciesPerFile.get(sourceName);\n\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n\n      connectedComponents.push(dependencyGraph);\n    }\n\n    return connectedComponents;\n  }\n\n  _getTransitiveDependencies(file, visited, path) {\n    if (visited.has(file)) {\n      return new Set();\n    }\n\n    visited.add(file);\n    const directDependencies = this.getDependencies(file).map(dependency => ({\n      dependency,\n      path\n    }));\n    const transitiveDependencies = new Set(directDependencies);\n\n    for (const {\n      dependency\n    } of transitiveDependencies) {\n      this._getTransitiveDependencies(dependency, visited, path.concat(dependency)).forEach(x => transitiveDependencies.add(x));\n    }\n\n    return transitiveDependencies;\n  }\n\n  async _addDependenciesFrom(resolver, file) {\n    if (this._visitedFiles.has(file.absolutePath)) {\n      return;\n    }\n\n    this._visitedFiles.add(file.absolutePath);\n\n    const dependencies = new Set();\n\n    this._resolvedFiles.set(file.sourceName, file);\n\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n\n    for (const imp of file.content.imports) {\n      const dependency = await resolver.resolveImport(file, imp);\n      dependencies.add(dependency);\n      await this._addDependenciesFrom(resolver, dependency);\n    }\n  }\n\n}\n\nexports.DependencyGraph = DependencyGraph;","map":{"version":3,"sources":["../../src/internal/solidity/dependencyGraph.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DependencyGraph = void 0;\nclass DependencyGraph {\n    constructor() {\n        this._resolvedFiles = new Map();\n        this._dependenciesPerFile = new Map();\n        this._visitedFiles = new Set();\n    }\n    static async createFromResolvedFiles(resolver, resolvedFiles) {\n        const graph = new DependencyGraph();\n        for (const resolvedFile of resolvedFiles) {\n            await graph._addDependenciesFrom(resolver, resolvedFile);\n        }\n        return graph;\n    }\n    getResolvedFiles() {\n        return Array.from(this._resolvedFiles.values());\n    }\n    has(file) {\n        return this._resolvedFiles.has(file.sourceName);\n    }\n    isEmpty() {\n        return this._resolvedFiles.size === 0;\n    }\n    entries() {\n        return Array.from(this._dependenciesPerFile.entries()).map(([key, value]) => [this._resolvedFiles.get(key), value]);\n    }\n    getDependencies(file) {\n        var _a;\n        const dependencies = (_a = this._dependenciesPerFile.get(file.sourceName)) !== null && _a !== void 0 ? _a : new Set();\n        return [...dependencies];\n    }\n    getTransitiveDependencies(file) {\n        const visited = new Set();\n        const transitiveDependencies = this._getTransitiveDependencies(file, visited, []);\n        return [...transitiveDependencies];\n    }\n    getConnectedComponents() {\n        var _a, _b;\n        const undirectedGraph = {};\n        for (const [sourceName, dependencies,] of this._dependenciesPerFile.entries()) {\n            undirectedGraph[sourceName] = (_a = undirectedGraph[sourceName]) !== null && _a !== void 0 ? _a : new Set();\n            for (const dependency of dependencies) {\n                undirectedGraph[dependency.sourceName] = (_b = undirectedGraph[dependency.sourceName]) !== null && _b !== void 0 ? _b : new Set();\n                undirectedGraph[sourceName].add(dependency.sourceName);\n                undirectedGraph[dependency.sourceName].add(sourceName);\n            }\n        }\n        const components = [];\n        const visited = new Set();\n        for (const node of Object.keys(undirectedGraph)) {\n            if (visited.has(node)) {\n                continue;\n            }\n            visited.add(node);\n            const component = new Set([node]);\n            const stack = [...undirectedGraph[node]];\n            while (stack.length > 0) {\n                const newNode = stack.pop();\n                if (visited.has(newNode)) {\n                    continue;\n                }\n                visited.add(newNode);\n                component.add(newNode);\n                [...undirectedGraph[newNode]].forEach((adjacent) => {\n                    if (!visited.has(adjacent)) {\n                        stack.push(adjacent);\n                    }\n                });\n            }\n            components.push(component);\n        }\n        const connectedComponents = [];\n        for (const component of components) {\n            const dependencyGraph = new DependencyGraph();\n            for (const sourceName of component) {\n                const file = this._resolvedFiles.get(sourceName);\n                const dependencies = this._dependenciesPerFile.get(sourceName);\n                dependencyGraph._resolvedFiles.set(sourceName, file);\n                dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n            }\n            connectedComponents.push(dependencyGraph);\n        }\n        return connectedComponents;\n    }\n    _getTransitiveDependencies(file, visited, path) {\n        if (visited.has(file)) {\n            return new Set();\n        }\n        visited.add(file);\n        const directDependencies = this.getDependencies(file).map((dependency) => ({\n            dependency,\n            path,\n        }));\n        const transitiveDependencies = new Set(directDependencies);\n        for (const { dependency } of transitiveDependencies) {\n            this._getTransitiveDependencies(dependency, visited, path.concat(dependency)).forEach((x) => transitiveDependencies.add(x));\n        }\n        return transitiveDependencies;\n    }\n    async _addDependenciesFrom(resolver, file) {\n        if (this._visitedFiles.has(file.absolutePath)) {\n            return;\n        }\n        this._visitedFiles.add(file.absolutePath);\n        const dependencies = new Set();\n        this._resolvedFiles.set(file.sourceName, file);\n        this._dependenciesPerFile.set(file.sourceName, dependencies);\n        for (const imp of file.content.imports) {\n            const dependency = await resolver.resolveImport(file, imp);\n            dependencies.add(dependency);\n            await this._addDependenciesFrom(resolver, dependency);\n        }\n    }\n}\nexports.DependencyGraph = DependencyGraph;\n//# sourceMappingURL=dependencyGraph.js.map"]},"metadata":{},"sourceType":"script"}