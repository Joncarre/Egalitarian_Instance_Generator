{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentsParser = void 0;\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nclass ArgumentsParser {\n  static paramNameToCLA(paramName) {\n    return ArgumentsParser.PARAM_PREFIX + paramName.split(/(?=[A-Z])/g).map(s => s.toLowerCase()).join(\"-\");\n  }\n\n  static cLAToParamName(cLA) {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA\n      });\n    }\n\n    const parts = cLA.slice(ArgumentsParser.PARAM_PREFIX.length).split(\"-\").filter(x => x.length > 0);\n    return parts[0] + parts.slice(1).map(s => s[0].toUpperCase() + s.slice(1)).join(\"\");\n  }\n\n  parseHardhatArguments(hardhatParamDefinitions, envVariableArguments, rawCLAs) {\n    const hardhatArguments = {};\n    let taskName;\n    const unparsedCLAs = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (taskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          taskName = arg;\n          continue;\n        }\n\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG, {\n            argument: arg\n          });\n        }\n\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments);\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          unparsedCLAs.push(arg);\n          continue;\n        }\n\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments);\n      }\n    }\n\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments),\n      taskName,\n      unparsedCLAs\n    };\n  }\n\n  parseTaskArguments(taskDefinition, rawCLAs) {\n    const {\n      paramArguments,\n      rawPositionalArguments\n    } = this._parseTaskParamArguments(taskDefinition, rawCLAs);\n\n    const positionalArguments = this._parsePositionalParamArgs(rawPositionalArguments, taskDefinition.positionalParamDefinitions);\n\n    return Object.assign(Object.assign({}, paramArguments), positionalArguments);\n  }\n\n  _parseTaskParamArguments(taskDefinition, rawCLAs) {\n    const paramArguments = {};\n    const rawPositionalArguments = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg\n        });\n      }\n\n      i = this._parseArgumentAt(rawCLAs, i, taskDefinition.paramDefinitions, paramArguments);\n    }\n\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n\n    return {\n      paramArguments,\n      rawPositionalArguments\n    };\n  }\n\n  _addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments) {\n    return Object.assign(Object.assign({}, envVariableArguments), hardhatArguments);\n  }\n\n  _addTaskDefaultArguments(taskDefinition, taskArguments) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n\n      if (!definition.isOptional) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName)\n        });\n      }\n\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n\n  _isCLAParamName(str, paramDefinitions) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n\n  _hasCLAParamNameFormat(str) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n\n  _parseArgumentAt(rawCLAs, index, paramDefinitions, parsedArguments) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n\n    if (parsedArguments[paramName] !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg\n      });\n    }\n\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n\n      if (value === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName)\n        });\n      } // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n\n\n      const type = definition.type;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n\n    return index;\n  }\n\n  _parsePositionalParamArgs(rawPositionalParamArgs, positionalParamDefinitions) {\n    const args = {};\n\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i]; // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n\n      const type = definition.type;\n      const rawArg = rawPositionalParamArgs[i];\n\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name\n          });\n        }\n\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs.slice(i).map(raw => type.parse(definition.name, raw));\n      }\n    }\n\n    const lastDefinition = positionalParamDefinitions[positionalParamDefinitions.length - 1];\n    const hasVariadicParam = lastDefinition !== undefined && lastDefinition.isVariadic;\n\n    if (!hasVariadicParam && rawPositionalParamArgs.length > positionalParamDefinitions.length) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length]\n      });\n    }\n\n    return args;\n  }\n\n}\n\nexports.ArgumentsParser = ArgumentsParser;\nArgumentsParser.PARAM_PREFIX = \"--\";","map":{"version":3,"sources":["../../src/internal/cli/ArgumentsParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgumentsParser = void 0;\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nclass ArgumentsParser {\n    static paramNameToCLA(paramName) {\n        return (ArgumentsParser.PARAM_PREFIX +\n            paramName\n                .split(/(?=[A-Z])/g)\n                .map((s) => s.toLowerCase())\n                .join(\"-\"));\n    }\n    static cLAToParamName(cLA) {\n        if (cLA.toLowerCase() !== cLA) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n                param: cLA,\n            });\n        }\n        const parts = cLA\n            .slice(ArgumentsParser.PARAM_PREFIX.length)\n            .split(\"-\")\n            .filter((x) => x.length > 0);\n        return (parts[0] +\n            parts\n                .slice(1)\n                .map((s) => s[0].toUpperCase() + s.slice(1))\n                .join(\"\"));\n    }\n    parseHardhatArguments(hardhatParamDefinitions, envVariableArguments, rawCLAs) {\n        const hardhatArguments = {};\n        let taskName;\n        const unparsedCLAs = [];\n        for (let i = 0; i < rawCLAs.length; i++) {\n            const arg = rawCLAs[i];\n            if (taskName === undefined) {\n                if (!this._hasCLAParamNameFormat(arg)) {\n                    taskName = arg;\n                    continue;\n                }\n                if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n                    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG, { argument: arg });\n                }\n                i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments);\n            }\n            else {\n                if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n                    unparsedCLAs.push(arg);\n                    continue;\n                }\n                i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments);\n            }\n        }\n        return {\n            hardhatArguments: this._addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments),\n            taskName,\n            unparsedCLAs,\n        };\n    }\n    parseTaskArguments(taskDefinition, rawCLAs) {\n        const { paramArguments, rawPositionalArguments } = this._parseTaskParamArguments(taskDefinition, rawCLAs);\n        const positionalArguments = this._parsePositionalParamArgs(rawPositionalArguments, taskDefinition.positionalParamDefinitions);\n        return Object.assign(Object.assign({}, paramArguments), positionalArguments);\n    }\n    _parseTaskParamArguments(taskDefinition, rawCLAs) {\n        const paramArguments = {};\n        const rawPositionalArguments = [];\n        for (let i = 0; i < rawCLAs.length; i++) {\n            const arg = rawCLAs[i];\n            if (!this._hasCLAParamNameFormat(arg)) {\n                rawPositionalArguments.push(arg);\n                continue;\n            }\n            if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n                    param: arg,\n                });\n            }\n            i = this._parseArgumentAt(rawCLAs, i, taskDefinition.paramDefinitions, paramArguments);\n        }\n        this._addTaskDefaultArguments(taskDefinition, paramArguments);\n        return { paramArguments, rawPositionalArguments };\n    }\n    _addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments) {\n        return Object.assign(Object.assign({}, envVariableArguments), hardhatArguments);\n    }\n    _addTaskDefaultArguments(taskDefinition, taskArguments) {\n        for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n            const definition = taskDefinition.paramDefinitions[paramName];\n            if (taskArguments[paramName] !== undefined) {\n                continue;\n            }\n            if (!definition.isOptional) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n                    param: ArgumentsParser.paramNameToCLA(paramName),\n                });\n            }\n            taskArguments[paramName] = definition.defaultValue;\n        }\n    }\n    _isCLAParamName(str, paramDefinitions) {\n        if (!this._hasCLAParamNameFormat(str)) {\n            return false;\n        }\n        const name = ArgumentsParser.cLAToParamName(str);\n        return paramDefinitions[name] !== undefined;\n    }\n    _hasCLAParamNameFormat(str) {\n        return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n    }\n    _parseArgumentAt(rawCLAs, index, paramDefinitions, parsedArguments) {\n        const claArg = rawCLAs[index];\n        const paramName = ArgumentsParser.cLAToParamName(claArg);\n        const definition = paramDefinitions[paramName];\n        if (parsedArguments[paramName] !== undefined) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.REPEATED_PARAM, {\n                param: claArg,\n            });\n        }\n        if (definition.isFlag) {\n            parsedArguments[paramName] = true;\n        }\n        else {\n            index++;\n            const value = rawCLAs[index];\n            if (value === undefined) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n                    param: ArgumentsParser.paramNameToCLA(paramName),\n                });\n            }\n            // We only parse the arguments of non-subtasks, and those only\n            // accept CLIArgumentTypes.\n            const type = definition.type;\n            parsedArguments[paramName] = type.parse(paramName, value);\n        }\n        return index;\n    }\n    _parsePositionalParamArgs(rawPositionalParamArgs, positionalParamDefinitions) {\n        const args = {};\n        for (let i = 0; i < positionalParamDefinitions.length; i++) {\n            const definition = positionalParamDefinitions[i];\n            // We only parse the arguments of non-subtasks, and those only\n            // accept CLIArgumentTypes.\n            const type = definition.type;\n            const rawArg = rawPositionalParamArgs[i];\n            if (rawArg === undefined) {\n                if (!definition.isOptional) {\n                    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n                        param: definition.name,\n                    });\n                }\n                args[definition.name] = definition.defaultValue;\n            }\n            else if (!definition.isVariadic) {\n                args[definition.name] = type.parse(definition.name, rawArg);\n            }\n            else {\n                args[definition.name] = rawPositionalParamArgs\n                    .slice(i)\n                    .map((raw) => type.parse(definition.name, raw));\n            }\n        }\n        const lastDefinition = positionalParamDefinitions[positionalParamDefinitions.length - 1];\n        const hasVariadicParam = lastDefinition !== undefined && lastDefinition.isVariadic;\n        if (!hasVariadicParam &&\n            rawPositionalParamArgs.length > positionalParamDefinitions.length) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n                argument: rawPositionalParamArgs[positionalParamDefinitions.length],\n            });\n        }\n        return args;\n    }\n}\nexports.ArgumentsParser = ArgumentsParser;\nArgumentsParser.PARAM_PREFIX = \"--\";\n//# sourceMappingURL=ArgumentsParser.js.map"]},"metadata":{},"sourceType":"script"}