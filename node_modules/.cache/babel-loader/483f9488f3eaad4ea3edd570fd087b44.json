{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getArtifactFromContractOutput = exports.Artifacts = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst os = __importStar(require(\"os\"));\n\nconst path = __importStar(require(\"path\"));\n\nconst contract_names_1 = require(\"../utils/contract-names\");\n\nconst source_names_1 = require(\"../utils/source-names\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./core/errors\");\n\nconst errors_list_1 = require(\"./core/errors-list\");\n\nconst glob_1 = require(\"./util/glob\");\n\nconst hash_1 = require(\"./util/hash\");\n\nconst log = debug_1.default(\"hardhat:core:artifacts\");\n\nclass Artifacts {\n  constructor(_artifactsPath) {\n    this._artifactsPath = _artifactsPath;\n    this._buildInfosGlob = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME, \"**/*.json\");\n    this._dbgsGlob = path.join(this._artifactsPath, \"**/*.dbg.json\");\n  }\n\n  async readArtifact(name) {\n    const {\n      trueCasePath\n    } = await Promise.resolve().then(() => __importStar(require(\"true-case-path\")));\n    const artifactPath = await this._getArtifactPath(name);\n\n    try {\n      const trueCaseArtifactPath = await trueCasePath(path.relative(this._artifactsPath, artifactPath), this._artifactsPath);\n\n      if (artifactPath !== trueCaseArtifactPath) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: trueCaseArtifactPath,\n          incorrect: artifactPath\n        });\n      }\n\n      return await fs_extra_1.default.readJson(trueCaseArtifactPath);\n    } catch (error) {\n      if (typeof error.message === \"string\" && error.message.includes(\"no matching file exists\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.INTERNAL.WRONG_ARTIFACT_PATH, {\n          contractName: name,\n          artifactPath\n        });\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  readArtifactSync(name) {\n    const {\n      trueCasePathSync\n    } = require(\"true-case-path\");\n\n    const artifactPath = this._getArtifactPathSync(name);\n\n    try {\n      const trueCaseArtifactPath = trueCasePathSync(path.relative(this._artifactsPath, artifactPath), this._artifactsPath);\n\n      if (artifactPath !== trueCaseArtifactPath) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n          correct: trueCaseArtifactPath,\n          incorrect: artifactPath\n        });\n      }\n\n      return fs_extra_1.default.readJsonSync(trueCaseArtifactPath);\n    } catch (error) {\n      if (typeof error.message === \"string\" && error.message.includes(\"no matching file exists\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.INTERNAL.WRONG_ARTIFACT_PATH, {\n          contractName: name,\n          artifactPath\n        });\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async artifactExists(name) {\n    try {\n      await this.readArtifact(name);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  async getAllFullyQualifiedNames() {\n    const paths = await this.getArtifactPaths();\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  async getBuildInfo(fullyQualifiedName) {\n    const artifactPath = this._getArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n    if (buildInfoPath === undefined) {\n      return undefined;\n    }\n\n    return fs_extra_1.default.readJSON(buildInfoPath);\n  }\n\n  async getArtifactPaths() {\n    const paths = await glob_1.glob(path.join(this._artifactsPath, \"**/*.json\"), {\n      ignore: [this._buildInfosGlob, this._dbgsGlob]\n    });\n    return paths.sort();\n  }\n\n  async getBuildInfoPaths() {\n    const paths = await glob_1.glob(this._buildInfosGlob);\n    return paths.sort();\n  }\n\n  async getDebugFilePaths() {\n    const paths = await glob_1.glob(this._dbgsGlob);\n    return paths.sort();\n  }\n\n  async saveArtifactAndDebugFile(artifact, pathToBuildInfo) {\n    // artifact\n    const fullyQualifiedName = contract_names_1.getFullyQualifiedName(artifact.sourceName, artifact.contractName);\n\n    const artifactPath = this._getArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    await fs_extra_1.default.ensureDir(path.dirname(artifactPath)); // write artifact\n\n    await fs_extra_1.default.writeJSON(artifactPath, artifact, {\n      spaces: 2\n    });\n\n    if (pathToBuildInfo === undefined) {\n      return;\n    } // save debug file\n\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n\n    const debugFile = this._createDebugFile(artifactPath, pathToBuildInfo);\n\n    await fs_extra_1.default.writeJSON(debugFilePath, debugFile, {\n      spaces: 2\n    });\n  }\n\n  async saveBuildInfo(solcVersion, solcLongVersion, input, output) {\n    const buildInfoDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n    await fs_extra_1.default.ensureDir(buildInfoDir);\n\n    const buildInfoName = this._getBuildInfoName(solcVersion, solcLongVersion, input);\n\n    const buildInfo = this._createBuildInfo(buildInfoName, solcVersion, solcLongVersion, input, output);\n\n    const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n    await fs_extra_1.default.writeJson(buildInfoPath, buildInfo, {\n      spaces: 2\n    });\n    return buildInfoPath;\n  }\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n\n\n  async removeObsoleteArtifacts(artifactsEmittedPerFile) {\n    const validArtifactsPaths = new Set();\n\n    for (const {\n      sourceName,\n      artifacts\n    } of artifactsEmittedPerFile) {\n      for (const artifactName of artifacts) {\n        validArtifactsPaths.add(this._getArtifactPathSync(contract_names_1.getFullyQualifiedName(sourceName, artifactName)));\n      }\n    }\n\n    const existingArtifactsPaths = await this.getArtifactPaths();\n\n    for (const artifactPath of existingArtifactsPaths) {\n      if (!validArtifactsPaths.has(artifactPath)) {\n        await this._removeArtifactFiles(artifactPath);\n      }\n    }\n  }\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n\n\n  async removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n    const validBuildInfos = new Set();\n\n    for (const debugFile of debugFiles) {\n      const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n\n      if (buildInfoFile !== undefined) {\n        validBuildInfos.add(path.resolve(path.dirname(debugFile), buildInfoFile));\n      }\n    }\n\n    const buildInfoFiles = await this.getBuildInfoPaths();\n\n    for (const buildInfoFile of buildInfoFiles) {\n      if (!validBuildInfos.has(buildInfoFile)) {\n        log(`Removing buildInfo '${buildInfoFile}'`);\n        await fs_extra_1.default.unlink(buildInfoFile);\n      }\n    }\n  }\n\n  _getBuildInfoName(solcVersion, solcLongVersion, input) {\n    const json = JSON.stringify({\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input\n    });\n    return hash_1.createNonCryptographicHashBasedIdentifier(Buffer.from(json)).toString(\"hex\");\n  }\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   */\n\n\n  async _getArtifactPath(name) {\n    if (contract_names_1.isFullyQualifiedName(name)) {\n      return this._getArtifactPathFromFullyQualifiedName(name);\n    }\n\n    const files = await this.getArtifactPaths();\n    return this._getArtifactPathFromFiles(name, files);\n  }\n\n  _createBuildInfo(id, solcVersion, solcLongVersion, input, output) {\n    return {\n      id,\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output\n    };\n  }\n\n  _createDebugFile(artifactPath, pathToBuildInfo) {\n    const relativePathToBuildInfo = path.relative(path.dirname(artifactPath), pathToBuildInfo);\n    const debugFile = {\n      _format: constants_1.DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo\n    };\n    return debugFile;\n  }\n\n  _getArtifactPathsSync() {\n    return glob_1.globSync(path.join(this._artifactsPath, \"**/*.json\"), {\n      ignore: [this._buildInfosGlob, this._dbgsGlob]\n    });\n  }\n  /**\n   * Sync version of _getArtifactPath\n   */\n\n\n  _getArtifactPathSync(name) {\n    if (contract_names_1.isFullyQualifiedName(name)) {\n      return this._getArtifactPathFromFullyQualifiedName(name);\n    }\n\n    const files = this._getArtifactPathsSync();\n\n    return this._getArtifactPathFromFiles(name, files);\n  }\n\n  _getArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = contract_names_1.parseFullyQualifiedName(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  _getDebugFilePath(artifactPath) {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n\n  _getArtifactPathFromFiles(contractName, files) {\n    const matchingFiles = files.filter(file => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n\n    if (matchingFiles.length === 0) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n        contractName\n      });\n    }\n\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map(file => this._getFullyQualifiedNameFromPath(file)).map(path.normalize);\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL)\n      });\n    }\n\n    return matchingFiles[0];\n  }\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n\n\n  _getFullyQualifiedNameFromPath(absolutePath) {\n    const sourceName = source_names_1.replaceBackslashes(path.relative(this._artifactsPath, path.dirname(absolutePath)));\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n    return contract_names_1.getFullyQualifiedName(sourceName, contractName);\n  }\n  /**\n   * Remove the artifact file, its debug file and, if it exists, its build\n   * info file.\n   */\n\n\n  async _removeArtifactFiles(artifactPath) {\n    await fs_extra_1.default.remove(artifactPath);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n    await fs_extra_1.default.remove(debugFilePath);\n\n    if (buildInfoPath !== undefined) {\n      await fs_extra_1.default.remove(buildInfoPath);\n    }\n  }\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n\n\n  async _getBuildInfoFromDebugFile(debugFilePath) {\n    if (await fs_extra_1.default.pathExists(debugFilePath)) {\n      const {\n        buildInfo\n      } = await fs_extra_1.default.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n\n    return undefined;\n  }\n\n}\n\nexports.Artifacts = Artifacts;\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\n\nfunction getArtifactFromContractOutput(sourceName, contractName, contractOutput) {\n  const evmBytecode = contractOutput.evm && contractOutput.evm.bytecode;\n  let bytecode = evmBytecode && evmBytecode.object ? evmBytecode.object : \"\";\n\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n\n  const evmDeployedBytecode = contractOutput.evm && contractOutput.evm.deployedBytecode;\n  let deployedBytecode = evmDeployedBytecode && evmDeployedBytecode.object ? evmDeployedBytecode.object : \"\";\n\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n\n  const linkReferences = evmBytecode && evmBytecode.linkReferences ? evmBytecode.linkReferences : {};\n  const deployedLinkReferences = evmDeployedBytecode && evmDeployedBytecode.linkReferences ? evmDeployedBytecode.linkReferences : {};\n  return {\n    _format: constants_1.ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences\n  };\n}\n\nexports.getArtifactFromContractOutput = getArtifactFromContractOutput;","map":{"version":3,"sources":["../src/internal/artifacts.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getArtifactFromContractOutput = exports.Artifacts = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst contract_names_1 = require(\"../utils/contract-names\");\nconst source_names_1 = require(\"../utils/source-names\");\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"./core/errors\");\nconst errors_list_1 = require(\"./core/errors-list\");\nconst glob_1 = require(\"./util/glob\");\nconst hash_1 = require(\"./util/hash\");\nconst log = debug_1.default(\"hardhat:core:artifacts\");\nclass Artifacts {\n    constructor(_artifactsPath) {\n        this._artifactsPath = _artifactsPath;\n        this._buildInfosGlob = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME, \"**/*.json\");\n        this._dbgsGlob = path.join(this._artifactsPath, \"**/*.dbg.json\");\n    }\n    async readArtifact(name) {\n        const { trueCasePath } = await Promise.resolve().then(() => __importStar(require(\"true-case-path\")));\n        const artifactPath = await this._getArtifactPath(name);\n        try {\n            const trueCaseArtifactPath = await trueCasePath(path.relative(this._artifactsPath, artifactPath), this._artifactsPath);\n            if (artifactPath !== trueCaseArtifactPath) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n                    correct: trueCaseArtifactPath,\n                    incorrect: artifactPath,\n                });\n            }\n            return await fs_extra_1.default.readJson(trueCaseArtifactPath);\n        }\n        catch (error) {\n            if (typeof error.message === \"string\" &&\n                error.message.includes(\"no matching file exists\")) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.INTERNAL.WRONG_ARTIFACT_PATH, {\n                    contractName: name,\n                    artifactPath,\n                });\n            }\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n    }\n    readArtifactSync(name) {\n        const { trueCasePathSync } = require(\"true-case-path\");\n        const artifactPath = this._getArtifactPathSync(name);\n        try {\n            const trueCaseArtifactPath = trueCasePathSync(path.relative(this._artifactsPath, artifactPath), this._artifactsPath);\n            if (artifactPath !== trueCaseArtifactPath) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n                    correct: trueCaseArtifactPath,\n                    incorrect: artifactPath,\n                });\n            }\n            return fs_extra_1.default.readJsonSync(trueCaseArtifactPath);\n        }\n        catch (error) {\n            if (typeof error.message === \"string\" &&\n                error.message.includes(\"no matching file exists\")) {\n                throw new errors_1.HardhatError(errors_list_1.ERRORS.INTERNAL.WRONG_ARTIFACT_PATH, {\n                    contractName: name,\n                    artifactPath,\n                });\n            }\n            // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n            throw error;\n        }\n    }\n    async artifactExists(name) {\n        try {\n            await this.readArtifact(name);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async getAllFullyQualifiedNames() {\n        const paths = await this.getArtifactPaths();\n        return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n    }\n    async getBuildInfo(fullyQualifiedName) {\n        const artifactPath = this._getArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n        const debugFilePath = this._getDebugFilePath(artifactPath);\n        const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n        if (buildInfoPath === undefined) {\n            return undefined;\n        }\n        return fs_extra_1.default.readJSON(buildInfoPath);\n    }\n    async getArtifactPaths() {\n        const paths = await glob_1.glob(path.join(this._artifactsPath, \"**/*.json\"), {\n            ignore: [this._buildInfosGlob, this._dbgsGlob],\n        });\n        return paths.sort();\n    }\n    async getBuildInfoPaths() {\n        const paths = await glob_1.glob(this._buildInfosGlob);\n        return paths.sort();\n    }\n    async getDebugFilePaths() {\n        const paths = await glob_1.glob(this._dbgsGlob);\n        return paths.sort();\n    }\n    async saveArtifactAndDebugFile(artifact, pathToBuildInfo) {\n        // artifact\n        const fullyQualifiedName = contract_names_1.getFullyQualifiedName(artifact.sourceName, artifact.contractName);\n        const artifactPath = this._getArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n        await fs_extra_1.default.ensureDir(path.dirname(artifactPath));\n        // write artifact\n        await fs_extra_1.default.writeJSON(artifactPath, artifact, {\n            spaces: 2,\n        });\n        if (pathToBuildInfo === undefined) {\n            return;\n        }\n        // save debug file\n        const debugFilePath = this._getDebugFilePath(artifactPath);\n        const debugFile = this._createDebugFile(artifactPath, pathToBuildInfo);\n        await fs_extra_1.default.writeJSON(debugFilePath, debugFile, {\n            spaces: 2,\n        });\n    }\n    async saveBuildInfo(solcVersion, solcLongVersion, input, output) {\n        const buildInfoDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n        await fs_extra_1.default.ensureDir(buildInfoDir);\n        const buildInfoName = this._getBuildInfoName(solcVersion, solcLongVersion, input);\n        const buildInfo = this._createBuildInfo(buildInfoName, solcVersion, solcLongVersion, input, output);\n        const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n        await fs_extra_1.default.writeJson(buildInfoPath, buildInfo, { spaces: 2 });\n        return buildInfoPath;\n    }\n    /**\n     * Remove all artifacts that don't correspond to the current solidity files\n     */\n    async removeObsoleteArtifacts(artifactsEmittedPerFile) {\n        const validArtifactsPaths = new Set();\n        for (const { sourceName, artifacts } of artifactsEmittedPerFile) {\n            for (const artifactName of artifacts) {\n                validArtifactsPaths.add(this._getArtifactPathSync(contract_names_1.getFullyQualifiedName(sourceName, artifactName)));\n            }\n        }\n        const existingArtifactsPaths = await this.getArtifactPaths();\n        for (const artifactPath of existingArtifactsPaths) {\n            if (!validArtifactsPaths.has(artifactPath)) {\n                await this._removeArtifactFiles(artifactPath);\n            }\n        }\n    }\n    /**\n     * Remove all build infos that aren't used by any debug file\n     */\n    async removeObsoleteBuildInfos() {\n        const debugFiles = await this.getDebugFilePaths();\n        const validBuildInfos = new Set();\n        for (const debugFile of debugFiles) {\n            const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n            if (buildInfoFile !== undefined) {\n                validBuildInfos.add(path.resolve(path.dirname(debugFile), buildInfoFile));\n            }\n        }\n        const buildInfoFiles = await this.getBuildInfoPaths();\n        for (const buildInfoFile of buildInfoFiles) {\n            if (!validBuildInfos.has(buildInfoFile)) {\n                log(`Removing buildInfo '${buildInfoFile}'`);\n                await fs_extra_1.default.unlink(buildInfoFile);\n            }\n        }\n    }\n    _getBuildInfoName(solcVersion, solcLongVersion, input) {\n        const json = JSON.stringify({\n            _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n            solcVersion,\n            solcLongVersion,\n            input,\n        });\n        return hash_1.createNonCryptographicHashBasedIdentifier(Buffer.from(json)).toString(\"hex\");\n    }\n    /**\n     * Returns the absolute path to the artifact that corresponds to the given\n     * name.\n     *\n     * If the name is fully qualified, the path is computed from it.  If not, an\n     * artifact that matches the given name is searched in the existing artifacts.\n     * If there is an ambiguity, an error is thrown.\n     */\n    async _getArtifactPath(name) {\n        if (contract_names_1.isFullyQualifiedName(name)) {\n            return this._getArtifactPathFromFullyQualifiedName(name);\n        }\n        const files = await this.getArtifactPaths();\n        return this._getArtifactPathFromFiles(name, files);\n    }\n    _createBuildInfo(id, solcVersion, solcLongVersion, input, output) {\n        return {\n            id,\n            _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n            solcVersion,\n            solcLongVersion,\n            input,\n            output,\n        };\n    }\n    _createDebugFile(artifactPath, pathToBuildInfo) {\n        const relativePathToBuildInfo = path.relative(path.dirname(artifactPath), pathToBuildInfo);\n        const debugFile = {\n            _format: constants_1.DEBUG_FILE_FORMAT_VERSION,\n            buildInfo: relativePathToBuildInfo,\n        };\n        return debugFile;\n    }\n    _getArtifactPathsSync() {\n        return glob_1.globSync(path.join(this._artifactsPath, \"**/*.json\"), {\n            ignore: [this._buildInfosGlob, this._dbgsGlob],\n        });\n    }\n    /**\n     * Sync version of _getArtifactPath\n     */\n    _getArtifactPathSync(name) {\n        if (contract_names_1.isFullyQualifiedName(name)) {\n            return this._getArtifactPathFromFullyQualifiedName(name);\n        }\n        const files = this._getArtifactPathsSync();\n        return this._getArtifactPathFromFiles(name, files);\n    }\n    _getArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n        const { sourceName, contractName } = contract_names_1.parseFullyQualifiedName(fullyQualifiedName);\n        return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n    }\n    _getDebugFilePath(artifactPath) {\n        return artifactPath.replace(/\\.json$/, \".dbg.json\");\n    }\n    _getArtifactPathFromFiles(contractName, files) {\n        const matchingFiles = files.filter((file) => {\n            return path.basename(file) === `${contractName}.json`;\n        });\n        if (matchingFiles.length === 0) {\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n                contractName,\n            });\n        }\n        if (matchingFiles.length > 1) {\n            const candidates = matchingFiles\n                .map((file) => this._getFullyQualifiedNameFromPath(file))\n                .map(path.normalize);\n            throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n                contractName,\n                candidates: candidates.join(os.EOL),\n            });\n        }\n        return matchingFiles[0];\n    }\n    /**\n     * Returns the FQN of a contract giving the absolute path to its artifact.\n     *\n     * For example, given a path like\n     * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n     * FQN `contracts/Foo.sol:Bar`\n     */\n    _getFullyQualifiedNameFromPath(absolutePath) {\n        const sourceName = source_names_1.replaceBackslashes(path.relative(this._artifactsPath, path.dirname(absolutePath)));\n        const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n        return contract_names_1.getFullyQualifiedName(sourceName, contractName);\n    }\n    /**\n     * Remove the artifact file, its debug file and, if it exists, its build\n     * info file.\n     */\n    async _removeArtifactFiles(artifactPath) {\n        await fs_extra_1.default.remove(artifactPath);\n        const debugFilePath = this._getDebugFilePath(artifactPath);\n        const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n        await fs_extra_1.default.remove(debugFilePath);\n        if (buildInfoPath !== undefined) {\n            await fs_extra_1.default.remove(buildInfoPath);\n        }\n    }\n    /**\n     * Given the path to a debug file, returns the absolute path to its\n     * corresponding build info file if it exists, or undefined otherwise.\n     */\n    async _getBuildInfoFromDebugFile(debugFilePath) {\n        if (await fs_extra_1.default.pathExists(debugFilePath)) {\n            const { buildInfo } = await fs_extra_1.default.readJson(debugFilePath);\n            return path.resolve(path.dirname(debugFilePath), buildInfo);\n        }\n        return undefined;\n    }\n}\nexports.Artifacts = Artifacts;\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\nfunction getArtifactFromContractOutput(sourceName, contractName, contractOutput) {\n    const evmBytecode = contractOutput.evm && contractOutput.evm.bytecode;\n    let bytecode = evmBytecode && evmBytecode.object ? evmBytecode.object : \"\";\n    if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n        bytecode = `0x${bytecode}`;\n    }\n    const evmDeployedBytecode = contractOutput.evm && contractOutput.evm.deployedBytecode;\n    let deployedBytecode = evmDeployedBytecode && evmDeployedBytecode.object\n        ? evmDeployedBytecode.object\n        : \"\";\n    if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n        deployedBytecode = `0x${deployedBytecode}`;\n    }\n    const linkReferences = evmBytecode && evmBytecode.linkReferences ? evmBytecode.linkReferences : {};\n    const deployedLinkReferences = evmDeployedBytecode && evmDeployedBytecode.linkReferences\n        ? evmDeployedBytecode.linkReferences\n        : {};\n    return {\n        _format: constants_1.ARTIFACT_FORMAT_VERSION,\n        contractName,\n        sourceName,\n        abi: contractOutput.abi,\n        bytecode,\n        deployedBytecode,\n        linkReferences,\n        deployedLinkReferences,\n    };\n}\nexports.getArtifactFromContractOutput = getArtifactFromContractOutput;\n//# sourceMappingURL=artifacts.js.map"]},"metadata":{},"sourceType":"script"}