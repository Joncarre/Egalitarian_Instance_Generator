{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcServer = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst http_1 = __importDefault(require(\"http\"));\n\nconst http_2 = require(\"../../core/providers/http\");\n\nconst handler_1 = __importDefault(require(\"./handler\"));\n\nconst log = debug_1.default(\"hardhat:core:hardhat-network:jsonrpc\");\n\nclass JsonRpcServer {\n  constructor(config) {\n    this.getProvider = (name = \"json-rpc\") => {\n      const {\n        address,\n        port\n      } = this._httpServer.address(); // TCP sockets return AddressInfo\n\n\n      return new http_2.HttpProvider(`http://${address}:${port}/`, name);\n    };\n\n    this.listen = () => {\n      return new Promise(resolve => {\n        log(`Starting JSON-RPC server on port ${this._config.port}`);\n\n        this._httpServer.listen(this._config.port, this._config.hostname, () => {\n          // We get the address and port directly from the server in order to handle random port allocation with `0`.\n          const address = this._httpServer.address(); // TCP sockets return AddressInfo\n\n\n          resolve(address);\n        });\n      });\n    };\n\n    this.waitUntilClosed = async () => {\n      const httpServerClosed = new Promise(resolve => {\n        this._httpServer.once(\"close\", resolve);\n      });\n      const wsServerClosed = new Promise(resolve => {\n        this._wsServer.once(\"close\", resolve);\n      });\n      await Promise.all([httpServerClosed, wsServerClosed]);\n    };\n\n    this.close = async () => {\n      await Promise.all([new Promise((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n\n        this._httpServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }), new Promise((resolve, reject) => {\n        log(\"Closing websocket server\");\n\n        this._wsServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      })]);\n    };\n\n    const {\n      Server: WSServer\n    } = require(\"ws\");\n\n    this._config = config;\n    const handler = new handler_1.default(config.provider);\n    this._httpServer = http_1.default.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer\n    });\n\n    this._httpServer.on(\"request\", handler.handleHttp);\n\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n\n}\n\nexports.JsonRpcServer = JsonRpcServer;","map":{"version":3,"sources":["../../../src/internal/hardhat-network/jsonrpc/server.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonRpcServer = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst http_1 = __importDefault(require(\"http\"));\nconst http_2 = require(\"../../core/providers/http\");\nconst handler_1 = __importDefault(require(\"./handler\"));\nconst log = debug_1.default(\"hardhat:core:hardhat-network:jsonrpc\");\nclass JsonRpcServer {\n    constructor(config) {\n        this.getProvider = (name = \"json-rpc\") => {\n            const { address, port } = this._httpServer.address(); // TCP sockets return AddressInfo\n            return new http_2.HttpProvider(`http://${address}:${port}/`, name);\n        };\n        this.listen = () => {\n            return new Promise((resolve) => {\n                log(`Starting JSON-RPC server on port ${this._config.port}`);\n                this._httpServer.listen(this._config.port, this._config.hostname, () => {\n                    // We get the address and port directly from the server in order to handle random port allocation with `0`.\n                    const address = this._httpServer.address(); // TCP sockets return AddressInfo\n                    resolve(address);\n                });\n            });\n        };\n        this.waitUntilClosed = async () => {\n            const httpServerClosed = new Promise((resolve) => {\n                this._httpServer.once(\"close\", resolve);\n            });\n            const wsServerClosed = new Promise((resolve) => {\n                this._wsServer.once(\"close\", resolve);\n            });\n            await Promise.all([httpServerClosed, wsServerClosed]);\n        };\n        this.close = async () => {\n            await Promise.all([\n                new Promise((resolve, reject) => {\n                    log(\"Closing JSON-RPC server\");\n                    this._httpServer.close((err) => {\n                        if (err !== null && err !== undefined) {\n                            log(\"Failed to close JSON-RPC server\");\n                            reject(err);\n                            return;\n                        }\n                        log(\"JSON-RPC server closed\");\n                        resolve();\n                    });\n                }),\n                new Promise((resolve, reject) => {\n                    log(\"Closing websocket server\");\n                    this._wsServer.close((err) => {\n                        if (err !== null && err !== undefined) {\n                            log(\"Failed to close websocket server\");\n                            reject(err);\n                            return;\n                        }\n                        log(\"Websocket server closed\");\n                        resolve();\n                    });\n                }),\n            ]);\n        };\n        const { Server: WSServer } = require(\"ws\");\n        this._config = config;\n        const handler = new handler_1.default(config.provider);\n        this._httpServer = http_1.default.createServer();\n        this._wsServer = new WSServer({\n            server: this._httpServer,\n        });\n        this._httpServer.on(\"request\", handler.handleHttp);\n        this._wsServer.on(\"connection\", handler.handleWs);\n    }\n}\nexports.JsonRpcServer = JsonRpcServer;\n//# sourceMappingURL=server.js.map"]},"metadata":{},"sourceType":"script"}