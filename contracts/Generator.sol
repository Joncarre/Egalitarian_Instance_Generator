// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

// Notas
    // 2. Una solucion es simplemente un reparto. Solo ciframos la solucion. Los hashes del algoritmo usado se quedan igual
    // 6. Si mode = false (0) estamos en unlimited. Si mode = true (1) estamos en limited

/// @title 
/// @author J. Carrero
contract Generator is VRFConsumerBase {
    // Researcher information
    struct Researcher {
        string name;
        string email;
        bool registered;
        uint256[] idInstance;
        uint256[] numberGenerated;
    }
    mapping(uint256 => Researcher) researchers; // secret => researcher

    // Linked information
    struct Link {
        uint256 secret;
    }
    mapping(uint256 => Link) links; // orcid => secret
    
    // Instance information
    struct Instance {
        uint256 id;
        string chain;
        uint256[] setup;
        uint256 dateCreated;
        string solution;
        bool solved;
        uint256 dateSolution;
    }
    mapping(uint256 => Instance) instancesAuction; // id => instanceAuction (even)
    mapping(uint256 => Instance) instancesOptimization; // id => instanceOptimization (odd)

    // Information about the solution hashed
    struct Hash {
        string solution_hash;
        string algorithm_hash;
        string hash_method;
    }
    mapping(uint256 => Hash) hashes; // id => hash information

    // VRF variables
    bytes32 internal keyHash;
    uint256 internal fee;
    uint256 public randomResult;

    // General variables
    uint256 nonce;
    uint256 idInstance;
    
    // Egalitarian variables
    uint256 maxRandonNumbers;
    
    /// @notice Main constructor
    constructor() 
      VRFConsumerBase(
            0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, // VRF Coordinator
            0xa36085F69e2889c224210F603D836748e7dC0088  // LINK Token
        )
    {
        keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
        fee = 0.1 * 10 ** 18; // 0.1 LINK (it varies by network)
        nonce = 0;
        idInstance = 0;
        maxRandonNumbers = 2100; // Around 400 for B generated so: 400*5 = 2000
    }
    
    // ---------------------------------- Researchers functions ----------------------------------

    /// @notice Registers a new Researcher 
    /// @param _secret, _name, _email, _orcid. Information about the researcher, stored in the struct
    function setResearcher(uint256 _secret, string memory _name, string memory _email, uint256 _orcid) public {
        require(!researchers[_secret].registered, "This ORCID is already registered.");
        uint256[] memory empty;
        researchers[_secret] = Researcher(_name, _email, true, empty, empty);
        links[_orcid] = Link(_secret);
    }
    
    /// @notice Get the array which contains all the dates for the random numbers generated
    /// @param _secret password generated using SHA256
    /// @return numberGenerated array with all the numbers generated by '_secret' researcher
    function getDateNumber(uint256 _secret) public view returns (uint256[] memory){
        return researchers[_secret].numberGenerated;
    }

    /// @notice Check the secret number
    /// @param _secret password generated using SHA256
    /// @return regustered, indicates if the researcher is registered
    function checkPass(uint _secret) public view returns (bool) {
        return researchers[_secret].registered;
    }

    // ---------------------------------- Instance functions ----------------------------------

    /// @notice Get instance. If _id is even we have to check in instancesAuction, otherwise we check in instancesOptimization
    /// @param _id instance
    /// @return instance itself
    function getInstance(uint256 _id) public view returns (uint256, string memory, uint256[] memory, uint256, string memory, bool, uint256){
        if(_id % 2 == 0)
            return (instancesAuction[_id].id, instancesAuction[_id].chain, instancesAuction[_id].setup, instancesAuction[_id].dateCreated, instancesAuction[_id].solution, instancesAuction[_id].solved, instancesAuction[_id].dateSolution);
        else
            return (instancesOptimization[_id].id, instancesOptimization[_id].chain, instancesOptimization[_id].setup, instancesOptimization[_id].dateCreated, instancesOptimization[_id].solution, instancesOptimization[_id].solved, instancesOptimization[_id].dateSolution);
    }

    /// @notice Get hash information about a instance
    /// @param _id instance
    /// @return array with the information about the solution of the instance
    function getHash(uint256 _id) public view returns (string memory, string memory, string memory){
        return (hashes[_id].solution_hash, hashes[_id].algorithm_hash, hashes[_id].hash_method);
    }

    /// @notice Get all instances
    /// @param _orcid of the researcher
    /// @return 
    function getAllInstances(uint256 _orcid) public view returns (Instance[] memory) {
        uint256 secret = links[_orcid].secret;
        Instance[] memory result = new Instance[](researchers[secret].idInstance.length);
        for(uint256 i = 0; i < researchers[secret].idInstance.length; i++){
            if(researchers[secret].idInstance[i] % 2 == 0)
                result[i] = instancesAuction[researchers[secret].idInstance[i]]; 
            else
                result[i] = instancesOptimization[researchers[secret].idInstance[i]];  
        }
        return result;
    }
    
    /// @notice Set the solution for the _id instance
    /// @param _secret, _id, _solution, _algorithm_hash, _hash_method. Password from the researcher, instance and information about the solution
    /// @return validResearcher indicates if the researcher has been able to solve the instance
    function solveInstance(uint256 _secret, uint256 _id, string memory _solution, string memory _algorithm_hash, string memory _hash_method) public returns (bool) {
        bool validResearcher = false;
        uint256 i = 0;
        while(validResearcher == false && i < researchers[_secret].idInstance.length){
            if(researchers[_secret].idInstance[i] == _id)
                validResearcher = true;
            i++;
        }
        if(validResearcher == true){
            if(_id % 2 == 0){
                instancesAuction[_id].solution = _solution;
                instancesAuction[_id].solved = true;
                instancesAuction[_id].dateSolution = block.timestamp;  
            }else{
                instancesOptimization[_id].solution = _solution;
                instancesOptimization[_id].solved = true;
                instancesOptimization[_id].dateSolution = block.timestamp;  
            }
            hashes[_id].solution_hash = _solution;
            hashes[_id].algorithm_hash = _algorithm_hash;
            hashes[_id].hash_method = _hash_method;      
        }
        return validResearcher;
    }

    // ------------------------------- Egalitarian functions --------------------------------

    /// @notice Generates a new Instance from A generator
    /// @param _agents, _resources, _secret, _numInstances and _mode 
    function createAInstance(uint256 _agents, uint256 _resources, uint256 _secret, uint256 _numInstances, uint256 _mode) public {
        uint256[] memory setup = new uint256[](3); // It contains three numbers: the first indicates the agents, the second one the number of resources and the third one the mode
        if(_agents == 0){
            _agents = random(10);
        }
        if(_agents == 0){
            _agents = 1;
        }
        if(_resources == 0){
            _resources = random(40);
        }
        if(_resources == 0){
            _resources = 1;
        }
        setup[0] = _agents;
        setup[1] = _resources;
        setup[2] = _mode;
        uint256 symbols = 1000;
        uint256 totalPreferences = _agents * _resources;
        for(uint k = 0; k < _numInstances; k++){
            string memory chain = "";
            for(uint256 i = 0; i < totalPreferences; i++){
                chain = append(chain, intToString(random(symbols)));
                chain = append(chain, " ");
            }
            instancesAuction[idInstance] = Instance(idInstance, chain, setup, block.timestamp, "Unresolved", false, 0);
            researchers[_secret].idInstance.push(idInstance);
            idInstance++;
            instancesOptimization[idInstance] = Instance(idInstance, chain, setup, block.timestamp, "Unresolved", false, 0);
            researchers[_secret].idInstance.push(idInstance);
            idInstance++;
        }
    }

    /// @notice Generates a new Instance from B generator
    /// @param _agents, _resources, _secret, _numInstances and _mode 
    function createBInstance(uint256 _agents, uint256 _resources, uint256 _secret, uint256 _numInstances, uint256 _mode) public {
        uint256[] memory setup = new uint256[](3); // It contains three numbers: the first indicates the agents, the second one the number of resources and the third one the mode
        if(_agents == 0){
            _agents = random(10);
        }
        if(_agents == 0){
            _agents = 1;
        }
        if(_resources == 0){
            _resources = random(40);
        }
        if(_resources == 0){
            _resources = 1;
        }
        setup[0] = _agents;
        setup[1] = _resources;
        setup[2] = _mode;
        uint256 totalPreferences = _agents * _resources;
        for(uint k = 0; k < _numInstances; k++){
            string memory chain = "";
            uint256 cont = 0;
            uint256 symbols = 1000;
            uint256 interval = symbols / _resources;
            for(uint256 i = 0; i < totalPreferences; i++){
                if(cont == _resources){
                    symbols = 1000;
                    cont = 0;
                }
                chain = append(chain, intToString(random(symbols)));
                chain = append(chain, " ");
                symbols = symbols - interval;
                cont++;
            }
            instancesAuction[idInstance] = Instance(idInstance, chain, setup, block.timestamp, "Unresolved", false, 0);
            researchers[_secret].idInstance.push(idInstance);
            idInstance++;
            instancesOptimization[idInstance] = Instance(idInstance, chain, setup, block.timestamp, "Unresolved", false, 0);
            researchers[_secret].idInstance.push(idInstance);
            idInstance++;
        }
    }

    /// @notice Generates a new Instance from C generator
    /// @param _agents, _resources, _secret, _numInstances and _mode 
    function createCInstance(uint256 _agents, uint256 _resources, uint256 _secret, uint256 _numInstances, uint256 _mode) public {
        uint256[] memory setup = new uint256[](3); // It contains three numbers: the first indicates the agents, the second one the number of resources and the third one the mode
        if(_agents == 0){
            _agents = random(10);
        }
        if(_agents == 0){
            _agents = 1;
        }
        if(_resources == 0){
            _resources = random(40);
        }
        if(_resources == 0){
            _resources = 1;
        }
        setup[0] = _agents;
        setup[1] = _resources;
        setup[2] = _mode;   
        uint256 totalPreferences = _agents * _resources;
        for(uint k = 0; k < _numInstances; k++){
            string memory chain = "";
            uint256 symbols = 0;
            uint256 interval = 1000 / _resources;
            uint256 cont = 0;
            for(uint256 i = 0; i < totalPreferences; i++){
                symbols = symbols + interval;
                chain = append(chain, intToString(random(symbols)));
                chain = append(chain, " ");
                cont++;
                if(cont == _resources){
                    symbols = 0;
                    cont = 0;
                }
            }
            instancesAuction[idInstance] = Instance(idInstance, chain, setup, block.timestamp, "Unresolved", false, 0);
            researchers[_secret].idInstance.push(idInstance);
            idInstance++;
            instancesOptimization[idInstance] = Instance(idInstance, chain, setup, block.timestamp, "Unresolved", false, 0);
            researchers[_secret].idInstance.push(idInstance);
            idInstance++;
        }
    }

    // --------------------------------- VRF functions ----------------------------------

    /// @notice Set the date of the new random number generated
    function getRandomNumber(uint256 _secret) public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
        researchers[_secret].numberGenerated.push(block.timestamp); 
        return requestRandomness(keyHash, fee);
    }

    /// @notice Function used by oracles' call
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResult = randomness;
    }

    /// @notice Generate an array of random numbers
    function expand() internal view returns (uint256[] memory expandedValues) {
        expandedValues = new uint256[](maxRandonNumbers);
        for (uint256 i = 0; i < maxRandonNumbers; i++) {
            expandedValues[i] = uint256(keccak256(abi.encode(randomResult, i))) % 100;
        }
        return expandedValues;
    }

    /// @notice Allows to know kow much LINK we have in the smart contract
    function getRemainingLINK() external view returns (uint256) {
        return LINK.balanceOf(address(this));
    }
   
    // -------------------------------- Support functions --------------------------------

    /// @notice Generates a random number within an interval
    /// @param _interval upper index of the (open) interval of the random value
    /// @dev now, msg.sender and nonce are the timestamp of the block, who made the call and an incremental number respectively
    /// @return randNumber number generated
    function random(uint256 _interval) internal returns (uint256) {
        uint256 randNumber = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, nonce))) % _interval;
        nonce++;
        return randNumber;
    }

    /// @notice Function to concatenate two strings
    function append(string memory _a, string memory _b) internal pure returns (string memory) {
        return string(abi.encodePacked(_a, _b));
    }

    /// @notice Function to convert int to string
    /// @param _i n umber to convert
    /// @return _uintAsString the string returned
    function intToString(uint256 _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return "0";
        }
        uint256 j = _i;
        uint256 len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k = k-1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}